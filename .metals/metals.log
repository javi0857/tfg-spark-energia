2024.10.23 12:51:36 INFO  Started: Metals version 1.3.5 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.94.2.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@6f74b04]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@64c4b7d4]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@6f74b04]
2024.10.23 12:51:36 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.23 12:51:37 INFO  Attempting to connect to the build server...
2024.10.23 12:51:42 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.23 12:51:42 INFO  Attempting to connect to the build server...
2024.10.23 12:51:42 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.23 12:51:42 INFO  time: Connected to build server in 5.47s
2024.10.23 12:51:42 INFO  Connected to Build server: Bloop v1.6.0
2024.10.23 12:51:42 INFO  time: Imported build in 0.16s
2024.10.23 12:51:42 INFO  running doctor check
2024.10.23 12:51:42 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.23 12:51:54 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.23 12:52:07 INFO  time: indexed workspace in 24s
oct 23, 2024 1:03:26 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 90
oct 23, 2024 1:03:26 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 91
oct 23, 2024 1:03:26 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 95
oct 23, 2024 1:03:55 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 276
2024.10.23 13:11:37 INFO  compiling root (1 scala source)
2024.10.23 13:11:40 INFO  time: compiled root in 3.17s
2024.10.23 13:15:39 INFO  compiling root (1 scala source)
2024.10.23 13:15:40 INFO  time: compiled root in 1.18s
2024.10.23 13:17:21 INFO  compiling root (1 scala source)
2024.10.23 13:17:22 INFO  time: compiled root in 1.09s
2024.10.23 13:17:32 INFO  compiling root (1 scala source)
2024.10.23 13:17:33 INFO  time: compiled root in 1.07s
2024.10.23 13:34:01 INFO  compiling root (1 scala source)
2024.10.23 13:34:01 INFO  time: compiled root in 0.85s
2024.10.23 13:34:31 INFO  compiling root (1 scala source)
2024.10.23 13:34:31 INFO  time: compiled root in 0.96s
2024.10.23 13:37:12 INFO  compiling root (1 scala source)
2024.10.23 13:37:12 INFO  time: compiled root in 0.74s
2024.10.23 13:41:26 INFO  compiling root (1 scala source)
2024.10.23 13:41:26 INFO  time: compiled root in 0.68s
oct 23, 2024 1:41:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 892
2024.10.23 13:41:32 INFO  compiling root (1 scala source)
2024.10.23 13:41:32 INFO  time: compiled root in 0.84s
2024.10.23 15:38:45 INFO  compiling root (1 scala source)
2024.10.23 15:38:45 INFO  time: compiled root in 0.99s
2024.10.23 15:45:01 INFO  compiling root (1 scala source)
2024.10.23 15:45:01 INFO  time: compiled root in 0.53s
oct 23, 2024 3:45:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1541
2024.10.23 15:45:14 INFO  compiling root (1 scala source)
2024.10.23 15:45:15 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.23 15:45:15 INFO  time: compiled root in 1.15s
2024.10.23 15:45:32 INFO  compiling root (1 scala source)
2024.10.23 15:45:32 INFO  time: compiled root in 0.73s
2024.10.23 15:51:07 INFO  compiling root (1 scala source)
2024.10.23 15:51:07 INFO  time: compiled root in 0.22s
oct 23, 2024 3:51:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 2591
2024.10.23 15:51:21 INFO  compiling root (1 scala source)
2024.10.23 15:51:21 INFO  time: compiled root in 0.38s
2024.10.23 15:51:38 INFO  compiling root (1 scala source)
2024.10.23 15:51:38 INFO  time: compiled root in 0.23s
2024.10.23 15:52:56 INFO  compiling root (1 scala source)
2024.10.23 15:52:56 INFO  time: compiled root in 0.64s
oct 23, 2024 3:53:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3055
2024.10.23 15:53:55 INFO  compiling root (1 scala source)
2024.10.23 15:53:55 INFO  time: compiled root in 0.26s
2024.10.23 15:54:06 INFO  compiling root (1 scala source)
2024.10.23 15:54:06 INFO  time: compiled root in 0.83s
2024.10.23 15:54:16 INFO  time: code lens generation in 2.92s
2024.10.23 15:54:21 INFO  compiling root (1 scala source)
2024.10.23 15:54:21 INFO  time: compiled root in 0.6s
oct 23, 2024 3:59:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3890
oct 23, 2024 3:59:29 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-23\r_compiler-error_(root)_15-59-29-291.md
oct 23, 2024 3:59:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3975
oct 23, 2024 4:01:19 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4715
2024.10.23 16:03:03 INFO  compiling root (1 scala source)
2024.10.23 16:03:03 INFO  time: compiled root in 0.23s
2024.10.23 16:03:11 INFO  compiling root (1 scala source)
2024.10.23 16:03:11 INFO  time: compiled root in 0.25s
2024.10.23 16:03:39 INFO  compiling root (1 scala source)
2024.10.23 16:03:39 INFO  time: compiled root in 0.24s
2024.10.23 16:03:50 INFO  compiling root (1 scala source)
2024.10.23 16:03:50 INFO  time: compiled root in 0.22s
2024.10.23 16:04:10 INFO  compiling root (1 scala source)
2024.10.23 16:04:10 INFO  time: compiled root in 0.72s
oct 23, 2024 4:09:49 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5360
2024.10.23 16:12:03 INFO  compiling root (1 scala source)
2024.10.23 16:12:03 INFO  time: compiled root in 0.7s
2024.10.23 16:12:08 INFO  compiling root (1 scala source)
2024.10.23 16:12:09 INFO  time: compiled root in 1.04s
2024.10.23 16:12:32 INFO  compiling root (1 scala source)
2024.10.23 16:12:32 INFO  time: compiled root in 0.65s
2024.10.23 16:13:01 INFO  compiling root (1 scala source)
2024.10.23 16:13:01 INFO  time: compiled root in 0.81s
2024.10.23 16:13:40 INFO  compiling root (1 scala source)
2024.10.23 16:13:40 INFO  time: compiled root in 0.61s
2024.10.23 16:14:28 INFO  compiling root (1 scala source)
2024.10.23 16:14:28 INFO  time: compiled root in 0.71s
oct 23, 2024 5:31:01 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6083
oct 23, 2024 5:32:18 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6249
oct 23, 2024 5:33:51 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6415
2024.10.23 17:35:50 INFO  compiling root (1 scala source)
2024.10.23 17:35:52 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.23 17:35:52 INFO  time: compiled root in 2.83s
oct 23, 2024 5:37:45 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6678
oct 23, 2024 5:44:40 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6777
oct 23, 2024 5:47:11 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6965
oct 23, 2024 5:47:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6975
oct 23, 2024 5:47:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6981
2024.10.23 17:47:24 INFO  compiling root (1 scala source)
2024.10.23 17:47:27 INFO  time: compiled root in 2.24s
2024.10.23 17:47:32 INFO  compiling root (1 scala source)
2024.10.23 17:47:32 INFO  time: compiled root in 0.76s
2024.10.23 17:49:53 INFO  compiling root (1 scala source)
2024.10.23 17:49:56 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.23 17:49:56 INFO  time: compiled root in 2.62s
oct 23, 2024 5:49:58 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 7217
2024.10.23 17:50:02 INFO  compiling root (1 scala source)
2024.10.23 17:50:04 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.23 17:50:04 INFO  time: compiled root in 2.52s
oct 23, 2024 5:50:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 7264
oct 23, 2024 5:50:43 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 7330
oct 23, 2024 5:51:33 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 7416
oct 23, 2024 5:51:33 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 7420
2024.10.23 17:51:33 INFO  compiling root (1 scala source)
2024.10.23 17:51:35 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.23 17:51:35 INFO  time: compiled root in 2.78s
2024.10.23 17:53:18 INFO  compiling root (1 scala source)
2024.10.23 17:53:20 INFO  time: compiled root in 1.82s
oct 23, 2024 5:57:24 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 7645
2024.10.23 17:57:32 INFO  compiling root (1 scala source)
2024.10.23 17:57:34 INFO  time: compiled root in 2.06s
oct 23, 2024 6:15:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 7966
oct 23, 2024 6:15:32 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 7982
2024.10.23 18:15:53 INFO  compiling root (1 scala source)
2024.10.23 18:15:56 INFO  time: compiled root in 2.08s
oct 23, 2024 6:20:40 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 8104
2024.10.23 18:20:40 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDateTime.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDateTime.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 23, 2024 6:20:40 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDateTime.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.LocalTime.HOURS_PER_DAY;\nimport static java.time.LocalTime.MICROS_PER_DAY;\nimport static java.time.LocalTime.MILLIS_PER_DAY;\nimport static java.time.LocalTime.MINUTES_PER_DAY;\nimport static java.time.LocalTime.NANOS_PER_DAY;\nimport static java.time.LocalTime.NANOS_PER_HOUR;\nimport static java.time.LocalTime.NANOS_PER_MINUTE;\nimport static java.time.LocalTime.NANOS_PER_SECOND;\nimport static java.time.LocalTime.SECONDS_PER_DAY;\nimport static java.time.temporal.ChronoField.NANO_OF_SECOND;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.ChronoLocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneRules;\nimport java.util.Objects;\n\n/**\n * A date-time without a time-zone in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30}.\n * \u003cp\u003e\n * {@code LocalDateTime} is an immutable date-time object that represents a date-time,\n * often viewed as year-month-day-hour-minute-second. Other date and time fields,\n * such as day-of-year, day-of-week and week-of-year, can also be accessed.\n * Time is represented to nanosecond precision.\n * For example, the value \"2nd October 2007 at 13:45.30.123456789\" can be\n * stored in a {@code LocalDateTime}.\n * \u003cp\u003e\n * This class does not store or represent a time-zone.\n * Instead, it is a description of the date, as used for birthdays, combined with\n * the local time as seen on a wall clock.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n * \u003cp\u003e\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today\u0027s rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code LocalDateTime} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class LocalDateTime\n        implements Temporal, TemporalAdjuster, ChronoLocalDateTime\u003cLocalDate\u003e, Serializable {\n\n    /**\n     * The minimum supported {@code LocalDateTime}, \u0027-999999999-01-01T00:00:00\u0027.\n     * This is the local date-time of midnight at the start of the minimum date.\n     * This combines {@link LocalDate#MIN} and {@link LocalTime#MIN}.\n     * This could be used by an application as a \"far past\" date-time.\n     */\n    public static final LocalDateTime MIN \u003d LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);\n    /**\n     * The maximum supported {@code LocalDateTime}, \u0027+999999999-12-31T23:59:59.999999999\u0027.\n     * This is the local date-time just before midnight at the end of the maximum date.\n     * This combines {@link LocalDate#MAX} and {@link LocalTime#MAX}.\n     * This could be used by an application as a \"far future\" date-time.\n     */\n    public static final LocalDateTime MAX \u003d LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 6207766400415563566L;\n\n    /**\n     * The date part.\n     */\n    private final LocalDate date;\n    /**\n     * The time part.\n     */\n    private final LocalTime time;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date-time.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date-time using the system clock and default time-zone, not null\n     */\n    public static LocalDateTime now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date-time using the system clock, not null\n     */\n    public static LocalDateTime now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date-time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date-time, not null\n     */\n    public static LocalDateTime now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        ZoneOffset offset \u003d clock.getZone().getRules().getOffset(now);\n        return ofEpochSecond(now.getEpochSecond(), now.getNano(), offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour and minute, setting the second and nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour and minute.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The second and nanosecond fields will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute and second, setting the nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute and second.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The nanosecond field will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute, second and nanosecond.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute, second and nanosecond.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour and minute, setting the second and nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour and minute.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The second and nanosecond fields will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute and second, setting the nanosecond to zero.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute and second.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     * The nanosecond field will be set to zero.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from year, month,\n     * day, hour, minute, second and nanosecond.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} with the specified year, month,\n     * day-of-month, hour, minute, second and nanosecond.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @param hour  the hour-of-day to represent, from 0 to 23\n     * @param minute  the minute-of-hour to represent, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond) {\n        LocalDate date \u003d LocalDate.of(year, month, dayOfMonth);\n        LocalTime time \u003d LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a date and time.\n     *\n     * @param date  the local date, not null\n     * @param time  the local time, not null\n     * @return the local date-time, not null\n     */\n    public static LocalDateTime of(LocalDate date, LocalTime time) {\n        Objects.requireNonNull(date, \"date\");\n        Objects.requireNonNull(time, \"time\");\n        return new LocalDateTime(date, time);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates a local date-time based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date-time.\n     *\n     * @param instant  the instant to create the date-time from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    public static LocalDateTime ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        return ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This allows the {@link ChronoField#INSTANT_SECONDS epoch-second} field\n     * to be converted to a local date-time. This is primarily intended for\n     * low-level conversions rather than general application usage.\n     *\n     * @param epochSecond  the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     * @param nanoOfSecond  the nanosecond within the second, from 0 to 999,999,999\n     * @param offset  the zone offset, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range,\n     *  or if the nano-of-second is invalid\n     */\n    public static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset) {\n        Objects.requireNonNull(offset, \"offset\");\n        NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n        long localSecond \u003d epochSecond + offset.getTotalSeconds();  // overflow caught later\n        long localEpochDay \u003d Math.floorDiv(localSecond, SECONDS_PER_DAY);\n        int secsOfDay \u003d Math.floorMod(localSecond, SECONDS_PER_DAY);\n        LocalDate date \u003d LocalDate.ofEpochDay(localEpochDay);\n        LocalTime time \u003d LocalTime.ofNanoOfDay(secsOfDay * NANOS_PER_SECOND + nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a temporal object.\n     * \u003cp\u003e\n     * This obtains a local date-time based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code LocalDateTime}.\n     * \u003cp\u003e\n     * The conversion extracts and combines the {@code LocalDate} and the\n     * {@code LocalTime} from the temporal object.\n     * Implementations are permitted to perform optimizations such as accessing\n     * those fields that are equivalent to the relevant objects.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code LocalDateTime::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the local date-time, not null\n     * @throws DateTimeException if unable to convert to a {@code LocalDateTime}\n     */\n    public static LocalDateTime from(TemporalAccessor temporal) {\n        if (temporal instanceof LocalDateTime) {\n            return (LocalDateTime) temporal;\n        } else if (temporal instanceof ZonedDateTime) {\n            return ((ZonedDateTime) temporal).toLocalDateTime();\n        } else if (temporal instanceof OffsetDateTime) {\n            return ((OffsetDateTime) temporal).toLocalDateTime();\n        }\n        try {\n            LocalDate date \u003d LocalDate.from(temporal);\n            LocalTime time \u003d LocalTime.from(temporal);\n            return new LocalDateTime(date, time);\n        } catch (DateTimeException ex) {\n            throw new DateTimeException(\"Unable to obtain LocalDateTime from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a text string such as {@code 2007-12-03T10:15:30}.\n     * \u003cp\u003e\n     * The string must represent a valid date-time and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_DATE_TIME}.\n     *\n     * @param text  the text to parse such as \"2007-12-03T10:15:30\", not null\n     * @return the parsed local date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDateTime parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDateTime} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed local date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, LocalDateTime::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param date  the date part of the date-time, validated not null\n     * @param time  the time part of the date-time, validated not null\n     */\n    private LocalDateTime(LocalDate date, LocalTime time) {\n        this.date \u003d date;\n        this.time \u003d time;\n    }\n\n    /**\n     * Returns a copy of this date-time with the new date and time, checking\n     * to see if a new object is in fact required.\n     *\n     * @param newDate  the date of the new date-time, not null\n     * @param newTime  the time of the new date-time, not null\n     * @return the date-time, not null\n     */\n    private LocalDateTime with(LocalDate newDate, LocalTime newTime) {\n        if (date \u003d\u003d newDate \u0026\u0026 time \u003d\u003d newTime) {\n            return this;\n        }\n        return new LocalDateTime(newDate, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANO_OF_SECOND}\n     * \u003cli\u003e{@code NANO_OF_DAY}\n     * \u003cli\u003e{@code MICRO_OF_SECOND}\n     * \u003cli\u003e{@code MICRO_OF_DAY}\n     * \u003cli\u003e{@code MILLI_OF_SECOND}\n     * \u003cli\u003e{@code MILLI_OF_DAY}\n     * \u003cli\u003e{@code SECOND_OF_MINUTE}\n     * \u003cli\u003e{@code SECOND_OF_DAY}\n     * \u003cli\u003e{@code MINUTE_OF_HOUR}\n     * \u003cli\u003e{@code MINUTE_OF_DAY}\n     * \u003cli\u003e{@code HOUR_OF_AMPM}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_AMPM}\n     * \u003cli\u003e{@code HOUR_OF_DAY}\n     * \u003cli\u003e{@code CLOCK_HOUR_OF_DAY}\n     * \u003cli\u003e{@code AMPM_OF_DAY}\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date-time, false if not\n     */\n    @Override\n    public boolean isSupported(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return f.isDateBased() || f.isTimeBased();\n        }\n        return field !\u003d null \u0026\u0026 field.isSupportedBy(this);\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code NANOS}\n     * \u003cli\u003e{@code MICROS}\n     * \u003cli\u003e{@code MILLIS}\n     * \u003cli\u003e{@code SECONDS}\n     * \u003cli\u003e{@code MINUTES}\n     * \u003cli\u003e{@code HOURS}\n     * \u003cli\u003e{@code HALF_DAYS}\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        return ChronoLocalDateTime.super.isSupported(unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return (f.isTimeBased() ? time.range(field) : date.range(field));\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},\n     * {@code EPOCH_DAY} and {@code PROLEPTIC_MONTH} which are too large to fit in\n     * an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return (f.isTimeBased() ? time.get(field) : date.get(field));\n        }\n        return ChronoLocalDateTime.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date-time for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date-time.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            return (f.isTimeBased() ? time.getLong(field) : date.getLong(field));\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalDate} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return the date part of this date-time, not null\n     */\n    @Override\n    public LocalDate toLocalDate() {\n        return date;\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return date.getYear();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return date.getMonthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return date.getMonth();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return date.getDayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return date.getDayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        return date.getDayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@code LocalTime} part of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return the time part of this date-time, not null\n     */\n    @Override\n    public LocalTime toLocalTime() {\n        return time;\n    }\n\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return the hour-of-day, from 0 to 23\n     */\n    public int getHour() {\n        return time.getHour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return the minute-of-hour, from 0 to 59\n     */\n    public int getMinute() {\n        return time.getMinute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return the second-of-minute, from 0 to 59\n     */\n    public int getSecond() {\n        return time.getSecond();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return the nano-of-second, from 0 to 999,999,999\n     */\n    public int getNano() {\n        return time.getNano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date-time.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * \u003cp\u003e\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d localDateTime.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The classes {@link LocalDate} and {@link LocalTime} implement {@code TemporalAdjuster},\n     * thus this method can be used to change the date, time or offset:\n     * \u003cpre\u003e\n     *  result \u003d localDateTime.with(date);\n     *  result \u003d localDateTime.with(time);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return a {@code LocalDateTime} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return with((LocalDate) adjuster, time);\n        } else if (adjuster instanceof LocalTime) {\n            return with(date, (LocalTime) adjuster);\n        } else if (adjuster instanceof LocalDateTime) {\n            return (LocalDateTime) adjuster;\n        }\n        return (LocalDateTime) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will behave as per\n     * the matching method on {@link LocalDate#with(TemporalField, long) LocalDate}\n     * or {@link LocalTime#with(TemporalField, long) LocalTime}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return a {@code LocalDateTime} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            if (f.isTimeBased()) {\n                return with(date, time.with(field, newValue));\n            } else {\n                return with(date.with(field, newValue), time);\n            }\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the year altered.\n     * \u003cp\u003e\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return a {@code LocalDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public LocalDateTime withYear(int year) {\n        return with(date.withYear(year), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the month-of-year altered.\n     * \u003cp\u003e\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return a {@code LocalDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public LocalDateTime withMonth(int month) {\n        return with(date.withMonth(month), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting date-time is invalid, an exception is thrown.\n     * The time does not affect the calculation and will be the same in the result.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return a {@code LocalDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public LocalDateTime withDayOfMonth(int dayOfMonth) {\n        return with(date.withDayOfMonth(dayOfMonth), time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the day-of-year altered.\n     * \u003cp\u003e\n     * If the resulting date-time is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return a {@code LocalDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public LocalDateTime withDayOfYear(int dayOfYear) {\n        return with(date.withDayOfYear(dayOfYear), time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the hour-of-day altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hour  the hour-of-day to set in the result, from 0 to 23\n     * @return a {@code LocalDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    public LocalDateTime withHour(int hour) {\n        LocalTime newTime \u003d time.withHour(hour);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the minute-of-hour altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minute  the minute-of-hour to set in the result, from 0 to 59\n     * @return a {@code LocalDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    public LocalDateTime withMinute(int minute) {\n        LocalTime newTime \u003d time.withMinute(minute);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the second-of-minute altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param second  the second-of-minute to set in the result, from 0 to 59\n     * @return a {@code LocalDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    public LocalDateTime withSecond(int second) {\n        LocalTime newTime \u003d time.withSecond(second);\n        return with(date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the nano-of-second altered.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return a {@code LocalDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    public LocalDateTime withNano(int nanoOfSecond) {\n        LocalTime newTime \u003d time.withNano(nanoOfSecond);\n        return with(date, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the time truncated.\n     * \u003cp\u003e\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     * \u003cp\u003e\n     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param unit  the unit to truncate to, not null\n     * @return a {@code LocalDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    public LocalDateTime truncatedTo(TemporalUnit unit) {\n        return with(date, time.truncatedTo(unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return a {@code LocalDateTime} based on this date-time with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime plus(TemporalAmount amountToAdd) {\n        if (amountToAdd instanceof Period) {\n            Period periodToAdd \u003d (Period) amountToAdd;\n            return with(date.plus(periodToAdd), time);\n        }\n        Objects.requireNonNull(amountToAdd, \"amountToAdd\");\n        return (LocalDateTime) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented here.\n     * Date units are added as per {@link LocalDate#plus(long, TemporalUnit)}.\n     * Time units are added as per {@link LocalTime#plus(long, TemporalUnit)} with\n     * any overflow in days added equivalent to using {@link #plusDays(long)}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return a {@code LocalDateTime} based on this date-time with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            ChronoUnit f \u003d (ChronoUnit) unit;\n            switch (f) {\n                case NANOS: return plusNanos(amountToAdd);\n                case MICROS: return plusDays(amountToAdd / MICROS_PER_DAY).plusNanos((amountToAdd % MICROS_PER_DAY) * 1000);\n                case MILLIS: return plusDays(amountToAdd / MILLIS_PER_DAY).plusNanos((amountToAdd % MILLIS_PER_DAY) * 1000_000);\n                case SECONDS: return plusSeconds(amountToAdd);\n                case MINUTES: return plusMinutes(amountToAdd);\n                case HOURS: return plusHours(amountToAdd);\n                case HALF_DAYS: return plusDays(amountToAdd / 256).plusHours((amountToAdd % 256) * 12);  // no overflow (256 is multiple of 2)\n            }\n            return with(date.plus(amountToAdd, unit), time);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusYears(long years) {\n        LocalDate newDate \u003d date.plusYears(years);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusMonths(long months) {\n        LocalDate newDate \u003d date.plusMonths(months);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusWeeks(long weeks) {\n        LocalDate newDate \u003d date.plusWeeks(weeks);\n        return with(newDate, time);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusDays(long days) {\n        LocalDate newDate \u003d date.plusDays(days);\n        return with(newDate, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of hours added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusHours(long hours) {\n        return plusWithOverflow(date, hours, 0, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of minutes added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusMinutes(long minutes) {\n        return plusWithOverflow(date, 0, minutes, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of seconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusSeconds(long seconds) {\n        return plusWithOverflow(date, 0, 0, seconds, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of nanoseconds added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to add, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime plusNanos(long nanos) {\n        return plusWithOverflow(date, 0, 0, 0, nanos, 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} or {@link Duration} but may be\n     * any other type implementing the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return a {@code LocalDateTime} based on this date-time with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime minus(TemporalAmount amountToSubtract) {\n        if (amountToSubtract instanceof Period) {\n            Period periodToSubtract \u003d (Period) amountToSubtract;\n            return with(date.minus(periodToSubtract), time);\n        }\n        Objects.requireNonNull(amountToSubtract, \"amountToSubtract\");\n        return (LocalDateTime) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return a {@code LocalDateTime} based on this date-time with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDateTime minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param years  the years to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusYears(long years) {\n        return (years \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-years));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param months  the months to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusMonths(long months) {\n        return (months \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-months));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeks  the weeks to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusWeeks(long weeks) {\n        return (weeks \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeks));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param days  the days to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusDays(long days) {\n        return (days \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-days));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of hours subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param hours  the hours to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusHours(long hours) {\n        return plusWithOverflow(date, hours, 0, 0, 0, -1);\n   }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of minutes subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param minutes  the minutes to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusMinutes(long minutes) {\n        return plusWithOverflow(date, 0, minutes, 0, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of seconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param seconds  the seconds to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusSeconds(long seconds) {\n        return plusWithOverflow(date, 0, 0, seconds, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified number of nanoseconds subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param nanos  the nanos to subtract, may be negative\n     * @return a {@code LocalDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDateTime minusNanos(long nanos) {\n        return plusWithOverflow(date, 0, 0, 0, nanos, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDateTime} with the specified period added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param newDate  the new date to base the calculation on, not null\n     * @param hours  the hours to add, may be negative\n     * @param minutes the minutes to add, may be negative\n     * @param seconds the seconds to add, may be negative\n     * @param nanos the nanos to add, may be negative\n     * @param sign  the sign to determine add or subtract\n     * @return the combined result, not null\n     */\n    private LocalDateTime plusWithOverflow(LocalDate newDate, long hours, long minutes, long seconds, long nanos, int sign) {\n        // 9223372036854775808 long, 2147483648 int\n        if ((hours | minutes | seconds | nanos) \u003d\u003d 0) {\n            return with(newDate, time);\n        }\n        long totDays \u003d nanos / NANOS_PER_DAY +             //   max/24*60*60*1B\n                seconds / SECONDS_PER_DAY +                //   max/24*60*60\n                minutes / MINUTES_PER_DAY +                //   max/24*60\n                hours / HOURS_PER_DAY;                     //   max/24\n        totDays *\u003d sign;                                   // total max*0.4237...\n        long totNanos \u003d nanos % NANOS_PER_DAY +                    //   max  86400000000000\n                (seconds % SECONDS_PER_DAY) * NANOS_PER_SECOND +   //   max  86400000000000\n                (minutes % MINUTES_PER_DAY) * NANOS_PER_MINUTE +   //   max  86400000000000\n                (hours % HOURS_PER_DAY) * NANOS_PER_HOUR;          //   max  86400000000000\n        long curNoD \u003d time.toNanoOfDay();                       //   max  86400000000000\n        totNanos \u003d totNanos * sign + curNoD;                    // total 432000000000000\n        totDays +\u003d Math.floorDiv(totNanos, NANOS_PER_DAY);\n        long newNoD \u003d Math.floorMod(totNanos, NANOS_PER_DAY);\n        LocalTime newTime \u003d (newNoD \u003d\u003d curNoD ? time : LocalTime.ofNanoOfDay(newNoD));\n        return with(newDate.plusDays(totDays), newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     * \u003cp\u003e\n     * This queries this date-time using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override  // override for Javadoc\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) date;\n        }\n        return ChronoLocalDateTime.super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date and time as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the date and time changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * twice, passing {@link ChronoField#EPOCH_DAY} and\n     * {@link ChronoField#NANO_OF_DAY} as the fields.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisLocalDateTime.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisLocalDateTime);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc\n    public Temporal adjustInto(Temporal temporal) {\n        return ChronoLocalDateTime.super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the amount of time until another date-time in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code LocalDateTime}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code LocalDateTime} using {@link #from(TemporalAccessor)}.\n     * For example, the amount in days between two date-times can be calculated\n     * using {@code startDateTime.until(endDateTime, DAYS)}.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the amount in months between 2012-06-15T00:00 and 2012-08-14T23:59\n     * will only be one month as it is one minute short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},\n     * {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},\n     * {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},\n     * {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to a {@code LocalDateTime}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date-time and the end date-time\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to a {@code LocalDateTime}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        LocalDateTime end \u003d LocalDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            if (unit.isTimeBased()) {\n                long amount \u003d date.daysUntil(end.date);\n                if (amount \u003d\u003d 0) {\n                    return time.until(end.time, unit);\n                }\n                long timePart \u003d end.time.toNanoOfDay() - time.toNanoOfDay();\n                if (amount \u003e 0) {\n                    amount--;  // safe\n                    timePart +\u003d NANOS_PER_DAY;  // safe\n                } else {\n                    amount++;  // safe\n                    timePart -\u003d NANOS_PER_DAY;  // safe\n                }\n                switch ((ChronoUnit) unit) {\n                    case NANOS:\n                        amount \u003d Math.multiplyExact(amount, NANOS_PER_DAY);\n                        break;\n                    case MICROS:\n                        amount \u003d Math.multiplyExact(amount, MICROS_PER_DAY);\n                        timePart \u003d timePart / 1000;\n                        break;\n                    case MILLIS:\n                        amount \u003d Math.multiplyExact(amount, MILLIS_PER_DAY);\n                        timePart \u003d timePart / 1_000_000;\n                        break;\n                    case SECONDS:\n                        amount \u003d Math.multiplyExact(amount, SECONDS_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_SECOND;\n                        break;\n                    case MINUTES:\n                        amount \u003d Math.multiplyExact(amount, MINUTES_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_MINUTE;\n                        break;\n                    case HOURS:\n                        amount \u003d Math.multiplyExact(amount, HOURS_PER_DAY);\n                        timePart \u003d timePart / NANOS_PER_HOUR;\n                        break;\n                    case HALF_DAYS:\n                        amount \u003d Math.multiplyExact(amount, 2);\n                        timePart \u003d timePart / (NANOS_PER_HOUR * 12);\n                        break;\n                }\n                return Math.addExact(amount, timePart);\n            }\n            LocalDate endDate \u003d end.date;\n            if (endDate.isAfter(date) \u0026\u0026 end.time.isBefore(time)) {\n                endDate \u003d endDate.minusDays(1);\n            } else if (endDate.isBefore(date) \u0026\u0026 end.time.isAfter(time)) {\n                endDate \u003d endDate.plusDays(1);\n            }\n            return date.until(endDate, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this date-time using the specified formatter.\n     * \u003cp\u003e\n     * This date-time will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    @Override  // override for Javadoc and performance\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with an offset to create an {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime} formed from this date-time at the specified offset.\n     * All possible combinations of date-time and offset are valid.\n     *\n     * @param offset  the offset to combine with, not null\n     * @return the offset date-time formed from this date-time and the specified offset, not null\n     */\n    public OffsetDateTime atOffset(ZoneOffset offset) {\n        return OffsetDateTime.of(this, offset);\n    }\n\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code ZonedDateTime} formed from this date-time at the\n     * specified time-zone. The result will match this date-time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     * \u003cp\u003e\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules rules} of the zone ID.\n     *\u003cp\u003e\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, where clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to \"summer\".\n     * \u003cp\u003e\n     * In the case of a gap, where clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to \"summer\".\n     * \u003cp\u003e\n     * To obtain the later offset during an overlap, call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} on the result of this method.\n     * To throw an exception when there is a gap or overlap, use\n     * {@link ZonedDateTime#ofStrict(LocalDateTime, ZoneOffset, ZoneId)}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date-time, not null\n     */\n    @Override\n    public ZonedDateTime atZone(ZoneId zone) {\n        return ZonedDateTime.of(this, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * \u003cp\u003e\n     * The comparison is primarily based on the date-time, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * If all the date-times being compared are instances of {@code LocalDateTime},\n     * then the comparison will be entirely based on the date-time.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link ChronoLocalDateTime#compareTo}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override  // override for Javadoc and performance\n    public int compareTo(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other);\n        }\n        return ChronoLocalDateTime.super.compareTo(other);\n    }\n\n    private int compareTo0(LocalDateTime other) {\n        int cmp \u003d date.compareTo0(other.toLocalDate());\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d time.compareTo(other.toLocalTime());\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date-time is after the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents a point on the\n     * local time-line after the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isAfter(b) \u003d\u003d false\n     *   a.isAfter(a) \u003d\u003d false\n     *   b.isAfter(a) \u003d\u003d true\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is after the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isAfter(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003e 0;\n        }\n        return ChronoLocalDateTime.super.isAfter(other);\n    }\n\n    /**\n     * Checks if this date-time is before the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents a point on the\n     * local time-line before the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isBefore(b) \u003d\u003d true\n     *   a.isBefore(a) \u003d\u003d false\n     *   b.isBefore(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is before the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isBefore(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003c 0;\n        }\n        return ChronoLocalDateTime.super.isBefore(other);\n    }\n\n    /**\n     * Checks if this date-time is equal to the specified date-time.\n     * \u003cp\u003e\n     * This checks to see if this date-time represents the same point on the\n     * local time-line as the other date-time.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b \u003d LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isEqual(b) \u003d\u003d false\n     *   a.isEqual(a) \u003d\u003d true\n     *   b.isEqual(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},\n     * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return true if this date-time is equal to the specified date-time\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isEqual(ChronoLocalDateTime\u003c?\u003e other) {\n        if (other instanceof LocalDateTime) {\n            return compareTo0((LocalDateTime) other) \u003d\u003d 0;\n        }\n        return ChronoLocalDateTime.super.isEqual(other);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     * \u003cp\u003e\n     * Compares this {@code LocalDateTime} with another ensuring that the date-time is the same.\n     * Only objects of type {@code LocalDateTime} are compared, other types return false.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date-time\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof LocalDateTime) {\n            LocalDateTime other \u003d (LocalDateTime) obj;\n            return date.equals(other.date) \u0026\u0026 time.equals(other.time);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return date.hashCode() ^ time.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a {@code String}, such as {@code 2007-12-03T10:15:30}.\n     * \u003cp\u003e\n     * The output will be one of the following ISO-8601 formats:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSS}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSS}\u003c/li\u003e\n     * \u003cli\u003e{@code uuuu-MM-dd\u0027T\u0027HH:mm:ss.SSSSSSSSS}\u003c/li\u003e\n     * \u003c/ul\u003e\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return a string representation of this date-time, not null\n     */\n    @Override\n    public String toString() {\n        return date.toString() + \u0027T\u0027 + time.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(5);  // identifies a LocalDateTime\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalDate\"\u003edate\u003c/a\u003e excluding the one byte header\n     *  // the \u003ca href\u003d\"../../serialized-form.html#java.time.LocalTime\"\u003etime\u003c/a\u003e excluding the one byte header\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.LOCAL_DATE_TIME_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(DataOutput out) throws IOException {\n        date.writeExternal(out);\n        time.writeExternal(out);\n    }\n\n    static LocalDateTime readExternal(DataInput in) throws IOException {\n        LocalDate date \u003d LocalDate.readExternal(in);\n        LocalTime time \u003d LocalTime.readExternal(in);\n        return LocalDateTime.of(date, time);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 23, 2024 6:20:40 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDateTime.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDateTime.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 23, 2024 6:20:42 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 8117
oct 23, 2024 6:20:42 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 8119
oct 23, 2024 6:20:42 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 8116
oct 23, 2024 6:20:42 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 8115
2024.10.23 18:20:44 INFO  compiling root (1 scala source)
2024.10.23 18:20:45 INFO  time: compiled root in 1.75s
oct 23, 2024 6:21:09 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 8272
2024.10.23 18:22:59 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 23, 2024 6:22:59 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2022, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.nio.charset.CharacterCodingException;\nimport java.security.AccessControlContext;\nimport java.security.ProtectionDomain;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\n\nimport jdk.internal.logger.LoggerFinderLoader.TemporaryLoggerFinder;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.HotSpotIntrinsicCandidate;\nimport jdk.internal.misc.JavaLangAccess;\nimport jdk.internal.misc.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * VM will invoke the initializeSystemClass method to complete\n     * the initialization for this class separated from clinit.\n     * Note that to use properties set by the VM, see the constraints\n     * described in the initializeSystemClass method.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user.\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     */\n    public static final PrintStream err \u003d null;\n\n    /* The security manager for the system.\n     */\n    private static volatile SecurityManager security;\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    /**\n     * Sets the System security.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @param      s   the security manager.\n     * @throws     SecurityException  if the security manager has already\n     *             been set and its {@code checkPermission} method\n     *             doesn\u0027t allow it to be replaced.\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     */\n    public static void setSecurityManager(final SecurityManager s) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (s !\u003d null) {\n            try {\n                s.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(s);\n    }\n\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission\n                                     (\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Cause policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system security interface.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     */\n    public static SecurityManager getSecurityManager() {\n        return security;\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @HotSpotIntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @HotSpotIntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @HotSpotIntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @HotSpotIntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties. The following properties are guaranteed to be defined:\n     * \u003cdl\u003e\n     * \u003cdt\u003ejava.version         \u003cdd\u003eJava version number\n     * \u003cdt\u003ejava.version.date    \u003cdd\u003eJava version date\n     * \u003cdt\u003ejava.vendor          \u003cdd\u003eJava vendor specific string\n     * \u003cdt\u003ejava.vendor.url      \u003cdd\u003eJava vendor URL\n     * \u003cdt\u003ejava.vendor.version  \u003cdd\u003eJava vendor version\n     * \u003cdt\u003ejava.home            \u003cdd\u003eJava installation directory\n     * \u003cdt\u003ejava.class.version   \u003cdd\u003eJava class version number\n     * \u003cdt\u003ejava.class.path      \u003cdd\u003eJava classpath\n     * \u003cdt\u003eos.name              \u003cdd\u003eOperating System Name\n     * \u003cdt\u003eos.arch              \u003cdd\u003eOperating System Architecture\n     * \u003cdt\u003eos.version           \u003cdd\u003eOperating System Version\n     * \u003cdt\u003efile.separator       \u003cdd\u003eFile separator (\"/\" on Unix)\n     * \u003cdt\u003epath.separator       \u003cdd\u003ePath separator (\":\" on Unix)\n     * \u003cdt\u003eline.separator       \u003cdd\u003eLine separator (\"\\n\" on Unix)\n     * \u003cdt\u003euser.name            \u003cdd\u003eUser account name\n     * \u003cdt\u003euser.home            \u003cdd\u003eUser home directory\n     * \u003cdt\u003euser.dir             \u003cdd\u003eUser\u0027s current working directory\n     * \u003c/dl\u003e\n     */\n\n    private static Properties props;\n    private static native Properties initProperties(Properties props);\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties always includes values\n     * for the following keys:\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.specification.maintenance.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification maintenance version,\n     *     may be interpreted as a positive integer \u003cem\u003e(optional, see below)\u003c/em\u003e\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * The {@code java.specification.maintenance.version} property is\n     * defined if the specification implemented by this runtime at the\n     * time of its construction had undergone a \u003ca\n     * href\u003d\"https://jcp.org/en/procedures/jcp2#3.6.4\"\u003emaintenance\n     * release\u003c/a\u003e. When defined, its value identifies that\n     * maintenance release. To indicate the first maintenance release\n     * this property will have the value {@code \"1\"}, to indicate the\n     * second maintenance release this property will have the value\n     * {@code \"2\"}, and so on.\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n        if (props \u003d\u003d null) {\n            props \u003d new Properties();\n            initProperties(props);\n            System.props \u003d props;\n            VersionProps.init();\n        } else {\n            System.props \u003d props;\n        }\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.equals(\"\")) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            LoggerFinder finder \u003d service;\n            if (finder \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                finder \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n                if (finder instanceof TemporaryLoggerFinder) return finder;\n                service \u003d finder;\n            }\n            return finder;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector.\n     *\n     * Calling the {@code gc} method suggests that the Java Virtual\n     * Machine expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for quick reuse.\n     * When control returns from the method call, the Java Virtual\n     * Machine has made a best effort to reclaim space from all discarded\n     * objects.\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an implementation-\n     * dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization, in which it may need access, via\n        // System.getProperty(), to the related system encoding property that\n        // have been initialized (put into \"props\") at early stage of the\n        // initialization. So make sure the \"props\" is available at the\n        // very beginning of the initialization and all system properties to\n        // be put into it directly.\n        props \u003d new Properties(84);\n        initProperties(props);  // initialized by the VM\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // removed from the system properties.\n        //\n        // See java.lang.Integer.IntegerCache and the\n        // VM.saveAndRemoveProperties method for example.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.  Remove\n        // certain system properties that are not intended for public access.\n        VM.saveAndRemoveProperties(props);\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n        VersionProps.init();\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n        // register shared secrets\n        setJavaLangAccess();\n\n        ClassLoader.initLibraryPaths();\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. set security manager\n     * 2. set system class loader\n     * 3. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be custom class from\n     * the application classpath or modulepath.\n     */\n    private static void initPhase3() {\n        // set security manager\n        String cn \u003d System.getProperty(\"java.security.manager\");\n        if (cn !\u003d null) {\n            if (cn.isEmpty() || \"default\".equals(cn)) {\n                System.setSecurityManager(new SecurityManager());\n            } else {\n                try {\n                    Class\u003c?\u003e c \u003d Class.forName(cn, false, ClassLoader.getBuiltinAppClassLoader());\n                    Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                    // Must be a public subclass of SecurityManager with\n                    // a public no-arg constructor\n                    if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                        throw new Error(\"Could not create SecurityManager: \" + ctor.toString());\n                    }\n                    // custom security manager implementation may be in unnamed module\n                    // or a named module but non-exported package\n                    ctor.setAccessible(true);\n                    SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                    System.setSecurityManager(sm);\n                } catch (Exception e) {\n                    throw new Error(\"Could not create SecurityManager\", e);\n                }\n            }\n        }\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(ClassLoader cl, String name) {\n                return cl.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Iterator\u003cString\u003e packages) {\n                m.implAddOpensToAllUnnamed(packages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return StringCoding.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return StringCoding.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return StringCoding.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return StringCoding.getBytesUTF8NoRepl(s);\n            }\n\n            public String getLoaderNameID(ClassLoader loader) {\n                return loader !\u003d null ? loader.nameAndId() : \"null\";\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 23, 2024 6:22:59 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 8540
oct 23, 2024 6:22:59 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 23, 2024 6:23:20 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 8578
2024.10.23 18:24:17 INFO  compiling root (1 scala source)
2024.10.23 18:24:17 INFO  time: compiled root in 0.81s
2024.10.23 18:24:31 INFO  compiling root (1 scala source)
2024.10.23 18:24:33 INFO  time: compiled root in 2.22s
oct 23, 2024 6:27:09 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 8834
2024.10.23 18:27:39 INFO  compiling root (1 scala source)
2024.10.23 18:27:39 INFO  time: compiled root in 0.55s
2024.10.23 18:27:51 INFO  compiling root (1 scala source)
2024.10.23 18:27:53 INFO  time: compiled root in 2.33s
oct 23, 2024 6:28:24 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 9003
oct 23, 2024 6:28:57 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 9155
2024.10.23 18:29:04 INFO  compiling root (1 scala source)
2024.10.23 18:29:06 INFO  time: compiled root in 1.98s
2024.10.23 18:31:11 INFO  compiling root (1 scala source)
2024.10.23 18:31:11 INFO  time: compiled root in 0.99s
2024.10.23 18:31:24 INFO  compiling root (1 scala source)
2024.10.23 18:31:25 INFO  time: compiled root in 1.16s
2024.10.23 18:36:57 INFO  compiling root (1 scala source)
2024.10.23 18:36:57 INFO  time: compiled root in 0.53s
2024.10.23 18:37:09 INFO  compiling root (1 scala source)
2024.10.23 18:37:09 INFO  time: compiled root in 0.4s
2024.10.23 18:37:22 INFO  compiling root (1 scala source)
2024.10.23 18:37:22 INFO  time: compiled root in 0.41s
2024.10.23 18:37:36 INFO  compiling root (1 scala source)
2024.10.23 18:37:36 INFO  time: compiled root in 0.45s
2024.10.23 18:40:46 INFO  compiling root (1 scala source)
2024.10.23 18:40:46 INFO  time: compiled root in 0.56s
2024.10.23 18:43:34 INFO  compiling root (1 scala source)
2024.10.23 18:43:34 INFO  time: compiled root in 0.25s
2024.10.23 18:44:05 INFO  compiling root (1 scala source)
2024.10.23 18:44:05 INFO  time: compiled root in 0.73s
2024.10.23 18:44:47 INFO  compiling root (1 scala source)
2024.10.23 18:44:47 INFO  time: compiled root in 0.99s
2024.10.23 18:47:41 INFO  compiling root (1 scala source)
2024.10.23 18:47:41 INFO  time: compiled root in 0.39s
2024.10.23 18:49:47 INFO  compiling root (1 scala source)
2024.10.23 18:49:47 INFO  time: compiled root in 0.27s
2024.10.23 18:50:16 INFO  compiling root (1 scala source)
2024.10.23 18:50:16 INFO  time: compiled root in 0.75s
2024.10.23 18:50:35 INFO  compiling root (1 scala source)
2024.10.23 18:50:35 INFO  time: compiled root in 0.24s
2024.10.23 18:50:40 INFO  compiling root (1 scala source)
2024.10.23 18:50:40 INFO  time: compiled root in 0.74s
2024.10.23 18:50:42 INFO  compiling root (1 scala source)
2024.10.23 18:50:42 INFO  time: compiled root in 0.43s
2024.10.23 18:51:59 INFO  compiling root (1 scala source)
2024.10.23 18:51:59 INFO  time: compiled root in 0.23s
2024.10.23 18:52:07 INFO  compiling root (1 scala source)
2024.10.23 18:52:07 INFO  time: compiled root in 0.22s
2024.10.23 18:52:21 INFO  compiling root (1 scala source)
2024.10.23 18:52:21 INFO  time: compiled root in 0.23s
2024.10.23 18:52:37 INFO  compiling root (1 scala source)
2024.10.23 18:52:37 INFO  time: compiled root in 0.76s
2024.10.23 18:54:43 INFO  compiling root (1 scala source)
2024.10.23 18:54:43 INFO  time: compiled root in 0.24s
2024.10.23 18:55:46 INFO  compiling root (1 scala source)
2024.10.23 18:55:46 INFO  time: compiled root in 0.74s
2024.10.23 18:55:52 INFO  compiling root (1 scala source)
2024.10.23 18:55:52 INFO  time: compiled root in 0.79s
2024.10.23 19:03:10 INFO  compiling root (1 scala source)
2024.10.23 19:03:10 INFO  time: compiled root in 0.25s
oct 23, 2024 7:04:00 P. M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMACIÓN: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.10.23 19:05:40 INFO  compiling root (1 scala source)
2024.10.23 19:05:40 INFO  time: compiled root in 0.22s
2024.10.23 19:05:53 INFO  compiling root (1 scala source)
2024.10.23 19:05:53 INFO  time: compiled root in 0.25s
2024.10.23 19:06:25 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 23, 2024 7:06:25 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2008-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time.format;\n\nimport static java.time.temporal.ChronoField.DAY_OF_MONTH;\nimport static java.time.temporal.ChronoField.DAY_OF_WEEK;\nimport static java.time.temporal.ChronoField.DAY_OF_YEAR;\nimport static java.time.temporal.ChronoField.HOUR_OF_DAY;\nimport static java.time.temporal.ChronoField.MINUTE_OF_HOUR;\nimport static java.time.temporal.ChronoField.MONTH_OF_YEAR;\nimport static java.time.temporal.ChronoField.NANO_OF_SECOND;\nimport static java.time.temporal.ChronoField.SECOND_OF_MINUTE;\nimport static java.time.temporal.ChronoField.YEAR;\n\nimport java.io.IOException;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.time.DateTimeException;\nimport java.time.Period;\nimport java.time.ZoneId;\nimport java.time.ZoneOffset;\nimport java.time.chrono.ChronoLocalDateTime;\nimport java.time.chrono.Chronology;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatterBuilder.CompositePrinterParser;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.IsoFields;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQuery;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport sun.util.locale.provider.TimeZoneNameUtility;\n\n/**\n * Formatter for printing and parsing date-time objects.\n * \u003cp\u003e\n * This class provides the main application entry point for printing and parsing\n * and provides common implementations of {@code DateTimeFormatter}:\n * \u003cul\u003e\n * \u003cli\u003eUsing predefined constants, such as {@link #ISO_LOCAL_DATE}\u003c/li\u003e\n * \u003cli\u003eUsing pattern letters, such as {@code uuuu-MMM-dd}\u003c/li\u003e\n * \u003cli\u003eUsing localized styles, such as {@code long} or {@code medium}\u003c/li\u003e\n * \u003c/ul\u003e\n * \u003cp\u003e\n * More complex formatters are provided by\n * {@link DateTimeFormatterBuilder DateTimeFormatterBuilder}.\n *\n * \u003cp\u003e\n * The main date-time classes provide two methods - one for formatting,\n * {@code format(DateTimeFormatter formatter)}, and one for parsing,\n * {@code parse(CharSequence text, DateTimeFormatter formatter)}.\n * \u003cp\u003eFor example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *  LocalDate date \u003d LocalDate.now();\n *  String text \u003d date.format(formatter);\n *  LocalDate parsedDate \u003d LocalDate.parse(text, formatter);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * In addition to the format, formatters can be created with desired Locale,\n * Chronology, ZoneId, and DecimalStyle.\n * \u003cp\u003e\n * The {@link #withLocale withLocale} method returns a new formatter that\n * overrides the locale. The locale affects some aspects of formatting and\n * parsing. For example, the {@link #ofLocalizedDate ofLocalizedDate} provides a\n * formatter that uses the locale specific date format.\n * \u003cp\u003e\n * The {@link #withChronology withChronology} method returns a new formatter\n * that overrides the chronology. If overridden, the date-time value is\n * converted to the chronology before formatting. During parsing the date-time\n * value is converted to the chronology before it is returned.\n * \u003cp\u003e\n * The {@link #withZone withZone} method returns a new formatter that overrides\n * the zone. If overridden, the date-time value is converted to a ZonedDateTime\n * with the requested ZoneId before formatting. During parsing the ZoneId is\n * applied before the value is returned.\n * \u003cp\u003e\n * The {@link #withDecimalStyle withDecimalStyle} method returns a new formatter that\n * overrides the {@link DecimalStyle}. The DecimalStyle symbols are used for\n * formatting and parsing.\n * \u003cp\u003e\n * Some applications may need to use the older {@link Format java.text.Format}\n * class for formatting. The {@link #toFormat()} method returns an\n * implementation of {@code java.text.Format}.\n *\n * \u003ch3 id\u003d\"predefined\"\u003ePredefined Formatters\u003c/h3\u003e\n * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n * \u003ccaption\u003ePredefined Formatters\u003c/caption\u003e\n * \u003cthead\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"col\"\u003eFormatter\u003c/th\u003e\n * \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n * \u003cth scope\u003d\"col\"\u003eExample\u003c/th\u003e\n * \u003c/tr\u003e\n * \u003c/thead\u003e\n * \u003ctbody\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e{@link #ofLocalizedDate ofLocalizedDate(dateStyle)} \u003c/th\u003e\n * \u003ctd\u003e Formatter with date style from the locale \u003c/td\u003e\n * \u003ctd\u003e \u00272011-12-03\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ofLocalizedTime ofLocalizedTime(timeStyle)} \u003c/th\u003e\n * \u003ctd\u003e Formatter with time style from the locale \u003c/td\u003e\n * \u003ctd\u003e \u002710:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ofLocalizedDateTime ofLocalizedDateTime(dateTimeStyle)} \u003c/th\u003e\n * \u003ctd\u003e Formatter with a style for date and time from the locale\u003c/td\u003e\n * \u003ctd\u003e \u00273 Jun 2008 11:05:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ofLocalizedDateTime ofLocalizedDateTime(dateStyle,timeStyle)}\n * \u003c/th\u003e\n * \u003ctd\u003e Formatter with date and time styles from the locale \u003c/td\u003e\n * \u003ctd\u003e \u00273 Jun 2008 11:05\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #BASIC_ISO_DATE}\u003c/th\u003e\n * \u003ctd\u003eBasic ISO date \u003c/td\u003e \u003ctd\u003e\u002720111203\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_LOCAL_DATE}\u003c/th\u003e\n * \u003ctd\u003e ISO Local Date \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_OFFSET_DATE}\u003c/th\u003e\n * \u003ctd\u003e ISO Date with offset \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03+01:00\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_DATE}\u003c/th\u003e\n * \u003ctd\u003e ISO Date with or without offset \u003c/td\u003e\n * \u003ctd\u003e \u00272011-12-03+01:00\u0027; \u00272011-12-03\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_LOCAL_TIME}\u003c/th\u003e\n * \u003ctd\u003e Time without offset \u003c/td\u003e\n * \u003ctd\u003e\u002710:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_OFFSET_TIME}\u003c/th\u003e\n * \u003ctd\u003e Time with offset \u003c/td\u003e\n * \u003ctd\u003e\u002710:15:30+01:00\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_TIME}\u003c/th\u003e\n * \u003ctd\u003e Time with or without offset \u003c/td\u003e\n * \u003ctd\u003e\u002710:15:30+01:00\u0027; \u002710:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_LOCAL_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e ISO Local Date and Time \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_OFFSET_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e Date Time with Offset\n * \u003c/td\u003e\u003ctd\u003e\u00272011-12-03T10:15:30+01:00\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_ZONED_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e Zoned Date Time \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e Date and time with ZoneId \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_ORDINAL_DATE}\u003c/th\u003e\n * \u003ctd\u003e Year and day of year \u003c/td\u003e\n * \u003ctd\u003e\u00272012-337\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_WEEK_DATE}\u003c/th\u003e\n * \u003ctd\u003e Year and Week \u003c/td\u003e\n * \u003ctd\u003e\u00272012-W48-6\u0027\u003c/td\u003e\u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_INSTANT}\u003c/th\u003e\n * \u003ctd\u003e Date and Time of an Instant \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30Z\u0027 \u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #RFC_1123_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e RFC 1123 / RFC 822 \u003c/td\u003e\n * \u003ctd\u003e\u0027Tue, 3 Jun 2008 11:05:30 GMT\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003c/tbody\u003e\n * \u003c/table\u003e\n *\n * \u003ch3 id\u003d\"patterns\"\u003ePatterns for Formatting and Parsing\u003c/h3\u003e\n * Patterns are based on a simple sequence of letters and symbols.\n * A pattern is used to create a Formatter using the\n * {@link #ofPattern(String)} and {@link #ofPattern(String, Locale)} methods.\n * For example,\n * {@code \"d MMM uuuu\"} will format 2011-12-03 as \u00273\u0026nbsp;Dec\u0026nbsp;2011\u0027.\n * A formatter created from a pattern can be used as many times as necessary,\n * it is immutable and is thread-safe.\n * \u003cp\u003e\n * For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *  LocalDate date \u003d LocalDate.now();\n *  DateTimeFormatter formatter \u003d DateTimeFormatter.ofPattern(\"yyyy MM dd\");\n *  String text \u003d date.format(formatter);\n *  LocalDate parsedDate \u003d LocalDate.parse(text, formatter);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * All letters \u0027A\u0027 to \u0027Z\u0027 and \u0027a\u0027 to \u0027z\u0027 are reserved as pattern letters. The\n * following pattern letters are defined:\n * \u003ctable class\u003d\"striped\"\u003e\n * \u003ccaption\u003ePattern Letters and Symbols\u003c/caption\u003e\n * \u003cthead\u003e\n *  \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSymbol\u003c/th\u003e   \u003cth scope\u003d\"col\"\u003eMeaning\u003c/th\u003e         \u003cth scope\u003d\"col\"\u003ePresentation\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eExamples\u003c/th\u003e\n * \u003c/thead\u003e\n * \u003ctbody\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eG\u003c/th\u003e       \u003ctd\u003eera\u003c/td\u003e                         \u003ctd\u003etext\u003c/td\u003e              \u003ctd\u003eAD; Anno Domini; A\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eu\u003c/th\u003e       \u003ctd\u003eyear\u003c/td\u003e                        \u003ctd\u003eyear\u003c/td\u003e              \u003ctd\u003e2004; 04\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ey\u003c/th\u003e       \u003ctd\u003eyear-of-era\u003c/td\u003e                 \u003ctd\u003eyear\u003c/td\u003e              \u003ctd\u003e2004; 04\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eD\u003c/th\u003e       \u003ctd\u003eday-of-year\u003c/td\u003e                 \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e189\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eM/L\u003c/th\u003e     \u003ctd\u003emonth-of-year\u003c/td\u003e               \u003ctd\u003enumber/text\u003c/td\u003e       \u003ctd\u003e7; 07; Jul; July; J\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ed\u003c/th\u003e       \u003ctd\u003eday-of-month\u003c/td\u003e                \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e10\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eg\u003c/th\u003e       \u003ctd\u003emodified-julian-day\u003c/td\u003e         \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e2451334\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eQ/q\u003c/th\u003e     \u003ctd\u003equarter-of-year\u003c/td\u003e             \u003ctd\u003enumber/text\u003c/td\u003e       \u003ctd\u003e3; 03; Q3; 3rd quarter\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eY\u003c/th\u003e       \u003ctd\u003eweek-based-year\u003c/td\u003e             \u003ctd\u003eyear\u003c/td\u003e              \u003ctd\u003e1996; 96\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ew\u003c/th\u003e       \u003ctd\u003eweek-of-week-based-year\u003c/td\u003e     \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e27\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eW\u003c/th\u003e       \u003ctd\u003eweek-of-month\u003c/td\u003e               \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e4\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eE\u003c/th\u003e       \u003ctd\u003eday-of-week\u003c/td\u003e                 \u003ctd\u003etext\u003c/td\u003e              \u003ctd\u003eTue; Tuesday; T\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ee/c\u003c/th\u003e     \u003ctd\u003elocalized day-of-week\u003c/td\u003e       \u003ctd\u003enumber/text\u003c/td\u003e       \u003ctd\u003e2; 02; Tue; Tuesday; T\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eF\u003c/th\u003e       \u003ctd\u003eday-of-week-in-month\u003c/td\u003e        \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e3\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ea\u003c/th\u003e       \u003ctd\u003eam-pm-of-day\u003c/td\u003e                \u003ctd\u003etext\u003c/td\u003e              \u003ctd\u003ePM\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eh\u003c/th\u003e       \u003ctd\u003eclock-hour-of-am-pm (1-12)\u003c/td\u003e  \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e12\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eK\u003c/th\u003e       \u003ctd\u003ehour-of-am-pm (0-11)\u003c/td\u003e        \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e0\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ek\u003c/th\u003e       \u003ctd\u003eclock-hour-of-day (1-24)\u003c/td\u003e    \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e24\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eH\u003c/th\u003e       \u003ctd\u003ehour-of-day (0-23)\u003c/td\u003e          \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e0\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003em\u003c/th\u003e       \u003ctd\u003eminute-of-hour\u003c/td\u003e              \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e30\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003es\u003c/th\u003e       \u003ctd\u003esecond-of-minute\u003c/td\u003e            \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e55\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eS\u003c/th\u003e       \u003ctd\u003efraction-of-second\u003c/td\u003e          \u003ctd\u003efraction\u003c/td\u003e          \u003ctd\u003e978\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eA\u003c/th\u003e       \u003ctd\u003emilli-of-day\u003c/td\u003e                \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e1234\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003en\u003c/th\u003e       \u003ctd\u003enano-of-second\u003c/td\u003e              \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e987654321\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eN\u003c/th\u003e       \u003ctd\u003enano-of-day\u003c/td\u003e                 \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e1234000000\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eV\u003c/th\u003e       \u003ctd\u003etime-zone ID\u003c/td\u003e                \u003ctd\u003ezone-id\u003c/td\u003e           \u003ctd\u003eAmerica/Los_Angeles; Z; -08:30\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ev\u003c/th\u003e       \u003ctd\u003egeneric time-zone name\u003c/td\u003e      \u003ctd\u003ezone-name\u003c/td\u003e         \u003ctd\u003ePacific Time; PT\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ez\u003c/th\u003e       \u003ctd\u003etime-zone name\u003c/td\u003e              \u003ctd\u003ezone-name\u003c/td\u003e         \u003ctd\u003ePacific Standard Time; PST\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eO\u003c/th\u003e       \u003ctd\u003elocalized zone-offset\u003c/td\u003e       \u003ctd\u003eoffset-O\u003c/td\u003e          \u003ctd\u003eGMT+8; GMT+08:00; UTC-08:00\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eX\u003c/th\u003e       \u003ctd\u003ezone-offset \u0027Z\u0027 for zero\u003c/td\u003e    \u003ctd\u003eoffset-X\u003c/td\u003e          \u003ctd\u003eZ; -08; -0830; -08:30; -083015; -08:30:15\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ex\u003c/th\u003e       \u003ctd\u003ezone-offset\u003c/td\u003e                 \u003ctd\u003eoffset-x\u003c/td\u003e          \u003ctd\u003e+0000; -08; -0830; -08:30; -083015; -08:30:15\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eZ\u003c/th\u003e       \u003ctd\u003ezone-offset\u003c/td\u003e                 \u003ctd\u003eoffset-Z\u003c/td\u003e          \u003ctd\u003e+0000; -0800; -08:00\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ep\u003c/th\u003e       \u003ctd\u003epad next\u003c/td\u003e                    \u003ctd\u003epad modifier\u003c/td\u003e      \u003ctd\u003e1\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e\u0027\u003c/th\u003e       \u003ctd\u003eescape for text\u003c/td\u003e             \u003ctd\u003edelimiter\u003c/td\u003e         \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e\u0027\u0027\u003c/th\u003e      \u003ctd\u003esingle quote\u003c/td\u003e                \u003ctd\u003eliteral\u003c/td\u003e           \u003ctd\u003e\u0027\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e[\u003c/th\u003e       \u003ctd\u003eoptional section start\u003c/td\u003e      \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e]\u003c/th\u003e       \u003ctd\u003eoptional section end\u003c/td\u003e        \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e#\u003c/th\u003e       \u003ctd\u003ereserved for future use\u003c/td\u003e     \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{\u003c/th\u003e       \u003ctd\u003ereserved for future use\u003c/td\u003e     \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e}\u003c/th\u003e       \u003ctd\u003ereserved for future use\u003c/td\u003e     \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n * \u003c/tbody\u003e\n * \u003c/table\u003e\n * \u003cp\u003e\n * The count of pattern letters determines the format.\n * \u003cp\u003e\n * \u003cb\u003eText\u003c/b\u003e: The text style is determined based on the number of pattern\n * letters used. Less than 4 pattern letters will use the\n * {@link TextStyle#SHORT short form}. Exactly 4 pattern letters will use the\n * {@link TextStyle#FULL full form}. Exactly 5 pattern letters will use the\n * {@link TextStyle#NARROW narrow form}.\n * Pattern letters \u0027L\u0027, \u0027c\u0027, and \u0027q\u0027 specify the stand-alone form of the text styles.\n * \u003cp\u003e\n * \u003cb\u003eNumber\u003c/b\u003e: If the count of letters is one, then the value is output using\n * the minimum number of digits and without padding. Otherwise, the count of digits\n * is used as the width of the output field, with the value zero-padded as necessary.\n * The following pattern letters have constraints on the count of letters.\n * Only one letter of \u0027c\u0027 and \u0027F\u0027 can be specified.\n * Up to two letters of \u0027d\u0027, \u0027H\u0027, \u0027h\u0027, \u0027K\u0027, \u0027k\u0027, \u0027m\u0027, and \u0027s\u0027 can be specified.\n * Up to three letters of \u0027D\u0027 can be specified.\n * \u003cp\u003e\n * \u003cb\u003eNumber/Text\u003c/b\u003e: If the count of pattern letters is 3 or greater, use the\n * Text rules above. Otherwise use the Number rules above.\n * \u003cp\u003e\n * \u003cb\u003eFraction\u003c/b\u003e: Outputs the nano-of-second field as a fraction-of-second.\n * The nano-of-second value has nine digits, thus the count of pattern letters\n * is from 1 to 9. If it is less than 9, then the nano-of-second value is\n * truncated, with only the most significant digits being output.\n * \u003cp\u003e\n * \u003cb\u003eYear\u003c/b\u003e: The count of letters determines the minimum field width below\n * which padding is used. If the count of letters is two, then a\n * {@link DateTimeFormatterBuilder#appendValueReduced reduced} two digit form is\n * used. For printing, this outputs the rightmost two digits. For parsing, this\n * will parse using the base value of 2000, resulting in a year within the range\n * 2000 to 2099 inclusive. If the count of letters is less than four (but not\n * two), then the sign is only output for negative years as per\n * {@link SignStyle#NORMAL}. Otherwise, the sign is output if the pad width is\n * exceeded, as per {@link SignStyle#EXCEEDS_PAD}.\n * \u003cp\u003e\n * \u003cb\u003eZoneId\u003c/b\u003e: This outputs the time-zone ID, such as \u0027Europe/Paris\u0027. If the\n * count of letters is two, then the time-zone ID is output. Any other count of\n * letters throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eZone names\u003c/b\u003e: This outputs the display name of the time-zone ID. If the\n * pattern letter is \u0027z\u0027 the output is the daylight savings aware zone name.\n * If there is insufficient information to determine whether DST applies,\n * the name ignoring daylight savings time will be used.\n * If the count of letters is one, two or three, then the short name is output.\n * If the count of letters is four, then the full name is output.\n * Five or more letters throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * If the pattern letter is \u0027v\u0027 the output provides the zone name ignoring\n * daylight savings time. If the count of letters is one, then the short name is output.\n * If the count of letters is four, then the full name is output.\n * Two, three and five or more letters throw {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eOffset X and x\u003c/b\u003e: This formats the offset based on the number of pattern\n * letters. One letter outputs just the hour, such as \u0027+01\u0027, unless the minute\n * is non-zero in which case the minute is also output, such as \u0027+0130\u0027. Two\n * letters outputs the hour and minute, without a colon, such as \u0027+0130\u0027. Three\n * letters outputs the hour and minute, with a colon, such as \u0027+01:30\u0027. Four\n * letters outputs the hour and minute and optional second, without a colon,\n * such as \u0027+013015\u0027. Five letters outputs the hour and minute and optional\n * second, with a colon, such as \u0027+01:30:15\u0027. Six or more letters throws\n * {@code IllegalArgumentException}. Pattern letter \u0027X\u0027 (upper case) will output\n * \u0027Z\u0027 when the offset to be output would be zero, whereas pattern letter \u0027x\u0027\n * (lower case) will output \u0027+00\u0027, \u0027+0000\u0027, or \u0027+00:00\u0027.\n * \u003cp\u003e\n * \u003cb\u003eOffset O\u003c/b\u003e: This formats the localized offset based on the number of\n * pattern letters. One letter outputs the {@linkplain TextStyle#SHORT short}\n * form of the localized offset, which is localized offset text, such as \u0027GMT\u0027,\n * with hour without leading zero, optional 2-digit minute and second if\n * non-zero, and colon, for example \u0027GMT+8\u0027. Four letters outputs the\n * {@linkplain TextStyle#FULL full} form, which is localized offset text,\n * such as \u0027GMT, with 2-digit hour and minute field, optional second field\n * if non-zero, and colon, for example \u0027GMT+08:00\u0027. Any other count of letters\n * throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eOffset Z\u003c/b\u003e: This formats the offset based on the number of pattern\n * letters. One, two or three letters outputs the hour and minute, without a\n * colon, such as \u0027+0130\u0027. The output will be \u0027+0000\u0027 when the offset is zero.\n * Four letters outputs the {@linkplain TextStyle#FULL full} form of localized\n * offset, equivalent to four letters of Offset-O. The output will be the\n * corresponding localized offset text if the offset is zero. Five\n * letters outputs the hour, minute, with optional second if non-zero, with\n * colon. It outputs \u0027Z\u0027 if the offset is zero.\n * Six or more letters throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eOptional section\u003c/b\u003e: The optional section markers work exactly like\n * calling {@link DateTimeFormatterBuilder#optionalStart()} and\n * {@link DateTimeFormatterBuilder#optionalEnd()}.\n * \u003cp\u003e\n * \u003cb\u003ePad modifier\u003c/b\u003e: Modifies the pattern that immediately follows to be\n * padded with spaces. The pad width is determined by the number of pattern\n * letters. This is the same as calling\n * {@link DateTimeFormatterBuilder#padNext(int)}.\n * \u003cp\u003e\n * For example, \u0027ppH\u0027 outputs the hour-of-day padded on the left with spaces to\n * a width of 2.\n * \u003cp\u003e\n * Any unrecognized letter is an error. Any non-letter character, other than\n * \u0027[\u0027, \u0027]\u0027, \u0027{\u0027, \u0027}\u0027, \u0027#\u0027 and the single quote will be output directly.\n * Despite this, it is recommended to use single quotes around all characters\n * that you want to output directly to ensure that future changes do not break\n * your application.\n *\n * \u003ch3 id\u003d\"resolving\"\u003eResolving\u003c/h3\u003e\n * Parsing is implemented as a two-phase operation.\n * First, the text is parsed using the layout defined by the formatter, producing\n * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.\n * Second, the parsed data is \u003cem\u003eresolved\u003c/em\u003e, by validating, combining and\n * simplifying the various fields into more useful ones.\n * \u003cp\u003e\n * Five parsing methods are supplied by this class.\n * Four of these perform both the parse and resolve phases.\n * The fifth method, {@link #parseUnresolved(CharSequence, ParsePosition)},\n * only performs the first phase, leaving the result unresolved.\n * As such, it is essentially a low-level operation.\n * \u003cp\u003e\n * The resolve phase is controlled by two parameters, set on this class.\n * \u003cp\u003e\n * The {@link ResolverStyle} is an enum that offers three different approaches,\n * strict, smart and lenient. The smart option is the default.\n * It can be set using {@link #withResolverStyle(ResolverStyle)}.\n * \u003cp\u003e\n * The {@link #withResolverFields(TemporalField...)} parameter allows the\n * set of fields that will be resolved to be filtered before resolving starts.\n * For example, if the formatter has parsed a year, month, day-of-month\n * and day-of-year, then there are two approaches to resolve a date:\n * (year + month + day-of-month) and (year + day-of-year).\n * The resolver fields allows one of the two approaches to be selected.\n * If no resolver fields are set then both approaches must result in the same date.\n * \u003cp\u003e\n * Resolving separate fields to form a complete date and time is a complex\n * process with behaviour distributed across a number of classes.\n * It follows these steps:\n * \u003col\u003e\n * \u003cli\u003eThe chronology is determined.\n * The chronology of the result is either the chronology that was parsed,\n * or if no chronology was parsed, it is the chronology set on this class,\n * or if that is null, it is {@code IsoChronology}.\n * \u003cli\u003eThe {@code ChronoField} date fields are resolved.\n * This is achieved using {@link Chronology#resolveDate(Map, ResolverStyle)}.\n * Documentation about field resolution is located in the implementation\n * of {@code Chronology}.\n * \u003cli\u003eThe {@code ChronoField} time fields are resolved.\n * This is documented on {@link ChronoField} and is the same for all chronologies.\n * \u003cli\u003eAny fields that are not {@code ChronoField} are processed.\n * This is achieved using {@link TemporalField#resolve(Map, TemporalAccessor, ResolverStyle)}.\n * Documentation about field resolution is located in the implementation\n * of {@code TemporalField}.\n * \u003cli\u003eThe {@code ChronoField} date and time fields are re-resolved.\n * This allows fields in step four to produce {@code ChronoField} values\n * and have them be processed into dates and times.\n * \u003cli\u003eA {@code LocalTime} is formed if there is at least an hour-of-day available.\n * This involves providing default values for minute, second and fraction of second.\n * \u003cli\u003eAny remaining unresolved fields are cross-checked against any\n * date and/or time that was resolved. Thus, an earlier stage would resolve\n * (year + month + day-of-month) to a date, and this stage would check that\n * day-of-week was valid for the date.\n * \u003cli\u003eIf an {@linkplain #parsedExcessDays() excess number of days}\n * was parsed then it is added to the date if a date is available.\n * \u003cli\u003e If a second-based field is present, but {@code LocalTime} was not parsed,\n * then the resolver ensures that milli, micro and nano second values are\n * available to meet the contract of {@link ChronoField}.\n * These will be set to zero if missing.\n * \u003cli\u003eIf both date and time were parsed and either an offset or zone is present,\n * the field {@link ChronoField#INSTANT_SECONDS} is created.\n * If an offset was parsed then the offset will be combined with the\n * {@code LocalDateTime} to form the instant, with any zone ignored.\n * If a {@code ZoneId} was parsed without an offset then the zone will be\n * combined with the {@code LocalDateTime} to form the instant using the rules\n * of {@link ChronoLocalDateTime#atZone(ZoneId)}.\n * \u003c/ol\u003e\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class DateTimeFormatter {\n\n    /**\n     * The printer and/or parser to use, not null.\n     */\n    private final CompositePrinterParser printerParser;\n    /**\n     * The locale to use for formatting, not null.\n     */\n    private final Locale locale;\n    /**\n     * The symbols to use for formatting, not null.\n     */\n    private final DecimalStyle decimalStyle;\n    /**\n     * The resolver style to use, not null.\n     */\n    private final ResolverStyle resolverStyle;\n    /**\n     * The fields to use in resolving, null for all fields.\n     */\n    private final Set\u003cTemporalField\u003e resolverFields;\n    /**\n     * The chronology to use for formatting, null for no override.\n     */\n    private final Chronology chrono;\n    /**\n     * The zone to use for formatting, null for no override.\n     */\n    private final ZoneId zone;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a formatter using the specified pattern.\n     * \u003cp\u003e\n     * This method will create a formatter based on a simple\n     * \u003ca href\u003d\"#patterns\"\u003epattern of letters and symbols\u003c/a\u003e\n     * as described in the class documentation.\n     * For example, {@code d MMM uuuu} will format 2011-12-03 as \u00273 Dec 2011\u0027.\n     * \u003cp\u003e\n     * The formatter will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * This can be changed using {@link DateTimeFormatter#withLocale(Locale)} on the returned formatter.\n     * Alternatively use the {@link #ofPattern(String, Locale)} variant of this method.\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses {@link ResolverStyle#SMART SMART} resolver style.\n     *\n     * @param pattern  the pattern to use, not null\n     * @return the formatter based on the pattern, not null\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormatterBuilder#appendPattern(String)\n     */\n    public static DateTimeFormatter ofPattern(String pattern) {\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n    }\n\n    /**\n     * Creates a formatter using the specified pattern and locale.\n     * \u003cp\u003e\n     * This method will create a formatter based on a simple\n     * \u003ca href\u003d\"#patterns\"\u003epattern of letters and symbols\u003c/a\u003e\n     * as described in the class documentation.\n     * For example, {@code d MMM uuuu} will format 2011-12-03 as \u00273 Dec 2011\u0027.\n     * \u003cp\u003e\n     * The formatter will use the specified locale.\n     * This can be changed using {@link DateTimeFormatter#withLocale(Locale)} on the returned formatter.\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses {@link ResolverStyle#SMART SMART} resolver style.\n     *\n     * @param pattern  the pattern to use, not null\n     * @param locale  the locale to use, not null\n     * @return the formatter based on the pattern, not null\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormatterBuilder#appendPattern(String)\n     */\n    public static DateTimeFormatter ofPattern(String pattern, Locale locale) {\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter(locale);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a locale specific date format for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a date.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     *\n     * @param dateStyle  the formatter style to obtain, not null\n     * @return the date formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedDate(FormatStyle dateStyle) {\n        Objects.requireNonNull(dateStyle, \"dateStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(dateStyle, null)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    /**\n     * Returns a locale specific time format for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a time.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     * The {@code FULL} and {@code LONG} styles typically require a time-zone.\n     * When formatting using these styles, a {@code ZoneId} must be available,\n     * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.\n     *\n     * @param timeStyle  the formatter style to obtain, not null\n     * @return the time formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedTime(FormatStyle timeStyle) {\n        Objects.requireNonNull(timeStyle, \"timeStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(null, timeStyle)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    /**\n     * Returns a locale specific date-time formatter for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a date-time.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     * The {@code FULL} and {@code LONG} styles typically require a time-zone.\n     * When formatting using these styles, a {@code ZoneId} must be available,\n     * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.\n     *\n     * @param dateTimeStyle  the formatter style to obtain, not null\n     * @return the date-time formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateTimeStyle) {\n        Objects.requireNonNull(dateTimeStyle, \"dateTimeStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(dateTimeStyle, dateTimeStyle)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    /**\n     * Returns a locale specific date and time format for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a date-time.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault() default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     * The {@code FULL} and {@code LONG} styles typically require a time-zone.\n     * When formatting using these styles, a {@code ZoneId} must be available,\n     * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.\n     *\n     * @param dateStyle  the date formatter style to obtain, not null\n     * @param timeStyle  the time formatter style to obtain, not null\n     * @return the date, time or date-time formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateStyle, FormatStyle timeStyle) {\n        Objects.requireNonNull(dateStyle, \"dateStyle\");\n        Objects.requireNonNull(timeStyle, \"timeStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(dateStyle, timeStyle)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date without an\n     * offset, such as \u00272011-12-03\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended local date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits or more for the {@link ChronoField#YEAR year}.\n     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.\n     * Years outside that range will have a prefixed positive or negative symbol.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MONTH_OF_YEAR month-of-year}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eTwo digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_LOCAL_DATE;\n    static {\n        ISO_LOCAL_DATE \u003d new DateTimeFormatterBuilder()\n                .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(MONTH_OF_YEAR, 2)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(DAY_OF_MONTH, 2)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date with an\n     * offset, such as \u00272011-12-03+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE}\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_OFFSET_DATE;\n    static {\n        ISO_OFFSET_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE)\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date with the\n     * offset if available, such as \u00272011-12-03\u0027 or \u00272011-12-03+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE}\n     * \u003cli\u003eIf the offset is not available then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_DATE;\n    static {\n        ISO_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO time formatter that formats or parses a time without an\n     * offset, such as \u002710:15\u0027 or \u002710:15:30\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended local time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eTwo digits for the {@link ChronoField#HOUR_OF_DAY hour-of-day}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MINUTE_OF_HOUR minute-of-hour}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the second-of-minute is not available then the format is complete.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#SECOND_OF_MINUTE second-of-minute}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the nano-of-second is zero or not available then the format is complete.\n     * \u003cli\u003eA decimal point\n     * \u003cli\u003eOne to nine digits for the {@link ChronoField#NANO_OF_SECOND nano-of-second}.\n     *  As many digits will be output as required.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_LOCAL_TIME;\n    static {\n        ISO_LOCAL_TIME \u003d new DateTimeFormatterBuilder()\n                .appendValue(HOUR_OF_DAY, 2)\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(MINUTE_OF_HOUR, 2)\n                .optionalStart()\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(SECOND_OF_MINUTE, 2)\n                .optionalStart()\n                .appendFraction(NANO_OF_SECOND, 0, 9, true)\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO time formatter that formats or parses a time with an\n     * offset, such as \u002710:15+01:00\u0027 or \u002710:15:30+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_TIME}\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_OFFSET_TIME;\n    static {\n        ISO_OFFSET_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_TIME)\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO time formatter that formats or parses a time, with the\n     * offset if available, such as \u002710:15\u0027, \u002710:15:30\u0027 or \u002710:15:30+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_TIME}\n     * \u003cli\u003eIf the offset is not available then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_TIME;\n    static {\n        ISO_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_TIME)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date-time formatter that formats or parses a date-time without\n     * an offset, such as \u00272011-12-03T10:15:30\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset date-time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE}\n     * \u003cli\u003eThe letter \u0027T\u0027. Parsing is case insensitive.\n     * \u003cli\u003eThe {@link #ISO_LOCAL_TIME}\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_LOCAL_DATE_TIME;\n    static {\n        ISO_LOCAL_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE)\n                .appendLiteral(\u0027T\u0027)\n                .append(ISO_LOCAL_TIME)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date-time formatter that formats or parses a date-time with an\n     * offset, such as \u00272011-12-03T10:15:30+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset date-time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE_TIME}\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  The offset parsing is lenient, which allows the minutes and seconds to be optional.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_OFFSET_DATE_TIME;\n    static {\n        ISO_OFFSET_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE_TIME)\n                .parseLenient()\n                .appendOffsetId()\n                .parseStrict()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO-like date-time formatter that formats or parses a date-time with\n     * offset and zone, such as \u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * a format that extends the ISO-8601 extended offset date-time format\n     * to add the time-zone.\n     * The section in square brackets is not part of the ISO-8601 standard.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_OFFSET_DATE_TIME}\n     * \u003cli\u003eIf the zone ID is not available or is a {@code ZoneOffset} then the format is complete.\n     * \u003cli\u003eAn open square bracket \u0027[\u0027.\n     * \u003cli\u003eThe {@link ZoneId#getId() zone ID}. This is not part of the ISO-8601 standard.\n     *  Parsing is case sensitive.\n     * \u003cli\u003eA close square bracket \u0027]\u0027.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_ZONED_DATE_TIME;\n    static {\n        ISO_ZONED_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .append(ISO_OFFSET_DATE_TIME)\n                .optionalStart()\n                .appendLiteral(\u0027[\u0027)\n                .parseCaseSensitive()\n                .appendZoneRegionId()\n                .appendLiteral(\u0027]\u0027)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO-like date-time formatter that formats or parses a date-time with\n     * the offset and zone if available, such as \u00272011-12-03T10:15:30\u0027,\n     * \u00272011-12-03T10:15:30+01:00\u0027 or \u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended local or offset date-time format, as well as the\n     * extended non-ISO form specifying the time-zone.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE_TIME}\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     * \u003cli\u003eIf the zone ID is not available or is a {@code ZoneOffset} then the format is complete.\n     * \u003cli\u003eAn open square bracket \u0027[\u0027.\n     * \u003cli\u003eThe {@link ZoneId#getId() zone ID}. This is not part of the ISO-8601 standard.\n     *  Parsing is case sensitive.\n     * \u003cli\u003eA close square bracket \u0027]\u0027.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_DATE_TIME;\n    static {\n        ISO_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .append(ISO_LOCAL_DATE_TIME)\n                .optionalStart()\n                .appendOffsetId()\n                .optionalStart()\n                .appendLiteral(\u0027[\u0027)\n                .parseCaseSensitive()\n                .appendZoneRegionId()\n                .appendLiteral(\u0027]\u0027)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses the ordinal date\n     * without an offset, such as \u00272012-337\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended ordinal date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits or more for the {@link ChronoField#YEAR year}.\n     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.\n     * Years outside that range will have a prefixed positive or negative symbol.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eThree digits for the {@link ChronoField#DAY_OF_YEAR day-of-year}.\n     *  This is pre-padded by zero to ensure three digits.\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_ORDINAL_DATE;\n    static {\n        ISO_ORDINAL_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(DAY_OF_YEAR, 3)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses the week-based date\n     * without an offset, such as \u00272012-W48-6\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended week-based date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits or more for the {@link IsoFields#WEEK_BASED_YEAR week-based-year}.\n     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.\n     * Years outside that range will have a prefixed positive or negative symbol.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eThe letter \u0027W\u0027. Parsing is case insensitive.\n     * \u003cli\u003eTwo digits for the {@link IsoFields#WEEK_OF_WEEK_BASED_YEAR week-of-week-based-year}.\n     *  This is pre-padded by zero to ensure three digits.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eOne digit for the {@link ChronoField#DAY_OF_WEEK day-of-week}.\n     *  The value run from Monday (1) to Sunday (7).\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_WEEK_DATE;\n    static {\n        ISO_WEEK_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendValue(IsoFields.WEEK_BASED_YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n                .appendLiteral(\"-W\")\n                .appendValue(IsoFields.WEEK_OF_WEEK_BASED_YEAR, 2)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(DAY_OF_WEEK, 1)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO instant formatter that formats or parses an instant in UTC,\n     * such as \u00272011-12-03T10:15:30Z\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 instant format.\n     * When formatting, the second-of-minute is always output.\n     * The nano-of-second outputs zero, three, six or nine digits as necessary.\n     * When parsing, time to at least the seconds field is required.\n     * Fractional seconds from zero to nine are parsed.\n     * The localized decimal style is not used.\n     * \u003cp\u003e\n     * This is a special case formatter intended to allow a human readable form\n     * of an {@link java.time.Instant}. The {@code Instant} class is designed to\n     * only represent a point in time and internally stores a value in nanoseconds\n     * from a fixed epoch of 1970-01-01Z. As such, an {@code Instant} cannot be\n     * formatted as a date or time without providing some form of time-zone.\n     * This formatter allows the {@code Instant} to be formatted, by providing\n     * a suitable conversion using {@code ZoneOffset.UTC}.\n     * \u003cp\u003e\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_OFFSET_DATE_TIME} where the instant is converted from\n     *  {@link ChronoField#INSTANT_SECONDS} and {@link ChronoField#NANO_OF_SECOND}\n     *  using the {@code UTC} offset. Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_INSTANT;\n    static {\n        ISO_INSTANT \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendInstant()\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date without an\n     * offset, such as \u002720111203\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 basic local date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits for the {@link ChronoField#YEAR year}.\n     *  Only years in the range 0000 to 9999 are supported.\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MONTH_OF_YEAR month-of-year}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eTwo digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID} without colons. If the offset has\n     *  seconds then they will be handled even though this is not part of the ISO-8601 standard.\n     *  The offset parsing is lenient, which allows the minutes and seconds to be optional.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter BASIC_ISO_DATE;\n    static {\n        BASIC_ISO_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendValue(YEAR, 4)\n                .appendValue(MONTH_OF_YEAR, 2)\n                .appendValue(DAY_OF_MONTH, 2)\n                .optionalStart()\n                .parseLenient()\n                .appendOffset(\"+HHMMss\", \"Z\")\n                .parseStrict()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The RFC-1123 date-time formatter, such as \u0027Tue, 3 Jun 2008 11:05:30 GMT\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * most of the RFC-1123 format.\n     * RFC-1123 updates RFC-822 changing the year from two digits to four.\n     * This implementation requires a four digit year.\n     * This implementation also does not handle North American or military zone\n     * names, only \u0027GMT\u0027 and offset amounts.\n     * \u003cp\u003e\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eIf the day-of-week is not available to format or parse then jump to day-of-month.\n     * \u003cli\u003eThree letter {@link ChronoField#DAY_OF_WEEK day-of-week} in English.\n     * \u003cli\u003eA comma\n     * \u003cli\u003eA space\n     * \u003cli\u003eOne or two digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.\n     * \u003cli\u003eA space\n     * \u003cli\u003eThree letter {@link ChronoField#MONTH_OF_YEAR month-of-year} in English.\n     * \u003cli\u003eA space\n     * \u003cli\u003eFour digits for the {@link ChronoField#YEAR year}.\n     *  Only years in the range 0000 to 9999 are supported.\n     * \u003cli\u003eA space\n     * \u003cli\u003eTwo digits for the {@link ChronoField#HOUR_OF_DAY hour-of-day}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MINUTE_OF_HOUR minute-of-hour}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the second-of-minute is not available then jump to the next space.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#SECOND_OF_MINUTE second-of-minute}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA space\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID} without colons or seconds.\n     *  An offset of zero uses \"GMT\". North American zone names and military zone names are not handled.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Parsing is case insensitive.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     */\n    public static final DateTimeFormatter RFC_1123_DATE_TIME;\n    static {\n        // manually code maps to ensure correct data always used\n        // (locale data can be changed by application code)\n        Map\u003cLong, String\u003e dow \u003d new HashMap\u003c\u003e();\n        dow.put(1L, \"Mon\");\n        dow.put(2L, \"Tue\");\n        dow.put(3L, \"Wed\");\n        dow.put(4L, \"Thu\");\n        dow.put(5L, \"Fri\");\n        dow.put(6L, \"Sat\");\n        dow.put(7L, \"Sun\");\n        Map\u003cLong, String\u003e moy \u003d new HashMap\u003c\u003e();\n        moy.put(1L, \"Jan\");\n        moy.put(2L, \"Feb\");\n        moy.put(3L, \"Mar\");\n        moy.put(4L, \"Apr\");\n        moy.put(5L, \"May\");\n        moy.put(6L, \"Jun\");\n        moy.put(7L, \"Jul\");\n        moy.put(8L, \"Aug\");\n        moy.put(9L, \"Sep\");\n        moy.put(10L, \"Oct\");\n        moy.put(11L, \"Nov\");\n        moy.put(12L, \"Dec\");\n        RFC_1123_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .parseLenient()\n                .optionalStart()\n                .appendText(DAY_OF_WEEK, dow)\n                .appendLiteral(\", \")\n                .optionalEnd()\n                .appendValue(DAY_OF_MONTH, 1, 2, SignStyle.NOT_NEGATIVE)\n                .appendLiteral(\u0027 \u0027)\n                .appendText(MONTH_OF_YEAR, moy)\n                .appendLiteral(\u0027 \u0027)\n                .appendValue(YEAR, 4)  // 2 digit year not handled\n                .appendLiteral(\u0027 \u0027)\n                .appendValue(HOUR_OF_DAY, 2)\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(MINUTE_OF_HOUR, 2)\n                .optionalStart()\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(SECOND_OF_MINUTE, 2)\n                .optionalEnd()\n                .appendLiteral(\u0027 \u0027)\n                .appendOffset(\"+HHMM\", \"GMT\")  // should handle UT/Z/EST/EDT/CST/CDT/MST/MDT/PST/MDT\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * A query that provides access to the excess days that were parsed.\n     * \u003cp\u003e\n     * This returns a singleton {@linkplain TemporalQuery query} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null period, with a zero period returned instead of null.\n     * \u003cp\u003e\n     * There are two situations where this query may return a non-zero period.\n     * \u003cul\u003e\n     * \u003cli\u003eIf the {@code ResolverStyle} is {@code LENIENT} and a time is parsed\n     *  without a date, then the complete result of the parse consists of a\n     *  {@code LocalTime} and an excess {@code Period} in days.\n     *\n     * \u003cli\u003eIf the {@code ResolverStyle} is {@code SMART} and a time is parsed\n     *  without a date where the time is 24:00:00, then the complete result of\n     *  the parse consists of a {@code LocalTime} of 00:00:00 and an excess\n     *  {@code Period} of one day.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * In both cases, if a complete {@code ChronoLocalDateTime} or {@code Instant}\n     * is parsed, then the excess days are added to the date part.\n     * As a result, this query will return a zero period.\n     * \u003cp\u003e\n     * The {@code SMART} behaviour handles the common \"end of day\" 24:00 value.\n     * Processing in {@code LENIENT} mode also produces the same result:\n     * \u003cpre\u003e\n     *  Text to parse        Parsed object                         Excess days\n     *  \"2012-12-03T00:00\"   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO\n     *  \"2012-12-03T24:00\"   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO\n     *  \"00:00\"              LocalTime.of(0, 0)                    ZERO\n     *  \"24:00\"              LocalTime.of(0, 0)                    Period.ofDays(1)\n     * \u003c/pre\u003e\n     * The query can be used as follows:\n     * \u003cpre\u003e\n     *  TemporalAccessor parsed \u003d formatter.parse(str);\n     *  LocalTime time \u003d parsed.query(LocalTime::from);\n     *  Period extraDays \u003d parsed.query(DateTimeFormatter.parsedExcessDays());\n     * \u003c/pre\u003e\n     * @return a query that provides access to the excess days that were parsed\n     */\n    public static final TemporalQuery\u003cPeriod\u003e parsedExcessDays() {\n        return PARSED_EXCESS_DAYS;\n    }\n    private static final TemporalQuery\u003cPeriod\u003e PARSED_EXCESS_DAYS \u003d t -\u003e {\n        if (t instanceof Parsed) {\n            return ((Parsed) t).excessDays;\n        } else {\n            return Period.ZERO;\n        }\n    };\n\n    /**\n     * A query that provides access to whether a leap-second was parsed.\n     * \u003cp\u003e\n     * This returns a singleton {@linkplain TemporalQuery query} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null boolean, true if parsing saw a leap-second, false if not.\n     * \u003cp\u003e\n     * Instant parsing handles the special \"leap second\" time of \u002723:59:60\u0027.\n     * Leap seconds occur at \u002723:59:60\u0027 in the UTC time-zone, but at other\n     * local times in different time-zones. To avoid this potential ambiguity,\n     * the handling of leap-seconds is limited to\n     * {@link DateTimeFormatterBuilder#appendInstant()}, as that method\n     * always parses the instant with the UTC zone offset.\n     * \u003cp\u003e\n     * If the time \u002723:59:60\u0027 is received, then a simple conversion is applied,\n     * replacing the second-of-minute of 60 with 59. This query can be used\n     * on the parse result to determine if the leap-second adjustment was made.\n     * The query will return {@code true} if it did adjust to remove the\n     * leap-second, and {@code false} if not. Note that applying a leap-second\n     * smoothing mechanism, such as UTC-SLS, is the responsibility of the\n     * application, as follows:\n     * \u003cpre\u003e\n     *  TemporalAccessor parsed \u003d formatter.parse(str);\n     *  Instant instant \u003d parsed.query(Instant::from);\n     *  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {\n     *    // validate leap-second is correct and apply correct smoothing\n     *  }\n     * \u003c/pre\u003e\n     * @return a query that provides access to whether a leap-second was parsed\n     */\n    public static final TemporalQuery\u003cBoolean\u003e parsedLeapSecond() {\n        return PARSED_LEAP_SECOND;\n    }\n    private static final TemporalQuery\u003cBoolean\u003e PARSED_LEAP_SECOND \u003d t -\u003e {\n        if (t instanceof Parsed) {\n            return ((Parsed) t).leapSecond;\n        } else {\n            return Boolean.FALSE;\n        }\n    };\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param printerParser  the printer/parser to use, not null\n     * @param locale  the locale to use, not null\n     * @param decimalStyle  the DecimalStyle to use, not null\n     * @param resolverStyle  the resolver style to use, not null\n     * @param resolverFields  the fields to use during resolving, null for all fields\n     * @param chrono  the chronology to use, null for no override\n     * @param zone  the zone to use, null for no override\n     */\n    DateTimeFormatter(CompositePrinterParser printerParser,\n            Locale locale, DecimalStyle decimalStyle,\n            ResolverStyle resolverStyle, Set\u003cTemporalField\u003e resolverFields,\n            Chronology chrono, ZoneId zone) {\n        this.printerParser \u003d Objects.requireNonNull(printerParser, \"printerParser\");\n        this.resolverFields \u003d resolverFields;\n        this.locale \u003d Objects.requireNonNull(locale, \"locale\");\n        this.decimalStyle \u003d Objects.requireNonNull(decimalStyle, \"decimalStyle\");\n        this.resolverStyle \u003d Objects.requireNonNull(resolverStyle, \"resolverStyle\");\n        this.chrono \u003d chrono;\n        this.zone \u003d zone;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the locale to be used during formatting.\n     * \u003cp\u003e\n     * This is used to lookup any part of the formatter needing specific\n     * localization, such as the text or localized pattern.\n     *\n     * @return the locale of this formatter, not null\n     */\n    public Locale getLocale() {\n        return locale;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new locale.\n     * \u003cp\u003e\n     * This is used to lookup any part of the formatter needing specific\n     * localization, such as the text or localized pattern.\n     * \u003cp\u003e\n     * The locale is stored as passed in, without further processing.\n     * If the locale has \u003ca href\u003d\"../../util/Locale.html#def_locale_extension\"\u003e\n     * Unicode extensions\u003c/a\u003e, they may be used later in text\n     * processing. To set the chronology, time-zone and decimal style from\n     * unicode extensions, see {@link #localizedBy localizedBy()}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param locale  the new locale, not null\n     * @return a formatter based on this formatter with the requested locale, not null\n     * @see #localizedBy(Locale)\n     */\n    public DateTimeFormatter withLocale(Locale locale) {\n        if (this.locale.equals(locale)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    /**\n     * Returns a copy of this formatter with localized values of the locale,\n     * calendar, region, decimal style and/or timezone, that supercede values in\n     * this formatter.\n     * \u003cp\u003e\n     * This is used to lookup any part of the formatter needing specific\n     * localization, such as the text or localized pattern. If the locale contains the\n     * \"ca\" (calendar), \"nu\" (numbering system), \"rg\" (region override), and/or\n     * \"tz\" (timezone)\n     * \u003ca href\u003d\"../../util/Locale.html#def_locale_extension\"\u003eUnicode extensions\u003c/a\u003e,\n     * the chronology, numbering system and/or the zone are overridden. If both \"ca\"\n     * and \"rg\" are specified, the chronology from the \"ca\" extension supersedes the\n     * implicit one from the \"rg\" extension. Same is true for the \"nu\" extension.\n     * \u003cp\u003e\n     * Unlike the {@link #withLocale withLocale} method, the call to this method may\n     * produce a different formatter depending on the order of method chaining with\n     * other withXXXX() methods.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param locale  the locale, not null\n     * @return a formatter based on this formatter with localized values of\n     *      the calendar, decimal style and/or timezone, that supercede values in this\n     *      formatter.\n     * @see #withLocale(Locale)\n     * @since 10\n     */\n    public DateTimeFormatter localizedBy(Locale locale) {\n        if (this.locale.equals(locale)) {\n            return this;\n        }\n\n        // Check for decimalStyle/chronology/timezone in locale object\n        Chronology c \u003d locale.getUnicodeLocaleType(\"ca\") !\u003d null ?\n                       Chronology.ofLocale(locale) : chrono;\n        DecimalStyle ds \u003d locale.getUnicodeLocaleType(\"nu\") !\u003d null ?\n                       DecimalStyle.of(locale) : decimalStyle;\n        String tzType \u003d locale.getUnicodeLocaleType(\"tz\");\n        ZoneId z  \u003d tzType !\u003d null ?\n                    TimeZoneNameUtility.convertLDMLShortID(tzType)\n                        .map(ZoneId::of)\n                        .orElse(zone) :\n                    zone;\n        return new DateTimeFormatter(printerParser, locale, ds, resolverStyle, resolverFields, c, z);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the DecimalStyle to be used during formatting.\n     *\n     * @return the locale of this formatter, not null\n     */\n    public DecimalStyle getDecimalStyle() {\n        return decimalStyle;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new DecimalStyle.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param decimalStyle  the new DecimalStyle, not null\n     * @return a formatter based on this formatter with the requested DecimalStyle, not null\n     */\n    public DateTimeFormatter withDecimalStyle(DecimalStyle decimalStyle) {\n        if (this.decimalStyle.equals(decimalStyle)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the overriding chronology to be used during formatting.\n     * \u003cp\u003e\n     * This returns the override chronology, used to convert dates.\n     * By default, a formatter has no override chronology, returning null.\n     * See {@link #withChronology(Chronology)} for more details on overriding.\n     *\n     * @return the override chronology of this formatter, null if no override\n     */\n    public Chronology getChronology() {\n        return chrono;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new override chronology.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but\n     * with the override chronology set.\n     * By default, a formatter has no override chronology, returning null.\n     * \u003cp\u003e\n     * If an override is added, then any date that is formatted or parsed will be affected.\n     * \u003cp\u003e\n     * When formatting, if the temporal object contains a date, then it will\n     * be converted to a date in the override chronology.\n     * Whether the temporal contains a date is determined by querying the\n     * {@link ChronoField#EPOCH_DAY EPOCH_DAY} field.\n     * Any time or zone will be retained unaltered unless overridden.\n     * \u003cp\u003e\n     * If the temporal object does not contain a date, but does contain one\n     * or more {@code ChronoField} date fields, then a {@code DateTimeException}\n     * is thrown. In all other cases, the override chronology is added to the temporal,\n     * replacing any previous chronology, but without changing the date/time.\n     * \u003cp\u003e\n     * When parsing, there are two distinct cases to consider.\n     * If a chronology has been parsed directly from the text, perhaps because\n     * {@link DateTimeFormatterBuilder#appendChronologyId()} was used, then\n     * this override chronology has no effect.\n     * If no zone has been parsed, then this override chronology will be used\n     * to interpret the {@code ChronoField} values into a date according to the\n     * date resolving rules of the chronology.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param chrono  the new chronology, null if no override\n     * @return a formatter based on this formatter with the requested override chronology, not null\n     */\n    public DateTimeFormatter withChronology(Chronology chrono) {\n        if (Objects.equals(this.chrono, chrono)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the overriding zone to be used during formatting.\n     * \u003cp\u003e\n     * This returns the override zone, used to convert instants.\n     * By default, a formatter has no override zone, returning null.\n     * See {@link #withZone(ZoneId)} for more details on overriding.\n     *\n     * @return the override zone of this formatter, null if no override\n     */\n    public ZoneId getZone() {\n        return zone;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new override zone.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but\n     * with the override zone set.\n     * By default, a formatter has no override zone, returning null.\n     * \u003cp\u003e\n     * If an override is added, then any instant that is formatted or parsed will be affected.\n     * \u003cp\u003e\n     * When formatting, if the temporal object contains an instant, then it will\n     * be converted to a zoned date-time using the override zone.\n     * Whether the temporal is an instant is determined by querying the\n     * {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS} field.\n     * If the input has a chronology then it will be retained unless overridden.\n     * If the input does not have a chronology, such as {@code Instant}, then\n     * the ISO chronology will be used.\n     * \u003cp\u003e\n     * If the temporal object does not contain an instant, but does contain\n     * an offset then an additional check is made. If the normalized override\n     * zone is an offset that differs from the offset of the temporal, then\n     * a {@code DateTimeException} is thrown. In all other cases, the override\n     * zone is added to the temporal, replacing any previous zone, but without\n     * changing the date/time.\n     * \u003cp\u003e\n     * When parsing, there are two distinct cases to consider.\n     * If a zone has been parsed directly from the text, perhaps because\n     * {@link DateTimeFormatterBuilder#appendZoneId()} was used, then\n     * this override zone has no effect.\n     * If no zone has been parsed, then this override zone will be included in\n     * the result of the parse where it can be used to build instants and date-times.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the new override zone, null if no override\n     * @return a formatter based on this formatter with the requested override zone, not null\n     */\n    public DateTimeFormatter withZone(ZoneId zone) {\n        if (Objects.equals(this.zone, zone)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the resolver style to use during parsing.\n     * \u003cp\u003e\n     * This returns the resolver style, used during the second phase of parsing\n     * when fields are resolved into dates and times.\n     * By default, a formatter has the {@link ResolverStyle#SMART SMART} resolver style.\n     * See {@link #withResolverStyle(ResolverStyle)} for more details.\n     *\n     * @return the resolver style of this formatter, not null\n     */\n    public ResolverStyle getResolverStyle() {\n        return resolverStyle;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new resolver style.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but\n     * with the resolver style set. By default, a formatter has the\n     * {@link ResolverStyle#SMART SMART} resolver style.\n     * \u003cp\u003e\n     * Changing the resolver style only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver style is used to control how phase 2, resolving, happens.\n     * See {@code ResolverStyle} for more information on the options available.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param resolverStyle  the new resolver style, not null\n     * @return a formatter based on this formatter with the requested resolver style, not null\n     */\n    public DateTimeFormatter withResolverStyle(ResolverStyle resolverStyle) {\n        Objects.requireNonNull(resolverStyle, \"resolverStyle\");\n        if (Objects.equals(this.resolverStyle, resolverStyle)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the resolver fields to use during parsing.\n     * \u003cp\u003e\n     * This returns the resolver fields, used during the second phase of parsing\n     * when fields are resolved into dates and times.\n     * By default, a formatter has no resolver fields, and thus returns null.\n     * See {@link #withResolverFields(Set)} for more details.\n     *\n     * @return the immutable set of resolver fields of this formatter, null if no fields\n     */\n    public Set\u003cTemporalField\u003e getResolverFields() {\n        return resolverFields;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new set of resolver fields.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but with\n     * the resolver fields set. By default, a formatter has no resolver fields.\n     * \u003cp\u003e\n     * Changing the resolver fields only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver fields are used to filter the field-value pairs between phase 1 and 2.\n     * \u003cp\u003e\n     * This can be used to select between two or more ways that a date or time might\n     * be resolved. For example, if the formatter consists of year, month, day-of-month\n     * and day-of-year, then there are two ways to resolve a date.\n     * Calling this method with the arguments {@link ChronoField#YEAR YEAR} and\n     * {@link ChronoField#DAY_OF_YEAR DAY_OF_YEAR} will ensure that the date is\n     * resolved using the year and day-of-year, effectively meaning that the month\n     * and day-of-month are ignored during the resolving phase.\n     * \u003cp\u003e\n     * In a similar manner, this method can be used to ignore secondary fields that\n     * would otherwise be cross-checked. For example, if the formatter consists of year,\n     * month, day-of-month and day-of-week, then there is only one way to resolve a\n     * date, but the parsed value for day-of-week will be cross-checked against the\n     * resolved date. Calling this method with the arguments {@link ChronoField#YEAR YEAR},\n     * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and\n     * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} will ensure that the date is\n     * resolved correctly, but without any cross-check for the day-of-week.\n     * \u003cp\u003e\n     * In implementation terms, this method behaves as follows. The result of the\n     * parsing phase can be considered to be a map of field to value. The behavior\n     * of this method is to cause that map to be filtered between phase 1 and 2,\n     * removing all fields other than those specified as arguments to this method.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param resolverFields  the new set of resolver fields, null if no fields\n     * @return a formatter based on this formatter with the requested resolver style, not null\n     */\n    public DateTimeFormatter withResolverFields(TemporalField... resolverFields) {\n        Set\u003cTemporalField\u003e fields \u003d null;\n        if (resolverFields !\u003d null) {\n            // Set.of cannot be used because it is hostile to nulls and duplicate elements\n            fields \u003d Collections.unmodifiableSet(new HashSet\u003c\u003e(Arrays.asList(resolverFields)));\n        }\n        if (Objects.equals(this.resolverFields, fields)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, fields, chrono, zone);\n    }\n\n    /**\n     * Returns a copy of this formatter with a new set of resolver fields.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but with\n     * the resolver fields set. By default, a formatter has no resolver fields.\n     * \u003cp\u003e\n     * Changing the resolver fields only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver fields are used to filter the field-value pairs between phase 1 and 2.\n     * \u003cp\u003e\n     * This can be used to select between two or more ways that a date or time might\n     * be resolved. For example, if the formatter consists of year, month, day-of-month\n     * and day-of-year, then there are two ways to resolve a date.\n     * Calling this method with the arguments {@link ChronoField#YEAR YEAR} and\n     * {@link ChronoField#DAY_OF_YEAR DAY_OF_YEAR} will ensure that the date is\n     * resolved using the year and day-of-year, effectively meaning that the month\n     * and day-of-month are ignored during the resolving phase.\n     * \u003cp\u003e\n     * In a similar manner, this method can be used to ignore secondary fields that\n     * would otherwise be cross-checked. For example, if the formatter consists of year,\n     * month, day-of-month and day-of-week, then there is only one way to resolve a\n     * date, but the parsed value for day-of-week will be cross-checked against the\n     * resolved date. Calling this method with the arguments {@link ChronoField#YEAR YEAR},\n     * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and\n     * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} will ensure that the date is\n     * resolved correctly, but without any cross-check for the day-of-week.\n     * \u003cp\u003e\n     * In implementation terms, this method behaves as follows. The result of the\n     * parsing phase can be considered to be a map of field to value. The behavior\n     * of this method is to cause that map to be filtered between phase 1 and 2,\n     * removing all fields other than those specified as arguments to this method.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param resolverFields  the new set of resolver fields, null if no fields\n     * @return a formatter based on this formatter with the requested resolver style, not null\n     */\n    public DateTimeFormatter withResolverFields(Set\u003cTemporalField\u003e resolverFields) {\n        if (Objects.equals(this.resolverFields, resolverFields)) {\n            return this;\n        }\n        if (resolverFields !\u003d null) {\n            resolverFields \u003d Collections.unmodifiableSet(new HashSet\u003c\u003e(resolverFields));\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats a date-time object using this formatter.\n     * \u003cp\u003e\n     * This formats the date-time to a String using the rules of the formatter.\n     *\n     * @param temporal  the temporal object to format, not null\n     * @return the formatted string, not null\n     * @throws DateTimeException if an error occurs during formatting\n     */\n    public String format(TemporalAccessor temporal) {\n        StringBuilder buf \u003d new StringBuilder(32);\n        formatTo(temporal, buf);\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats a date-time object to an {@code Appendable} using this formatter.\n     * \u003cp\u003e\n     * This outputs the formatted date-time to the specified destination.\n     * {@link Appendable} is a general purpose interface that is implemented by all\n     * key character output classes including {@code StringBuffer}, {@code StringBuilder},\n     * {@code PrintStream} and {@code Writer}.\n     * \u003cp\u003e\n     * Although {@code Appendable} methods throw an {@code IOException}, this method does not.\n     * Instead, any {@code IOException} is wrapped in a runtime exception.\n     *\n     * @param temporal  the temporal object to format, not null\n     * @param appendable  the appendable to format to, not null\n     * @throws DateTimeException if an error occurs during formatting\n     */\n    public void formatTo(TemporalAccessor temporal, Appendable appendable) {\n        Objects.requireNonNull(temporal, \"temporal\");\n        Objects.requireNonNull(appendable, \"appendable\");\n        try {\n            DateTimePrintContext context \u003d new DateTimePrintContext(temporal, this);\n            if (appendable instanceof StringBuilder) {\n                printerParser.format(context, (StringBuilder) appendable);\n            } else {\n                // buffer output to avoid writing to appendable in case of error\n                StringBuilder buf \u003d new StringBuilder(32);\n                printerParser.format(context, buf);\n                appendable.append(buf);\n            }\n        } catch (IOException ex) {\n            throw new DateTimeException(ex.getMessage(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Fully parses the text producing a temporal object.\n     * \u003cp\u003e\n     * This parses the entire text producing a temporal object.\n     * It is typically more useful to use {@link #parse(CharSequence, TemporalQuery)}.\n     * The result of this method is {@code TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     * \u003cp\u003e\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    public TemporalAccessor parse(CharSequence text) {\n        Objects.requireNonNull(text, \"text\");\n        try {\n            return parseResolved0(text, null);\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    /**\n     * Parses the text using this formatter, providing control over the text position.\n     * \u003cp\u003e\n     * This parses the text without requiring the parse to start from the beginning\n     * of the string or finish at the end.\n     * The result of this method is {@code TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     * \u003cp\u003e\n     * The text will be parsed from the specified start {@code ParsePosition}.\n     * The entire length of the text does not have to be parsed, the {@code ParsePosition}\n     * will be updated with the index at the end of parsing.\n     * \u003cp\u003e\n     * The operation of this method is slightly different to similar methods using\n     * {@code ParsePosition} on {@code java.text.Format}. That class will return\n     * errors using the error index on the {@code ParsePosition}. By contrast, this\n     * method will throw a {@link DateTimeParseException} if an error occurs, with\n     * the exception containing the error index.\n     * This change in behavior is necessary due to the increased complexity of\n     * parsing and resolving dates/times in this API.\n     * \u003cp\u003e\n     * If the formatter parses the same field more than once with different values,\n     * the result will be an error.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, not null\n     * @return the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    public TemporalAccessor parse(CharSequence text, ParsePosition position) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(position, \"position\");\n        try {\n            return parseResolved0(text, position);\n        } catch (DateTimeParseException | IndexOutOfBoundsException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Fully parses the text producing an object of the specified type.\n     * \u003cp\u003e\n     * Most applications should use this method for parsing.\n     * It parses the entire text to produce the required date-time.\n     * The query is typically a method reference to a {@code from(TemporalAccessor)} method.\n     * For example:\n     * \u003cpre\u003e\n     *  LocalDateTime dt \u003d parser.parse(str, LocalDateTime::from);\n     * \u003c/pre\u003e\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param \u003cT\u003e the type of the parsed date-time\n     * @param text  the text to parse, not null\n     * @param query  the query defining the type to parse to, not null\n     * @return the parsed date-time, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    public \u003cT\u003e T parse(CharSequence text, TemporalQuery\u003cT\u003e query) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(query, \"query\");\n        try {\n            return parseResolved0(text, null).query(query);\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    /**\n     * Fully parses the text producing an object of one of the specified types.\n     * \u003cp\u003e\n     * This parse method is convenient for use when the parser can handle optional elements.\n     * For example, a pattern of \u0027uuuu-MM-dd HH.mm[ VV]\u0027 can be fully parsed to a {@code ZonedDateTime},\n     * or partially parsed to a {@code LocalDateTime}.\n     * The queries must be specified in order, starting from the best matching full-parse option\n     * and ending with the worst matching minimal parse option.\n     * The query is typically a method reference to a {@code from(TemporalAccessor)} method.\n     * \u003cp\u003e\n     * The result is associated with the first type that successfully parses.\n     * Normally, applications will use {@code instanceof} to check the result.\n     * For example:\n     * \u003cpre\u003e\n     *  TemporalAccessor dt \u003d parser.parseBest(str, ZonedDateTime::from, LocalDateTime::from);\n     *  if (dt instanceof ZonedDateTime) {\n     *   ...\n     *  } else {\n     *   ...\n     *  }\n     * \u003c/pre\u003e\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param text  the text to parse, not null\n     * @param queries  the queries defining the types to attempt to parse to,\n     *  must implement {@code TemporalAccessor}, not null\n     * @return the parsed date-time, not null\n     * @throws IllegalArgumentException if less than 2 types are specified\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    public TemporalAccessor parseBest(CharSequence text, TemporalQuery\u003c?\u003e... queries) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(queries, \"queries\");\n        if (queries.length \u003c 2) {\n            throw new IllegalArgumentException(\"At least two queries must be specified\");\n        }\n        try {\n            TemporalAccessor resolved \u003d parseResolved0(text, null);\n            for (TemporalQuery\u003c?\u003e query : queries) {\n                try {\n                    return (TemporalAccessor) resolved.query(query);\n                } catch (RuntimeException ex) {\n                    // continue\n                }\n            }\n            throw new DateTimeException(\"Unable to convert parsed text using any of the specified queries\");\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    private DateTimeParseException createError(CharSequence text, RuntimeException ex) {\n        String abbr;\n        if (text.length() \u003e 64) {\n            abbr \u003d text.subSequence(0, 64).toString() + \"...\";\n        } else {\n            abbr \u003d text.toString();\n        }\n        return new DateTimeParseException(\"Text \u0027\" + abbr + \"\u0027 could not be parsed: \" + ex.getMessage(), text, 0, ex);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses and resolves the specified text.\n     * \u003cp\u003e\n     * This parses to a {@code TemporalAccessor} ensuring that the text is fully parsed.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, null if parsing whole string\n     * @return the resolved result of the parse, not null\n     * @throws DateTimeParseException if the parse fails\n     * @throws DateTimeException if an error occurs while resolving the date or time\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    private TemporalAccessor parseResolved0(final CharSequence text, final ParsePosition position) {\n        ParsePosition pos \u003d (position !\u003d null ? position : new ParsePosition(0));\n        DateTimeParseContext context \u003d parseUnresolved0(text, pos);\n        if (context \u003d\u003d null || pos.getErrorIndex() \u003e\u003d 0 || (position \u003d\u003d null \u0026\u0026 pos.getIndex() \u003c text.length())) {\n            String abbr;\n            if (text.length() \u003e 64) {\n                abbr \u003d text.subSequence(0, 64).toString() + \"...\";\n            } else {\n                abbr \u003d text.toString();\n            }\n            if (pos.getErrorIndex() \u003e\u003d 0) {\n                throw new DateTimeParseException(\"Text \u0027\" + abbr + \"\u0027 could not be parsed at index \" +\n                        pos.getErrorIndex(), text, pos.getErrorIndex());\n            } else {\n                throw new DateTimeParseException(\"Text \u0027\" + abbr + \"\u0027 could not be parsed, unparsed text found at index \" +\n                        pos.getIndex(), text, pos.getIndex());\n            }\n        }\n        return context.toResolved(resolverStyle, resolverFields);\n    }\n\n    /**\n     * Parses the text using this formatter, without resolving the result, intended\n     * for advanced use cases.\n     * \u003cp\u003e\n     * Parsing is implemented as a two-phase operation.\n     * First, the text is parsed using the layout defined by the formatter, producing\n     * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.\n     * Second, the parsed data is \u003cem\u003eresolved\u003c/em\u003e, by validating, combining and\n     * simplifying the various fields into more useful ones.\n     * This method performs the parsing stage but not the resolving stage.\n     * \u003cp\u003e\n     * The result of this method is {@code TemporalAccessor} which represents the\n     * data as seen in the input. Values are not validated, thus parsing a date string\n     * of \u00272012-00-65\u0027 would result in a temporal with three fields - year of \u00272012\u0027,\n     * month of \u00270\u0027 and day-of-month of \u002765\u0027.\n     * \u003cp\u003e\n     * The text will be parsed from the specified start {@code ParsePosition}.\n     * The entire length of the text does not have to be parsed, the {@code ParsePosition}\n     * will be updated with the index at the end of parsing.\n     * \u003cp\u003e\n     * Errors are returned using the error index field of the {@code ParsePosition}\n     * instead of {@code DateTimeParseException}.\n     * The returned error index will be set to an index indicative of the error.\n     * Callers must check for errors before using the result.\n     * \u003cp\u003e\n     * If the formatter parses the same field more than once with different values,\n     * the result will be an error.\n     * \u003cp\u003e\n     * This method is intended for advanced use cases that need access to the\n     * internal state during parsing. Typical application code should use\n     * {@link #parse(CharSequence, TemporalQuery)} or the parse method on the target type.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, not null\n     * @return the parsed text, null if the parse results in an error\n     * @throws DateTimeException if some problem occurs during parsing\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    public TemporalAccessor parseUnresolved(CharSequence text, ParsePosition position) {\n        DateTimeParseContext context \u003d parseUnresolved0(text, position);\n        if (context \u003d\u003d null) {\n            return null;\n        }\n        return context.toUnresolved();\n    }\n\n    private DateTimeParseContext parseUnresolved0(CharSequence text, ParsePosition position) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(position, \"position\");\n        DateTimeParseContext context \u003d new DateTimeParseContext(this);\n        int pos \u003d position.getIndex();\n        pos \u003d printerParser.parse(context, text, pos);\n        if (pos \u003c 0) {\n            position.setErrorIndex(~pos);  // index not updated from input\n            return null;\n        }\n        position.setIndex(pos);  // errorIndex not updated from input\n        return context;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the formatter as a composite printer parser.\n     *\n     * @param optional  whether the printer/parser should be optional\n     * @return the printer/parser, not null\n     */\n    CompositePrinterParser toPrinterParser(boolean optional) {\n        return printerParser.withOptional(optional);\n    }\n\n    /**\n     * Returns this formatter as a {@code java.text.Format} instance.\n     * \u003cp\u003e\n     * The returned {@link Format} instance will format any {@link TemporalAccessor}\n     * and parses to a resolved {@link TemporalAccessor}.\n     * \u003cp\u003e\n     * Exceptions will follow the definitions of {@code Format}, see those methods\n     * for details about {@code IllegalArgumentException} during formatting and\n     * {@code ParseException} or null during parsing.\n     * The format does not support attributing of the returned format string.\n     *\n     * @return this formatter as a classic format instance, not null\n     */\n    public Format toFormat() {\n        return new ClassicFormat(this, null);\n    }\n\n    /**\n     * Returns this formatter as a {@code java.text.Format} instance that will\n     * parse using the specified query.\n     * \u003cp\u003e\n     * The returned {@link Format} instance will format any {@link TemporalAccessor}\n     * and parses to the type specified.\n     * The type must be one that is supported by {@link #parse}.\n     * \u003cp\u003e\n     * Exceptions will follow the definitions of {@code Format}, see those methods\n     * for details about {@code IllegalArgumentException} during formatting and\n     * {@code ParseException} or null during parsing.\n     * The format does not support attributing of the returned format string.\n     *\n     * @param parseQuery  the query defining the type to parse to, not null\n     * @return this formatter as a classic format instance, not null\n     */\n    public Format toFormat(TemporalQuery\u003c?\u003e parseQuery) {\n        Objects.requireNonNull(parseQuery, \"parseQuery\");\n        return new ClassicFormat(this, parseQuery);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a description of the underlying formatters.\n     *\n     * @return a description of this formatter, not null\n     */\n    @Override\n    public String toString() {\n        String pattern \u003d printerParser.toString();\n        pattern \u003d pattern.startsWith(\"[\") ? pattern : pattern.substring(1, pattern.length() - 1);\n        return pattern;\n        // TODO: Fix tests to not depend on toString()\n//        return \"DateTimeFormatter[\" + locale +\n//                (chrono !\u003d null ? \",\" + chrono : \"\") +\n//                (zone !\u003d null ? \",\" + zone : \"\") +\n//                pattern + \"]\";\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements the classic Java Format API.\n     * @serial exclude\n     */\n    @SuppressWarnings(\"serial\")  // not actually serializable\n    static class ClassicFormat extends Format {\n        /** The formatter. */\n        private final DateTimeFormatter formatter;\n        /** The type to be parsed. */\n        private final TemporalQuery\u003c?\u003e parseType;\n        /** Constructor. */\n        public ClassicFormat(DateTimeFormatter formatter, TemporalQuery\u003c?\u003e parseType) {\n            this.formatter \u003d formatter;\n            this.parseType \u003d parseType;\n        }\n\n        @Override\n        public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n            Objects.requireNonNull(obj, \"obj\");\n            Objects.requireNonNull(toAppendTo, \"toAppendTo\");\n            Objects.requireNonNull(pos, \"pos\");\n            if (obj instanceof TemporalAccessor \u003d\u003d false) {\n                throw new IllegalArgumentException(\"Format target must implement TemporalAccessor\");\n            }\n            pos.setBeginIndex(0);\n            pos.setEndIndex(0);\n            try {\n                formatter.formatTo((TemporalAccessor) obj, toAppendTo);\n            } catch (RuntimeException ex) {\n                throw new IllegalArgumentException(ex.getMessage(), ex);\n            }\n            return toAppendTo;\n        }\n        @Override\n        public Object parseObject(String text) throws ParseException {\n            Objects.requireNonNull(text, \"text\");\n            try {\n                if (parseType \u003d\u003d null) {\n                    return formatter.parseResolved0(text, null);\n                }\n                return formatter.parse(text, parseType);\n            } catch (DateTimeParseException ex) {\n                throw new ParseException(ex.getMessage(), ex.getErrorIndex());\n            } catch (RuntimeException ex) {\n                throw (ParseException) new ParseException(ex.getMessage(), 0).initCause(ex);\n            }\n        }\n        @Override\n        public Object parseObject(String text, ParsePosition pos) {\n            Objects.requireNonNull(text, \"text\");\n            DateTimeParseContext context;\n            try {\n                context \u003d formatter.parseUnresolved0(text, pos);\n            } catch (IndexOutOfBoundsException ex) {\n                if (pos.getErrorIndex() \u003c 0) {\n                    pos.setErrorIndex(0);\n                }\n                return null;\n            }\n            if (context \u003d\u003d null) {\n                if (pos.getErrorIndex() \u003c 0) {\n                    pos.setErrorIndex(0);\n                }\n                return null;\n            }\n            try {\n                TemporalAccessor resolved \u003d context.toResolved(formatter.resolverStyle, formatter.resolverFields);\n                if (parseType \u003d\u003d null) {\n                    return resolved;\n                }\n                return resolved.query(parseType);\n            } catch (RuntimeException ex) {\n                pos.setErrorIndex(0);\n                return null;\n            }\n        }\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor29.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

oct 23, 2024 7:06:25 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.23 19:08:07 INFO  compiling root (1 scala source)
2024.10.23 19:08:07 INFO  time: compiled root in 0.24s
oct 23, 2024 7:09:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 12597
2024.10.23 19:09:22 INFO  compiling root (1 scala source)
2024.10.23 19:09:22 INFO  time: compiled root in 0.3s
2024.10.23 19:10:25 INFO  compiling root (1 scala source)
2024.10.23 19:10:26 INFO  time: compiled root in 1.01s
2024.10.23 19:11:02 INFO  compiling root (1 scala source)
2024.10.23 19:11:02 INFO  time: compiled root in 0.52s
2024.10.23 19:11:09 INFO  compiling root (1 scala source)
2024.10.23 19:11:09 INFO  time: compiled root in 0.53s
2024.10.23 19:11:26 INFO  compiling root (1 scala source)
2024.10.23 19:11:26 INFO  time: compiled root in 0.55s
2024.10.23 19:12:05 INFO  compiling root (1 scala source)
2024.10.23 19:12:05 INFO  time: compiled root in 0.35s
2024.10.23 19:12:14 INFO  compiling root (1 scala source)
2024.10.23 19:12:14 INFO  time: compiled root in 0.44s
2024.10.24 14:04:13 INFO  Started: Metals version 1.3.5 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.94.2.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@6e7e2174]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@161af14e]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@6e7e2174]
2024.10.24 14:04:17 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.24 14:04:18 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\MercadosDownloader.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.24 14:04:18 INFO  Attempting to connect to the build server...
2024.10.24 14:04:24 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.24 14:04:24 INFO  Attempting to connect to the build server...
2024.10.24 14:04:24 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.24 14:04:24 INFO  time: Connected to build server in 6.26s
2024.10.24 14:04:24 INFO  Connected to Build server: Bloop v1.6.0
2024.10.24 14:04:25 INFO  time: Imported build in 0.17s
2024.10.24 14:04:25 INFO  running doctor check
2024.10.24 14:04:25 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.24 14:04:32 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.24 14:04:47 INFO  time: indexed workspace in 22s
oct 24, 2024 2:55:55 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 146
2024.10.24 14:56:54 INFO  compiling root (1 scala source)
2024.10.24 14:56:57 INFO  time: compiled root in 3.32s
2024.10.24 14:59:19 INFO  compiling root (1 scala source)
2024.10.24 14:59:21 INFO  time: compiled root in 1.63s
2024.10.24 14:59:53 INFO  compiling root (1 scala source)
2024.10.24 14:59:54 INFO  time: compiled root in 1.39s
2024.10.24 15:01:46 INFO  compiling root (1 scala source)
2024.10.24 15:01:48 INFO  time: compiled root in 1.49s
oct 24, 2024 3:02:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1095
oct 24, 2024 3:04:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1584
2024.10.24 15:05:23 INFO  compiling root (1 scala source)
2024.10.24 15:05:24 INFO  time: compiled root in 1.06s
2024.10.24 15:06:52 INFO  compiling root (1 scala source)
2024.10.24 15:06:52 INFO  time: compiled root in 0.89s
oct 24, 2024 3:06:59 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 2108
2024.10.24 15:07:39 INFO  compiling root (1 scala source)
2024.10.24 15:07:39 INFO  time: compiled root in 0.84s
oct 24, 2024 3:08:31 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 2308
oct 24, 2024 3:08:44 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 2408
oct 24, 2024 3:10:58 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3188
2024.10.24 15:11:18 INFO  compiling root (1 scala source)
2024.10.24 15:11:18 INFO  time: compiled root in 0.32s
oct 24, 2024 3:20:55 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-24\r_compiler-error_(root)_15-20-55-620.md
2024.10.24 15:20:55 WARN  Could not find semantic tokens for: file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/MercadosDownloader.scala
oct 24, 2024 3:21:25 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3814
oct 24, 2024 3:23:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4083
oct 24, 2024 3:28:46 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4745
oct 24, 2024 3:30:40 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4993
oct 24, 2024 3:30:54 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5052
2024.10.24 15:32:20 WARN  Using indexes to guess the definition of Right
2024.10.24 16:47:36 INFO  compiling root (1 scala source)
2024.10.24 16:47:36 INFO  time: compiled root in 0.37s
2024.10.24 16:48:32 INFO  compiling root (1 scala source)
2024.10.24 16:48:34 INFO  time: compiled root in 1.2s
2024.10.24 16:49:31 INFO  compiling root (1 scala source)
2024.10.24 16:49:32 INFO  time: compiled root in 1.03s
2024.10.24 16:50:11 INFO  compiling root (1 scala source)
2024.10.24 16:50:11 INFO  time: compiled root in 0.24s
2024.10.24 16:53:23 INFO  compiling root (1 scala source)
2024.10.24 16:53:23 INFO  time: compiled root in 0.31s
oct 24, 2024 4:53:42 P. M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMACIÓN: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
oct 24, 2024 4:53:42 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-24\r_compiler-error_(root)_16-53-42-729.md
oct 24, 2024 4:53:42 P. M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMACIÓN: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
oct 24, 2024 4:53:43 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-24\r_compiler-error_(root)_16-53-43-208.md
2024.10.24 16:53:47 INFO  compiling root (1 scala source)
2024.10.24 16:53:47 INFO  time: compiled root in 0.27s
2024.10.24 16:54:06 INFO  compiling root (1 scala source)
2024.10.24 16:54:06 INFO  time: compiled root in 0.26s
2024.10.24 16:54:57 INFO  compiling root (1 scala source)
2024.10.24 16:54:57 INFO  time: compiled root in 0.25s
oct 24, 2024 4:54:59 P. M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMACIÓN: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.10.24 16:55:05 INFO  compiling root (1 scala source)
2024.10.24 16:55:05 INFO  time: compiled root in 0.88s
oct 24, 2024 4:58:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 7122
2024.10.24 16:58:44 INFO  compiling root (1 scala source)
2024.10.24 16:58:44 INFO  time: compiled root in 0.27s
2024.10.24 16:58:50 INFO  compiling root (1 scala source)
2024.10.24 16:58:50 INFO  time: compiled root in 0.26s
2024.10.24 17:00:36 INFO  compiling root (2 scala sources)
2024.10.24 17:00:36 INFO  time: compiled root in 0.28s
oct 24, 2024 5:00:56 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 7665
2024.10.24 17:00:59 INFO  compiling root (2 scala sources)
2024.10.24 17:00:59 INFO  time: compiled root in 0.33s
2024.10.24 17:03:14 INFO  compiling root (2 scala sources)
2024.10.24 17:03:14 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.24 17:03:14 INFO  time: compiled root in 0.94s
2024.10.24 17:03:54 INFO  compiling root (1 scala source)
2024.10.24 17:03:54 INFO  time: compiled root in 0.78s
2024.10.24 17:05:57 INFO  compiling root (1 scala source)
2024.10.24 17:05:57 INFO  time: compiled root in 1s
2024.10.24 17:07:07 INFO  compiling root (1 scala source)
2024.10.24 17:07:07 INFO  time: compiled root in 0.83s
2024.10.24 17:07:14 INFO  compiling root (1 scala source)
2024.10.24 17:07:14 INFO  time: compiled root in 0.26s
2024.10.24 17:07:17 INFO  compiling root (1 scala source)
2024.10.24 17:07:17 INFO  time: compiled root in 0.77s
2024.10.24 17:08:37 INFO  compiling root (1 scala source)
2024.10.24 17:08:37 INFO  time: compiled root in 0.87s
oct 24, 2024 5:40:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 9813
2024.10.24 17:43:44 INFO  compiling root (1 scala source)
2024.10.24 17:43:44 INFO  time: compiled root in 0.3s
oct 24, 2024 5:45:52 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 10833
Exception in thread "pool-5-thread-1" java.lang.OutOfMemoryError: Java heap space
	at java.base/java.util.Arrays.copyOf(Arrays.java:3481)
	at java.base/java.util.ArrayList.grow(ArrayList.java:237)
	at java.base/java.util.ArrayList.grow(ArrayList.java:244)
	at java.base/java.util.ArrayList.add(ArrayList.java:454)
	at java.base/java.util.ArrayList.add(ArrayList.java:467)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.pushToken$1(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.emitToken$1(ScalametaTokenizer.scala:146)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.loop$1(ScalametaTokenizer.scala:152)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:162)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$Lambda$7587/0x0000000801f14400.apply(Unknown Source)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$1.apply(ScalametaTokenizer.scala:313)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:22)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:13)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionStringDocMeta.safeTokenize(ScalametaCommonEnrichments.scala:237)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionStringDocMeta.checkIfNotInComment(ScalametaCommonEnrichments.scala:256)
	at scala.meta.internal.pc.Keywords.checkIfNotInComment(Keywords.scala:95)
	at scala.meta.internal.pc.Keywords.notInComment$lzycompute$1(Keywords.scala:21)
	at scala.meta.internal.pc.Keywords.notInComment$1(Keywords.scala:21)
	at scala.meta.internal.pc.Keywords.keywords(Keywords.scala:50)
	at scala.meta.internal.pc.Keywords.keywords$(Keywords.scala:12)
	at scala.meta.internal.pc.MetalsGlobal.keywords(MetalsGlobal.scala:36)
	at scala.meta.internal.pc.CompletionProvider.filterInteresting(CompletionProvider.scala:413)
	at scala.meta.internal.pc.CompletionProvider.safeCompletionsAt(CompletionProvider.scala:569)
	at scala.meta.internal.pc.CompletionProvider.completions(CompletionProvider.scala:59)
	at scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$complete$1(ScalaPresentationCompiler.scala:214)
	at scala.meta.internal.pc.ScalaPresentationCompiler$$Lambda$7568/0x0000000801eff108.apply(Unknown Source)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:156)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$withInterruptableCompiler$1(CompilerAccess.scala:102)
	at scala.meta.internal.pc.CompilerAccess$$Lambda$6098/0x0000000801b6b318.apply(Unknown Source)
Exception in thread "Thread-5" java.lang.OutOfMemoryError: Java heap space
Exception in thread "bsp-server-to-client" java.lang.OutOfMemoryError: Java heap space
Exception in thread "pool-1-thread-345" java.lang.OutOfMemoryError: Java heap space
2024.10.24 17:47:41 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.24 17:47:41 INFO  Connected to Build server: Bloop v1.6.0
org.h2.jdbc.JdbcSQLNonTransientConnectionException: Memoria Insuficiente - Out of memory. Tamaño: "OutOfMemoryError"
Out of memory. [90108-230]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:690)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:489)
	at org.h2.message.DbException.get(DbException.java:212)
	at org.h2.engine.Database.throwLastBackgroundException(Database.java:1816)
	at org.h2.engine.SessionLocal.beforeCommitOrRollback(SessionLocal.java:769)
	at org.h2.engine.SessionLocal.commit(SessionLocal.java:684)
	at org.h2.command.Command.stop(Command.java:162)
	at org.h2.command.Command.executeUpdate(Command.java:345)
	at org.h2.command.Command.executeUpdate(Command.java:248)
	at org.h2.jdbc.JdbcPreparedStatement.executeUpdateInternal(JdbcPreparedStatement.java:213)
	at org.h2.jdbc.JdbcPreparedStatement.executeUpdate(JdbcPreparedStatement.java:172)
	at scala.meta.internal.metals.JdbcEnrichments$XtensionConnection.update(JdbcEnrichments.scala:20)
	at scala.meta.internal.builds.Digests.setStatus(Digests.scala:18)
	at scala.meta.internal.builds.WorkspaceReload.$anonfun$persistChecksumStatus$1(WorkspaceReload.scala:42)
	at scala.meta.internal.builds.WorkspaceReload.$anonfun$persistChecksumStatus$1$adapted(WorkspaceReload.scala:41)
	at scala.Option.foreach(Option.scala:437)
	at scala.meta.internal.builds.WorkspaceReload.persistChecksumStatus(WorkspaceReload.scala:41)
	at scala.meta.internal.metals.ProjectMetalsLspService.$anonfun$connectToNewBuildServer$2(ProjectMetalsLspService.scala:986)
	at scala.meta.internal.metals.ProjectMetalsLspService.$anonfun$connectToNewBuildServer$2$adapted(ProjectMetalsLspService.scala:986)
	at scala.Option.foreach(Option.scala:437)
	at scala.meta.internal.metals.ProjectMetalsLspService.connectToNewBuildServer(ProjectMetalsLspService.scala:986)
	at scala.meta.internal.metals.ProjectMetalsLspService.$anonfun$autoConnectToBuildServer$6(ProjectMetalsLspService.scala:927)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$reconnect$3(BuildServerConnection.scala:490)
	at scala.util.Success.foreach(Try.scala:268)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:481)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: org.h2.message.DbException: OutOfMemoryError
	at org.h2.message.DbException.<clinit>(DbException.java:64)
	at org.h2.message.TraceObject.<clinit>(TraceObject.java:108)
	at org.h2.Driver.connect(Driver.java:59)
	at java.sql/java.sql.DriverManager.getConnection(DriverManager.java:681)
	at java.sql/java.sql.DriverManager.getConnection(DriverManager.java:229)
	at scala.meta.internal.metals.H2ConnectionProvider.upgradeIfNeeded(H2ConnectionProvider.scala:132)
	at scala.meta.internal.metals.H2ConnectionProvider.persistentConnection(H2ConnectionProvider.scala:108)
	at scala.meta.internal.metals.H2ConnectionProvider.tryAutoServer(H2ConnectionProvider.scala:62)
	at scala.meta.internal.metals.H2ConnectionProvider.connect(H2ConnectionProvider.scala:44)
	at scala.meta.internal.metals.H2ConnectionProvider.connection(H2ConnectionProvider.scala:34)
	at scala.meta.internal.metals.Tables.$anonfun$dependencySources$1(Tables.scala:23)
	at scala.meta.internal.metals.DependencySources.getBuildTarget(DependencySources.scala:25)
	at scala.meta.internal.metals.BuildTargets.$anonfun$inverseSources$2(BuildTargets.scala:259)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.BuildTargets.inverseSources(BuildTargets.scala:259)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$didOpen$1(MetalsLspService.scala:753)
	at java.base/java.util.concurrent.atomic.AtomicReference.getAndUpdate(AtomicReference.java:188)
	at scala.meta.internal.metals.MetalsLspService.didOpen(MetalsLspService.scala:751)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:401)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	... 3 more
Caused by: java.sql.SQLException: OutOfMemoryError
	at org.h2.message.DbException.<clinit>(DbException.java:62)
	... 35 more
Caused by: java.lang.OutOfMemoryError
	... 36 more
Exception in thread "pool-1-thread-347" Exception in thread "pool-2-thread-1" java.lang.OutOfMemoryError: Java heap space
java.lang.OutOfMemoryError: Java heap space
oct 24, 2024 5:49:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Java heap space
java.lang.OutOfMemoryError: Java heap space

2024.10.24 17:49:40 INFO  Started: Metals version 1.4.0 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.94.2.
2024.10.24 17:49:40 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.24 17:49:40 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\MercadosDownloader.scala. Using presentation compiler with project's scala-library version: 3.3.4
oct 24, 2024 5:49:43 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 2
oct 24, 2024 5:49:43 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1
2024.10.24 17:49:43 INFO  Attempting to connect to the build server...
2024.10.24 17:49:43 INFO  No running Bloop server found, starting one.
2024.10.24 17:50:02 ERROR Running process 'kill -9 23304' failed
java.io.IOException: Cannot run program "kill" (in directory "C:\Users\jalva\AppData\Local\ScalaCli\data\bloop"): CreateProcess error=2, El sistema no puede encontrar el archivo especificado
	at java.lang.ProcessBuilder.start(ProcessBuilder.java:1143)
	at java.lang.ProcessBuilder.start(ProcessBuilder.java:1073)
	at scala.meta.internal.process.SystemProcess$.run(SystemProcess.scala:48)
	at scala.meta.internal.builds.ShellRunner$.runSync(ShellRunner.scala:169)
	at scala.meta.internal.metals.BloopServers.$anonfun$checkOldBloopRunning$4(BloopServers.scala:265)
	at scala.meta.internal.metals.BloopServers.$anonfun$checkOldBloopRunning$4$adapted(BloopServers.scala:262)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)
Caused by: java.io.IOException: CreateProcess error=2, El sistema no puede encontrar el archivo especificado
	at java.lang.ProcessImpl.create(Native Method)
	at java.lang.ProcessImpl.<init>(ProcessImpl.java:494)
	at java.lang.ProcessImpl.start(ProcessImpl.java:159)
	at java.lang.ProcessBuilder.start(ProcessBuilder.java:1110)
	at java.lang.ProcessBuilder.start(ProcessBuilder.java:1073)
	at scala.meta.internal.process.SystemProcess$.run(SystemProcess.scala:48)
	at scala.meta.internal.builds.ShellRunner$.runSync(ShellRunner.scala:169)
	at scala.meta.internal.metals.BloopServers.$anonfun$checkOldBloopRunning$4(BloopServers.scala:265)
	at scala.meta.internal.metals.BloopServers.$anonfun$checkOldBloopRunning$4$adapted(BloopServers.scala:262)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.10.24 17:50:04 INFO  Starting compilation server
2024.10.24 17:50:06 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.24 17:50:06 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.24 17:50:06 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.24 17:50:06 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.10.24 17:50:09 INFO  Attempting to connect to the build server...
2024.10.24 17:50:09 INFO  Found a Bloop server running
2024.10.24 17:50:09 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.24 17:50:09 INFO  time: Connected to build server in 26s
2024.10.24 17:50:09 INFO  Connected to Build server: Bloop v2.0.3
2024.10.24 17:50:10 INFO  time: Imported build in 0.16s
2024.10.24 17:50:10 INFO  running doctor check
2024.10.24 17:50:10 INFO  java targets: spark-datos-energia-build, root-test, root
oct 24, 2024 5:50:10 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 20
2024.10.24 17:50:10 INFO  compiling root (8 scala sources)
2024.10.24 17:50:13 INFO  time: compiled root in 2.97s
2024.10.24 17:50:15 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.24 17:50:30 INFO  time: indexed workspace in 19s
2024.10.24 17:50:30 INFO  compiling root (8 scala sources)
2024.10.24 17:50:30 INFO  time: compiled root in 0.73s
2024.10.24 17:50:30 INFO  compiling root (8 scala sources)
2024.10.24 17:50:30 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 17:50:30 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\MercadosDownloader.scala
2024.10.24 17:50:30 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 17:50:30 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 17:50:30 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\MercadosDownloader.scala
2024.10.24 17:50:30 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 17:50:30 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\MercadosDownloader.scala
2024.10.24 17:50:30 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 17:50:31 INFO  time: compiled root in 0.72s
2024.10.24 17:50:31 INFO  compiling root (8 scala sources)
2024.10.24 17:50:31 INFO  time: compiled root in 0.69s
2024.10.24 17:50:32 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 17:50:34 INFO  compiling root (8 scala sources)
2024.10.24 17:50:34 INFO  time: compiled root in 0.5s
2024.10.24 17:50:35 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 17:50:39 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\MercadosDownloader.scala
2024.10.24 17:50:42 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\MercadosDownloader.scala
2024.10.24 17:50:45 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\MercadosDownloader.scala
2024.10.24 17:50:45 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\MercadosDownloader.scala
2024.10.24 17:50:46 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\MercadosDownloader.scala
2024.10.24 17:50:48 INFO  compiling root (8 scala sources)
2024.10.24 17:50:48 INFO  time: compiled root in 0.42s
2024.10.24 17:50:48 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\MercadosDownloader.scala
2024.10.24 17:50:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 17:50:58 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 17:51:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 17:51:01 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 17:51:02 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 17:51:24 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 17:51:27 INFO  compiling root (8 scala sources)
2024.10.24 17:51:30 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.24 17:51:30 INFO  time: compiled root in 2.7s
oct 24, 2024 5:52:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 571
2024.10.24 17:54:35 INFO  compiling root (1 scala source)
2024.10.24 17:54:36 INFO  time: compiled root in 1.07s
2024.10.24 17:55:08 INFO  compiling root (1 scala source)
2024.10.24 17:55:08 INFO  time: compiled root in 0.96s
2024.10.24 17:56:09 INFO  compiling root (1 scala source)
2024.10.24 17:56:09 INFO  time: compiled root in 0.94s
oct 24, 2024 5:56:43 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1236
oct 24, 2024 5:56:44 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1248
2024.10.24 17:56:52 INFO  compiling root (1 scala source)
2024.10.24 17:56:52 INFO  time: compiled root in 0.96s
2024.10.24 17:58:36 INFO  compiling root (1 scala source)
2024.10.24 17:58:36 INFO  time: compiled root in 0.91s
2024.10.24 17:58:55 INFO  compiling root (1 scala source)
2024.10.24 17:58:55 INFO  time: compiled root in 0.78s
2024.10.24 17:59:50 INFO  compiling root (1 scala source)
2024.10.24 17:59:50 INFO  time: compiled root in 0.91s
2024.10.24 18:20:48 INFO  compiling root (1 scala source)
2024.10.24 18:20:48 INFO  time: compiled root in 0.96s
2024.10.24 18:21:06 INFO  compiling root (1 scala source)
2024.10.24 18:21:06 INFO  time: compiled root in 0.24s
2024.10.24 18:21:17 INFO  time: compiled root in 17ms
2024.10.24 18:22:17 INFO  compiling root (1 scala source)
2024.10.24 18:22:17 INFO  time: compiled root in 0.91s
2024.10.24 18:22:28 INFO  compiling root (1 scala source)
2024.10.24 18:22:28 INFO  time: compiled root in 0.74s
2024.10.24 18:22:34 INFO  compiling root (1 scala source)
2024.10.24 18:22:34 INFO  time: compiled root in 0.76s
2024.10.24 18:23:29 INFO  compiling root (1 scala source)
2024.10.24 18:23:29 INFO  time: compiled root in 0.3s
2024.10.24 18:23:44 INFO  compiling root (1 scala source)
2024.10.24 18:23:44 INFO  time: compiled root in 0.25s
2024.10.24 18:25:13 INFO  compiling root (1 scala source)
2024.10.24 18:25:13 INFO  time: compiled root in 0.31s
2024.10.24 18:25:28 INFO  compiling root (1 scala source)
2024.10.24 18:25:28 INFO  time: compiled root in 0.25s
2024.10.24 18:25:40 INFO  compiling root (1 scala source)
2024.10.24 18:25:40 INFO  time: compiled root in 0.25s
2024.10.24 18:37:37 INFO  compiling root (1 scala source)
2024.10.24 18:37:37 INFO  time: compiled root in 0.39s
2024.10.24 18:37:56 INFO  compiling root (1 scala source)
2024.10.24 18:37:56 INFO  time: compiled root in 0.28s
2024.10.24 18:38:14 INFO  compiling root (1 scala source)
2024.10.24 18:38:14 INFO  time: compiled root in 0.26s
2024.10.24 18:38:18 INFO  compiling root (1 scala source)
2024.10.24 18:38:18 INFO  time: compiled root in 0.87s
2024.10.24 18:38:27 INFO  compiling root (1 scala source)
2024.10.24 18:38:27 INFO  time: compiled root in 0.79s
2024.10.24 18:40:28 INFO  compiling root (1 scala source)
2024.10.24 18:40:28 INFO  time: compiled root in 0.88s
2024.10.24 18:41:12 INFO  compiling root (1 scala source)
2024.10.24 18:41:12 INFO  time: compiled root in 0.96s
2024.10.24 18:45:28 INFO  compiling root (1 scala source)
2024.10.24 18:45:29 INFO  time: compiled root in 1s
2024.10.24 18:55:58 INFO  compiling spark-datos-energia-build (1 scala source)
2024.10.24 18:55:58 INFO  Non-compiled module 'compiler-bridge_2.12' for Scala 2.12.19. Compiling...
oct 24, 2024 6:55:58 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3604
2024.10.24 18:56:01 INFO  time: code lens generation in 2.56s
2024.10.24 18:56:11 INFO  Compilation completed in 12.883s.
2024.10.24 18:56:14 INFO  time: compiled spark-datos-energia-build in 16s
oct 24, 2024 6:57:54 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3977
2024.10.24 18:58:54 INFO  compiling root (1 scala source)
2024.10.24 18:58:54 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.24 18:58:55 INFO  time: compiled root in 1.07s
2024.10.24 18:58:55 INFO  compiling root (3 scala sources)
2024.10.24 18:58:55 INFO  time: compiled root in 0.22s
2024.10.24 19:08:11 INFO  compiling root (1 scala source)
2024.10.24 19:08:11 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.24 19:08:11 INFO  time: compiled root in 0.96s
2024.10.24 19:08:11 INFO  compiling root (3 scala sources)
2024.10.24 19:08:13 INFO  time: compiled root in 0.19s
2024.10.24 19:08:14 INFO  compiling root (1 scala source)
2024.10.24 19:08:14 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.24 19:08:14 INFO  time: compiled root in 0.95s
2024.10.24 19:08:14 INFO  compiling root (3 scala sources)
2024.10.24 19:08:15 INFO  time: compiled root in 0.18s
2024.10.24 19:09:22 INFO  compiling root (2 scala sources)
2024.10.24 19:09:23 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.24 19:09:23 INFO  time: compiled root in 1.2s
2024.10.24 19:09:23 INFO  compiling root (3 scala sources)
2024.10.24 19:09:23 INFO  time: compiled root in 0.16s
2024.10.24 19:09:29 INFO  compiling root (3 scala sources)
2024.10.24 19:09:30 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.24 19:09:30 INFO  time: compiled root in 1.09s
2024.10.24 19:09:30 INFO  compiling root (3 scala sources)
2024.10.24 19:09:30 INFO  time: compiled root in 0.14s
2024.10.24 19:09:35 INFO  compiling root (4 scala sources)
2024.10.24 19:09:36 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.24 19:09:36 INFO  time: compiled root in 1.2s
2024.10.24 19:09:44 INFO  compiling root (7 scala sources)
2024.10.24 19:09:44 INFO  time: compiled root in 0.34s
2024.10.24 19:10:03 INFO  compiling root (7 scala sources)
2024.10.24 19:10:03 INFO  time: compiled root in 0.3s
2024.10.24 19:10:03 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\DemandaDownloader.scala
oct 24, 2024 7:10:11 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
ADVERTENCIA: Error indexing C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
java.nio.file.NoSuchFileException: C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:442)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:278)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:289)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:204)
	at scala.collection.immutable.Set$Set1.foreach(Set.scala:177)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definitions(OnDemandSymbolIndex.scala:58)
	at scala.meta.internal.metals.DestinationProvider.definition(DefinitionProvider.scala:418)
	at scala.meta.internal.metals.DestinationProvider.fromSymbol(DefinitionProvider.scala:456)
	at scala.meta.internal.metals.DestinationProvider.fromSymbol(DefinitionProvider.scala:499)
	at scala.meta.internal.metals.DefinitionProvider.definitionResult$1(DefinitionProvider.scala:307)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definitionFromSnapshot$2(DefinitionProvider.scala:313)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.DefinitionProvider.definitionFromSnapshot(DefinitionProvider.scala:313)
	at scala.meta.internal.metals.DefinitionProvider.definition(DefinitionProvider.scala:90)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definitionResult$1(MetalsLspService.scala:1683)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.definitionResult(MetalsLspService.scala:1683)
	at scala.meta.internal.metals.MetalsLspService.definitionOrReferences(MetalsLspService.scala:1618)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definition$1(MetalsLspService.scala:973)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.definition(MetalsLspService.scala:972)
	at scala.meta.internal.metals.WorkspaceLspService.definition(WorkspaceLspService.scala:425)
	at scala.meta.metals.lsp.DelegatingScalaService.definition(DelegatingScalaService.scala:69)
	at jdk.internal.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 24, 2024 7:10:11 P. M. scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
ADVERTENCIA: Error indexing C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
java.nio.file.NoSuchFileException: C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:236)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:380)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:432)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3288)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:42)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:18)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:442)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:278)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:289)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:300)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:204)
	at scala.collection.immutable.Set$Set1.foreach(Set.scala:177)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:204)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:177)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:142)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:142)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definitions(OnDemandSymbolIndex.scala:58)
	at scala.meta.internal.metals.DestinationProvider.definition(DefinitionProvider.scala:418)
	at scala.meta.internal.metals.DestinationProvider.fromSymbol(DefinitionProvider.scala:456)
	at scala.meta.internal.metals.DestinationProvider.fromSymbol(DefinitionProvider.scala:499)
	at scala.meta.internal.metals.DefinitionProvider.definitionResult$1(DefinitionProvider.scala:307)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$definitionFromSnapshot$2(DefinitionProvider.scala:313)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.DefinitionProvider.definitionFromSnapshot(DefinitionProvider.scala:313)
	at scala.meta.internal.metals.DefinitionProvider.definition(DefinitionProvider.scala:90)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definitionResult$1(MetalsLspService.scala:1683)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.definitionResult(MetalsLspService.scala:1683)
	at scala.meta.internal.metals.MetalsLspService.definitionOrReferences(MetalsLspService.scala:1618)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definition$1(MetalsLspService.scala:973)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.definition(MetalsLspService.scala:972)
	at scala.meta.internal.metals.WorkspaceLspService.definition(WorkspaceLspService.scala:425)
	at scala.meta.metals.lsp.DelegatingScalaService.definition(DelegatingScalaService.scala:69)
	at jdk.internal.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.24 19:10:12 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 19:10:12 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 19:10:12 INFO  compiling root (7 scala sources)
2024.10.24 19:10:12 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 19:10:12 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 19:10:12 INFO  time: compiled root in 0.32s
2024.10.24 19:10:12 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala
2024.10.24 19:10:17 INFO  compiling root (7 scala sources)
2024.10.24 19:10:17 INFO  time: compiled root in 0.31s
2024.10.24 19:10:56 INFO  compiling root (7 scala sources)
2024.10.24 19:10:56 INFO  time: compiled root in 0.39s
2024.10.24 19:11:03 INFO  compiling root (7 scala sources)
2024.10.24 19:11:03 INFO  time: compiled root in 0.32s
oct 24, 2024 7:11:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4777
2024.10.24 19:11:24 INFO  compiling root (7 scala sources)
2024.10.24 19:11:26 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.24 19:11:26 INFO  time: compiled root in 1.3s
2024.10.24 19:12:22 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 24, 2024 7:12:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2008-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time.format;\n\nimport static java.time.temporal.ChronoField.DAY_OF_MONTH;\nimport static java.time.temporal.ChronoField.DAY_OF_WEEK;\nimport static java.time.temporal.ChronoField.DAY_OF_YEAR;\nimport static java.time.temporal.ChronoField.HOUR_OF_DAY;\nimport static java.time.temporal.ChronoField.MINUTE_OF_HOUR;\nimport static java.time.temporal.ChronoField.MONTH_OF_YEAR;\nimport static java.time.temporal.ChronoField.NANO_OF_SECOND;\nimport static java.time.temporal.ChronoField.SECOND_OF_MINUTE;\nimport static java.time.temporal.ChronoField.YEAR;\n\nimport java.io.IOException;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.time.DateTimeException;\nimport java.time.Period;\nimport java.time.ZoneId;\nimport java.time.ZoneOffset;\nimport java.time.chrono.ChronoLocalDateTime;\nimport java.time.chrono.Chronology;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatterBuilder.CompositePrinterParser;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.IsoFields;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQuery;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport sun.util.locale.provider.TimeZoneNameUtility;\n\n/**\n * Formatter for printing and parsing date-time objects.\n * \u003cp\u003e\n * This class provides the main application entry point for printing and parsing\n * and provides common implementations of {@code DateTimeFormatter}:\n * \u003cul\u003e\n * \u003cli\u003eUsing predefined constants, such as {@link #ISO_LOCAL_DATE}\u003c/li\u003e\n * \u003cli\u003eUsing pattern letters, such as {@code uuuu-MMM-dd}\u003c/li\u003e\n * \u003cli\u003eUsing localized styles, such as {@code long} or {@code medium}\u003c/li\u003e\n * \u003c/ul\u003e\n * \u003cp\u003e\n * More complex formatters are provided by\n * {@link DateTimeFormatterBuilder DateTimeFormatterBuilder}.\n *\n * \u003cp\u003e\n * The main date-time classes provide two methods - one for formatting,\n * {@code format(DateTimeFormatter formatter)}, and one for parsing,\n * {@code parse(CharSequence text, DateTimeFormatter formatter)}.\n * \u003cp\u003eFor example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *  LocalDate date \u003d LocalDate.now();\n *  String text \u003d date.format(formatter);\n *  LocalDate parsedDate \u003d LocalDate.parse(text, formatter);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * In addition to the format, formatters can be created with desired Locale,\n * Chronology, ZoneId, and DecimalStyle.\n * \u003cp\u003e\n * The {@link #withLocale withLocale} method returns a new formatter that\n * overrides the locale. The locale affects some aspects of formatting and\n * parsing. For example, the {@link #ofLocalizedDate ofLocalizedDate} provides a\n * formatter that uses the locale specific date format.\n * \u003cp\u003e\n * The {@link #withChronology withChronology} method returns a new formatter\n * that overrides the chronology. If overridden, the date-time value is\n * converted to the chronology before formatting. During parsing the date-time\n * value is converted to the chronology before it is returned.\n * \u003cp\u003e\n * The {@link #withZone withZone} method returns a new formatter that overrides\n * the zone. If overridden, the date-time value is converted to a ZonedDateTime\n * with the requested ZoneId before formatting. During parsing the ZoneId is\n * applied before the value is returned.\n * \u003cp\u003e\n * The {@link #withDecimalStyle withDecimalStyle} method returns a new formatter that\n * overrides the {@link DecimalStyle}. The DecimalStyle symbols are used for\n * formatting and parsing.\n * \u003cp\u003e\n * Some applications may need to use the older {@link Format java.text.Format}\n * class for formatting. The {@link #toFormat()} method returns an\n * implementation of {@code java.text.Format}.\n *\n * \u003ch3 id\u003d\"predefined\"\u003ePredefined Formatters\u003c/h3\u003e\n * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n * \u003ccaption\u003ePredefined Formatters\u003c/caption\u003e\n * \u003cthead\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"col\"\u003eFormatter\u003c/th\u003e\n * \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n * \u003cth scope\u003d\"col\"\u003eExample\u003c/th\u003e\n * \u003c/tr\u003e\n * \u003c/thead\u003e\n * \u003ctbody\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e{@link #ofLocalizedDate ofLocalizedDate(dateStyle)} \u003c/th\u003e\n * \u003ctd\u003e Formatter with date style from the locale \u003c/td\u003e\n * \u003ctd\u003e \u00272011-12-03\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ofLocalizedTime ofLocalizedTime(timeStyle)} \u003c/th\u003e\n * \u003ctd\u003e Formatter with time style from the locale \u003c/td\u003e\n * \u003ctd\u003e \u002710:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ofLocalizedDateTime ofLocalizedDateTime(dateTimeStyle)} \u003c/th\u003e\n * \u003ctd\u003e Formatter with a style for date and time from the locale\u003c/td\u003e\n * \u003ctd\u003e \u00273 Jun 2008 11:05:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ofLocalizedDateTime ofLocalizedDateTime(dateStyle,timeStyle)}\n * \u003c/th\u003e\n * \u003ctd\u003e Formatter with date and time styles from the locale \u003c/td\u003e\n * \u003ctd\u003e \u00273 Jun 2008 11:05\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #BASIC_ISO_DATE}\u003c/th\u003e\n * \u003ctd\u003eBasic ISO date \u003c/td\u003e \u003ctd\u003e\u002720111203\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_LOCAL_DATE}\u003c/th\u003e\n * \u003ctd\u003e ISO Local Date \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_OFFSET_DATE}\u003c/th\u003e\n * \u003ctd\u003e ISO Date with offset \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03+01:00\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_DATE}\u003c/th\u003e\n * \u003ctd\u003e ISO Date with or without offset \u003c/td\u003e\n * \u003ctd\u003e \u00272011-12-03+01:00\u0027; \u00272011-12-03\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_LOCAL_TIME}\u003c/th\u003e\n * \u003ctd\u003e Time without offset \u003c/td\u003e\n * \u003ctd\u003e\u002710:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_OFFSET_TIME}\u003c/th\u003e\n * \u003ctd\u003e Time with offset \u003c/td\u003e\n * \u003ctd\u003e\u002710:15:30+01:00\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_TIME}\u003c/th\u003e\n * \u003ctd\u003e Time with or without offset \u003c/td\u003e\n * \u003ctd\u003e\u002710:15:30+01:00\u0027; \u002710:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_LOCAL_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e ISO Local Date and Time \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_OFFSET_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e Date Time with Offset\n * \u003c/td\u003e\u003ctd\u003e\u00272011-12-03T10:15:30+01:00\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_ZONED_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e Zoned Date Time \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e Date and time with ZoneId \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_ORDINAL_DATE}\u003c/th\u003e\n * \u003ctd\u003e Year and day of year \u003c/td\u003e\n * \u003ctd\u003e\u00272012-337\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_WEEK_DATE}\u003c/th\u003e\n * \u003ctd\u003e Year and Week \u003c/td\u003e\n * \u003ctd\u003e\u00272012-W48-6\u0027\u003c/td\u003e\u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_INSTANT}\u003c/th\u003e\n * \u003ctd\u003e Date and Time of an Instant \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30Z\u0027 \u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #RFC_1123_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e RFC 1123 / RFC 822 \u003c/td\u003e\n * \u003ctd\u003e\u0027Tue, 3 Jun 2008 11:05:30 GMT\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003c/tbody\u003e\n * \u003c/table\u003e\n *\n * \u003ch3 id\u003d\"patterns\"\u003ePatterns for Formatting and Parsing\u003c/h3\u003e\n * Patterns are based on a simple sequence of letters and symbols.\n * A pattern is used to create a Formatter using the\n * {@link #ofPattern(String)} and {@link #ofPattern(String, Locale)} methods.\n * For example,\n * {@code \"d MMM uuuu\"} will format 2011-12-03 as \u00273\u0026nbsp;Dec\u0026nbsp;2011\u0027.\n * A formatter created from a pattern can be used as many times as necessary,\n * it is immutable and is thread-safe.\n * \u003cp\u003e\n * For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *  LocalDate date \u003d LocalDate.now();\n *  DateTimeFormatter formatter \u003d DateTimeFormatter.ofPattern(\"yyyy MM dd\");\n *  String text \u003d date.format(formatter);\n *  LocalDate parsedDate \u003d LocalDate.parse(text, formatter);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * All letters \u0027A\u0027 to \u0027Z\u0027 and \u0027a\u0027 to \u0027z\u0027 are reserved as pattern letters. The\n * following pattern letters are defined:\n * \u003ctable class\u003d\"striped\"\u003e\n * \u003ccaption\u003ePattern Letters and Symbols\u003c/caption\u003e\n * \u003cthead\u003e\n *  \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSymbol\u003c/th\u003e   \u003cth scope\u003d\"col\"\u003eMeaning\u003c/th\u003e         \u003cth scope\u003d\"col\"\u003ePresentation\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eExamples\u003c/th\u003e\n * \u003c/thead\u003e\n * \u003ctbody\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eG\u003c/th\u003e       \u003ctd\u003eera\u003c/td\u003e                         \u003ctd\u003etext\u003c/td\u003e              \u003ctd\u003eAD; Anno Domini; A\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eu\u003c/th\u003e       \u003ctd\u003eyear\u003c/td\u003e                        \u003ctd\u003eyear\u003c/td\u003e              \u003ctd\u003e2004; 04\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ey\u003c/th\u003e       \u003ctd\u003eyear-of-era\u003c/td\u003e                 \u003ctd\u003eyear\u003c/td\u003e              \u003ctd\u003e2004; 04\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eD\u003c/th\u003e       \u003ctd\u003eday-of-year\u003c/td\u003e                 \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e189\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eM/L\u003c/th\u003e     \u003ctd\u003emonth-of-year\u003c/td\u003e               \u003ctd\u003enumber/text\u003c/td\u003e       \u003ctd\u003e7; 07; Jul; July; J\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ed\u003c/th\u003e       \u003ctd\u003eday-of-month\u003c/td\u003e                \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e10\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eg\u003c/th\u003e       \u003ctd\u003emodified-julian-day\u003c/td\u003e         \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e2451334\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eQ/q\u003c/th\u003e     \u003ctd\u003equarter-of-year\u003c/td\u003e             \u003ctd\u003enumber/text\u003c/td\u003e       \u003ctd\u003e3; 03; Q3; 3rd quarter\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eY\u003c/th\u003e       \u003ctd\u003eweek-based-year\u003c/td\u003e             \u003ctd\u003eyear\u003c/td\u003e              \u003ctd\u003e1996; 96\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ew\u003c/th\u003e       \u003ctd\u003eweek-of-week-based-year\u003c/td\u003e     \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e27\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eW\u003c/th\u003e       \u003ctd\u003eweek-of-month\u003c/td\u003e               \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e4\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eE\u003c/th\u003e       \u003ctd\u003eday-of-week\u003c/td\u003e                 \u003ctd\u003etext\u003c/td\u003e              \u003ctd\u003eTue; Tuesday; T\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ee/c\u003c/th\u003e     \u003ctd\u003elocalized day-of-week\u003c/td\u003e       \u003ctd\u003enumber/text\u003c/td\u003e       \u003ctd\u003e2; 02; Tue; Tuesday; T\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eF\u003c/th\u003e       \u003ctd\u003eday-of-week-in-month\u003c/td\u003e        \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e3\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ea\u003c/th\u003e       \u003ctd\u003eam-pm-of-day\u003c/td\u003e                \u003ctd\u003etext\u003c/td\u003e              \u003ctd\u003ePM\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eh\u003c/th\u003e       \u003ctd\u003eclock-hour-of-am-pm (1-12)\u003c/td\u003e  \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e12\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eK\u003c/th\u003e       \u003ctd\u003ehour-of-am-pm (0-11)\u003c/td\u003e        \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e0\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ek\u003c/th\u003e       \u003ctd\u003eclock-hour-of-day (1-24)\u003c/td\u003e    \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e24\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eH\u003c/th\u003e       \u003ctd\u003ehour-of-day (0-23)\u003c/td\u003e          \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e0\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003em\u003c/th\u003e       \u003ctd\u003eminute-of-hour\u003c/td\u003e              \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e30\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003es\u003c/th\u003e       \u003ctd\u003esecond-of-minute\u003c/td\u003e            \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e55\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eS\u003c/th\u003e       \u003ctd\u003efraction-of-second\u003c/td\u003e          \u003ctd\u003efraction\u003c/td\u003e          \u003ctd\u003e978\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eA\u003c/th\u003e       \u003ctd\u003emilli-of-day\u003c/td\u003e                \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e1234\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003en\u003c/th\u003e       \u003ctd\u003enano-of-second\u003c/td\u003e              \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e987654321\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eN\u003c/th\u003e       \u003ctd\u003enano-of-day\u003c/td\u003e                 \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e1234000000\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eV\u003c/th\u003e       \u003ctd\u003etime-zone ID\u003c/td\u003e                \u003ctd\u003ezone-id\u003c/td\u003e           \u003ctd\u003eAmerica/Los_Angeles; Z; -08:30\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ev\u003c/th\u003e       \u003ctd\u003egeneric time-zone name\u003c/td\u003e      \u003ctd\u003ezone-name\u003c/td\u003e         \u003ctd\u003ePacific Time; PT\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ez\u003c/th\u003e       \u003ctd\u003etime-zone name\u003c/td\u003e              \u003ctd\u003ezone-name\u003c/td\u003e         \u003ctd\u003ePacific Standard Time; PST\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eO\u003c/th\u003e       \u003ctd\u003elocalized zone-offset\u003c/td\u003e       \u003ctd\u003eoffset-O\u003c/td\u003e          \u003ctd\u003eGMT+8; GMT+08:00; UTC-08:00\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eX\u003c/th\u003e       \u003ctd\u003ezone-offset \u0027Z\u0027 for zero\u003c/td\u003e    \u003ctd\u003eoffset-X\u003c/td\u003e          \u003ctd\u003eZ; -08; -0830; -08:30; -083015; -08:30:15\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ex\u003c/th\u003e       \u003ctd\u003ezone-offset\u003c/td\u003e                 \u003ctd\u003eoffset-x\u003c/td\u003e          \u003ctd\u003e+0000; -08; -0830; -08:30; -083015; -08:30:15\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eZ\u003c/th\u003e       \u003ctd\u003ezone-offset\u003c/td\u003e                 \u003ctd\u003eoffset-Z\u003c/td\u003e          \u003ctd\u003e+0000; -0800; -08:00\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ep\u003c/th\u003e       \u003ctd\u003epad next\u003c/td\u003e                    \u003ctd\u003epad modifier\u003c/td\u003e      \u003ctd\u003e1\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e\u0027\u003c/th\u003e       \u003ctd\u003eescape for text\u003c/td\u003e             \u003ctd\u003edelimiter\u003c/td\u003e         \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e\u0027\u0027\u003c/th\u003e      \u003ctd\u003esingle quote\u003c/td\u003e                \u003ctd\u003eliteral\u003c/td\u003e           \u003ctd\u003e\u0027\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e[\u003c/th\u003e       \u003ctd\u003eoptional section start\u003c/td\u003e      \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e]\u003c/th\u003e       \u003ctd\u003eoptional section end\u003c/td\u003e        \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e#\u003c/th\u003e       \u003ctd\u003ereserved for future use\u003c/td\u003e     \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{\u003c/th\u003e       \u003ctd\u003ereserved for future use\u003c/td\u003e     \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e}\u003c/th\u003e       \u003ctd\u003ereserved for future use\u003c/td\u003e     \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n * \u003c/tbody\u003e\n * \u003c/table\u003e\n * \u003cp\u003e\n * The count of pattern letters determines the format.\n * \u003cp\u003e\n * \u003cb\u003eText\u003c/b\u003e: The text style is determined based on the number of pattern\n * letters used. Less than 4 pattern letters will use the\n * {@link TextStyle#SHORT short form}. Exactly 4 pattern letters will use the\n * {@link TextStyle#FULL full form}. Exactly 5 pattern letters will use the\n * {@link TextStyle#NARROW narrow form}.\n * Pattern letters \u0027L\u0027, \u0027c\u0027, and \u0027q\u0027 specify the stand-alone form of the text styles.\n * \u003cp\u003e\n * \u003cb\u003eNumber\u003c/b\u003e: If the count of letters is one, then the value is output using\n * the minimum number of digits and without padding. Otherwise, the count of digits\n * is used as the width of the output field, with the value zero-padded as necessary.\n * The following pattern letters have constraints on the count of letters.\n * Only one letter of \u0027c\u0027 and \u0027F\u0027 can be specified.\n * Up to two letters of \u0027d\u0027, \u0027H\u0027, \u0027h\u0027, \u0027K\u0027, \u0027k\u0027, \u0027m\u0027, and \u0027s\u0027 can be specified.\n * Up to three letters of \u0027D\u0027 can be specified.\n * \u003cp\u003e\n * \u003cb\u003eNumber/Text\u003c/b\u003e: If the count of pattern letters is 3 or greater, use the\n * Text rules above. Otherwise use the Number rules above.\n * \u003cp\u003e\n * \u003cb\u003eFraction\u003c/b\u003e: Outputs the nano-of-second field as a fraction-of-second.\n * The nano-of-second value has nine digits, thus the count of pattern letters\n * is from 1 to 9. If it is less than 9, then the nano-of-second value is\n * truncated, with only the most significant digits being output.\n * \u003cp\u003e\n * \u003cb\u003eYear\u003c/b\u003e: The count of letters determines the minimum field width below\n * which padding is used. If the count of letters is two, then a\n * {@link DateTimeFormatterBuilder#appendValueReduced reduced} two digit form is\n * used. For printing, this outputs the rightmost two digits. For parsing, this\n * will parse using the base value of 2000, resulting in a year within the range\n * 2000 to 2099 inclusive. If the count of letters is less than four (but not\n * two), then the sign is only output for negative years as per\n * {@link SignStyle#NORMAL}. Otherwise, the sign is output if the pad width is\n * exceeded, as per {@link SignStyle#EXCEEDS_PAD}.\n * \u003cp\u003e\n * \u003cb\u003eZoneId\u003c/b\u003e: This outputs the time-zone ID, such as \u0027Europe/Paris\u0027. If the\n * count of letters is two, then the time-zone ID is output. Any other count of\n * letters throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eZone names\u003c/b\u003e: This outputs the display name of the time-zone ID. If the\n * pattern letter is \u0027z\u0027 the output is the daylight savings aware zone name.\n * If there is insufficient information to determine whether DST applies,\n * the name ignoring daylight savings time will be used.\n * If the count of letters is one, two or three, then the short name is output.\n * If the count of letters is four, then the full name is output.\n * Five or more letters throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * If the pattern letter is \u0027v\u0027 the output provides the zone name ignoring\n * daylight savings time. If the count of letters is one, then the short name is output.\n * If the count of letters is four, then the full name is output.\n * Two, three and five or more letters throw {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eOffset X and x\u003c/b\u003e: This formats the offset based on the number of pattern\n * letters. One letter outputs just the hour, such as \u0027+01\u0027, unless the minute\n * is non-zero in which case the minute is also output, such as \u0027+0130\u0027. Two\n * letters outputs the hour and minute, without a colon, such as \u0027+0130\u0027. Three\n * letters outputs the hour and minute, with a colon, such as \u0027+01:30\u0027. Four\n * letters outputs the hour and minute and optional second, without a colon,\n * such as \u0027+013015\u0027. Five letters outputs the hour and minute and optional\n * second, with a colon, such as \u0027+01:30:15\u0027. Six or more letters throws\n * {@code IllegalArgumentException}. Pattern letter \u0027X\u0027 (upper case) will output\n * \u0027Z\u0027 when the offset to be output would be zero, whereas pattern letter \u0027x\u0027\n * (lower case) will output \u0027+00\u0027, \u0027+0000\u0027, or \u0027+00:00\u0027.\n * \u003cp\u003e\n * \u003cb\u003eOffset O\u003c/b\u003e: This formats the localized offset based on the number of\n * pattern letters. One letter outputs the {@linkplain TextStyle#SHORT short}\n * form of the localized offset, which is localized offset text, such as \u0027GMT\u0027,\n * with hour without leading zero, optional 2-digit minute and second if\n * non-zero, and colon, for example \u0027GMT+8\u0027. Four letters outputs the\n * {@linkplain TextStyle#FULL full} form, which is localized offset text,\n * such as \u0027GMT, with 2-digit hour and minute field, optional second field\n * if non-zero, and colon, for example \u0027GMT+08:00\u0027. Any other count of letters\n * throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eOffset Z\u003c/b\u003e: This formats the offset based on the number of pattern\n * letters. One, two or three letters outputs the hour and minute, without a\n * colon, such as \u0027+0130\u0027. The output will be \u0027+0000\u0027 when the offset is zero.\n * Four letters outputs the {@linkplain TextStyle#FULL full} form of localized\n * offset, equivalent to four letters of Offset-O. The output will be the\n * corresponding localized offset text if the offset is zero. Five\n * letters outputs the hour, minute, with optional second if non-zero, with\n * colon. It outputs \u0027Z\u0027 if the offset is zero.\n * Six or more letters throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eOptional section\u003c/b\u003e: The optional section markers work exactly like\n * calling {@link DateTimeFormatterBuilder#optionalStart()} and\n * {@link DateTimeFormatterBuilder#optionalEnd()}.\n * \u003cp\u003e\n * \u003cb\u003ePad modifier\u003c/b\u003e: Modifies the pattern that immediately follows to be\n * padded with spaces. The pad width is determined by the number of pattern\n * letters. This is the same as calling\n * {@link DateTimeFormatterBuilder#padNext(int)}.\n * \u003cp\u003e\n * For example, \u0027ppH\u0027 outputs the hour-of-day padded on the left with spaces to\n * a width of 2.\n * \u003cp\u003e\n * Any unrecognized letter is an error. Any non-letter character, other than\n * \u0027[\u0027, \u0027]\u0027, \u0027{\u0027, \u0027}\u0027, \u0027#\u0027 and the single quote will be output directly.\n * Despite this, it is recommended to use single quotes around all characters\n * that you want to output directly to ensure that future changes do not break\n * your application.\n *\n * \u003ch3 id\u003d\"resolving\"\u003eResolving\u003c/h3\u003e\n * Parsing is implemented as a two-phase operation.\n * First, the text is parsed using the layout defined by the formatter, producing\n * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.\n * Second, the parsed data is \u003cem\u003eresolved\u003c/em\u003e, by validating, combining and\n * simplifying the various fields into more useful ones.\n * \u003cp\u003e\n * Five parsing methods are supplied by this class.\n * Four of these perform both the parse and resolve phases.\n * The fifth method, {@link #parseUnresolved(CharSequence, ParsePosition)},\n * only performs the first phase, leaving the result unresolved.\n * As such, it is essentially a low-level operation.\n * \u003cp\u003e\n * The resolve phase is controlled by two parameters, set on this class.\n * \u003cp\u003e\n * The {@link ResolverStyle} is an enum that offers three different approaches,\n * strict, smart and lenient. The smart option is the default.\n * It can be set using {@link #withResolverStyle(ResolverStyle)}.\n * \u003cp\u003e\n * The {@link #withResolverFields(TemporalField...)} parameter allows the\n * set of fields that will be resolved to be filtered before resolving starts.\n * For example, if the formatter has parsed a year, month, day-of-month\n * and day-of-year, then there are two approaches to resolve a date:\n * (year + month + day-of-month) and (year + day-of-year).\n * The resolver fields allows one of the two approaches to be selected.\n * If no resolver fields are set then both approaches must result in the same date.\n * \u003cp\u003e\n * Resolving separate fields to form a complete date and time is a complex\n * process with behaviour distributed across a number of classes.\n * It follows these steps:\n * \u003col\u003e\n * \u003cli\u003eThe chronology is determined.\n * The chronology of the result is either the chronology that was parsed,\n * or if no chronology was parsed, it is the chronology set on this class,\n * or if that is null, it is {@code IsoChronology}.\n * \u003cli\u003eThe {@code ChronoField} date fields are resolved.\n * This is achieved using {@link Chronology#resolveDate(Map, ResolverStyle)}.\n * Documentation about field resolution is located in the implementation\n * of {@code Chronology}.\n * \u003cli\u003eThe {@code ChronoField} time fields are resolved.\n * This is documented on {@link ChronoField} and is the same for all chronologies.\n * \u003cli\u003eAny fields that are not {@code ChronoField} are processed.\n * This is achieved using {@link TemporalField#resolve(Map, TemporalAccessor, ResolverStyle)}.\n * Documentation about field resolution is located in the implementation\n * of {@code TemporalField}.\n * \u003cli\u003eThe {@code ChronoField} date and time fields are re-resolved.\n * This allows fields in step four to produce {@code ChronoField} values\n * and have them be processed into dates and times.\n * \u003cli\u003eA {@code LocalTime} is formed if there is at least an hour-of-day available.\n * This involves providing default values for minute, second and fraction of second.\n * \u003cli\u003eAny remaining unresolved fields are cross-checked against any\n * date and/or time that was resolved. Thus, an earlier stage would resolve\n * (year + month + day-of-month) to a date, and this stage would check that\n * day-of-week was valid for the date.\n * \u003cli\u003eIf an {@linkplain #parsedExcessDays() excess number of days}\n * was parsed then it is added to the date if a date is available.\n * \u003cli\u003e If a second-based field is present, but {@code LocalTime} was not parsed,\n * then the resolver ensures that milli, micro and nano second values are\n * available to meet the contract of {@link ChronoField}.\n * These will be set to zero if missing.\n * \u003cli\u003eIf both date and time were parsed and either an offset or zone is present,\n * the field {@link ChronoField#INSTANT_SECONDS} is created.\n * If an offset was parsed then the offset will be combined with the\n * {@code LocalDateTime} to form the instant, with any zone ignored.\n * If a {@code ZoneId} was parsed without an offset then the zone will be\n * combined with the {@code LocalDateTime} to form the instant using the rules\n * of {@link ChronoLocalDateTime#atZone(ZoneId)}.\n * \u003c/ol\u003e\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class DateTimeFormatter {\n\n    /**\n     * The printer and/or parser to use, not null.\n     */\n    private final CompositePrinterParser printerParser;\n    /**\n     * The locale to use for formatting, not null.\n     */\n    private final Locale locale;\n    /**\n     * The symbols to use for formatting, not null.\n     */\n    private final DecimalStyle decimalStyle;\n    /**\n     * The resolver style to use, not null.\n     */\n    private final ResolverStyle resolverStyle;\n    /**\n     * The fields to use in resolving, null for all fields.\n     */\n    private final Set\u003cTemporalField\u003e resolverFields;\n    /**\n     * The chronology to use for formatting, null for no override.\n     */\n    private final Chronology chrono;\n    /**\n     * The zone to use for formatting, null for no override.\n     */\n    private final ZoneId zone;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a formatter using the specified pattern.\n     * \u003cp\u003e\n     * This method will create a formatter based on a simple\n     * \u003ca href\u003d\"#patterns\"\u003epattern of letters and symbols\u003c/a\u003e\n     * as described in the class documentation.\n     * For example, {@code d MMM uuuu} will format 2011-12-03 as \u00273 Dec 2011\u0027.\n     * \u003cp\u003e\n     * The formatter will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * This can be changed using {@link DateTimeFormatter#withLocale(Locale)} on the returned formatter.\n     * Alternatively use the {@link #ofPattern(String, Locale)} variant of this method.\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses {@link ResolverStyle#SMART SMART} resolver style.\n     *\n     * @param pattern  the pattern to use, not null\n     * @return the formatter based on the pattern, not null\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormatterBuilder#appendPattern(String)\n     */\n    public static DateTimeFormatter ofPattern(String pattern) {\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n    }\n\n    /**\n     * Creates a formatter using the specified pattern and locale.\n     * \u003cp\u003e\n     * This method will create a formatter based on a simple\n     * \u003ca href\u003d\"#patterns\"\u003epattern of letters and symbols\u003c/a\u003e\n     * as described in the class documentation.\n     * For example, {@code d MMM uuuu} will format 2011-12-03 as \u00273 Dec 2011\u0027.\n     * \u003cp\u003e\n     * The formatter will use the specified locale.\n     * This can be changed using {@link DateTimeFormatter#withLocale(Locale)} on the returned formatter.\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses {@link ResolverStyle#SMART SMART} resolver style.\n     *\n     * @param pattern  the pattern to use, not null\n     * @param locale  the locale to use, not null\n     * @return the formatter based on the pattern, not null\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormatterBuilder#appendPattern(String)\n     */\n    public static DateTimeFormatter ofPattern(String pattern, Locale locale) {\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter(locale);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a locale specific date format for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a date.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     *\n     * @param dateStyle  the formatter style to obtain, not null\n     * @return the date formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedDate(FormatStyle dateStyle) {\n        Objects.requireNonNull(dateStyle, \"dateStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(dateStyle, null)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    /**\n     * Returns a locale specific time format for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a time.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     * The {@code FULL} and {@code LONG} styles typically require a time-zone.\n     * When formatting using these styles, a {@code ZoneId} must be available,\n     * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.\n     *\n     * @param timeStyle  the formatter style to obtain, not null\n     * @return the time formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedTime(FormatStyle timeStyle) {\n        Objects.requireNonNull(timeStyle, \"timeStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(null, timeStyle)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    /**\n     * Returns a locale specific date-time formatter for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a date-time.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     * The {@code FULL} and {@code LONG} styles typically require a time-zone.\n     * When formatting using these styles, a {@code ZoneId} must be available,\n     * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.\n     *\n     * @param dateTimeStyle  the formatter style to obtain, not null\n     * @return the date-time formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateTimeStyle) {\n        Objects.requireNonNull(dateTimeStyle, \"dateTimeStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(dateTimeStyle, dateTimeStyle)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    /**\n     * Returns a locale specific date and time format for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a date-time.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault() default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     * The {@code FULL} and {@code LONG} styles typically require a time-zone.\n     * When formatting using these styles, a {@code ZoneId} must be available,\n     * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.\n     *\n     * @param dateStyle  the date formatter style to obtain, not null\n     * @param timeStyle  the time formatter style to obtain, not null\n     * @return the date, time or date-time formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateStyle, FormatStyle timeStyle) {\n        Objects.requireNonNull(dateStyle, \"dateStyle\");\n        Objects.requireNonNull(timeStyle, \"timeStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(dateStyle, timeStyle)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date without an\n     * offset, such as \u00272011-12-03\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended local date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits or more for the {@link ChronoField#YEAR year}.\n     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.\n     * Years outside that range will have a prefixed positive or negative symbol.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MONTH_OF_YEAR month-of-year}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eTwo digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_LOCAL_DATE;\n    static {\n        ISO_LOCAL_DATE \u003d new DateTimeFormatterBuilder()\n                .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(MONTH_OF_YEAR, 2)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(DAY_OF_MONTH, 2)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date with an\n     * offset, such as \u00272011-12-03+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE}\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_OFFSET_DATE;\n    static {\n        ISO_OFFSET_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE)\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date with the\n     * offset if available, such as \u00272011-12-03\u0027 or \u00272011-12-03+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE}\n     * \u003cli\u003eIf the offset is not available then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_DATE;\n    static {\n        ISO_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO time formatter that formats or parses a time without an\n     * offset, such as \u002710:15\u0027 or \u002710:15:30\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended local time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eTwo digits for the {@link ChronoField#HOUR_OF_DAY hour-of-day}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MINUTE_OF_HOUR minute-of-hour}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the second-of-minute is not available then the format is complete.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#SECOND_OF_MINUTE second-of-minute}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the nano-of-second is zero or not available then the format is complete.\n     * \u003cli\u003eA decimal point\n     * \u003cli\u003eOne to nine digits for the {@link ChronoField#NANO_OF_SECOND nano-of-second}.\n     *  As many digits will be output as required.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_LOCAL_TIME;\n    static {\n        ISO_LOCAL_TIME \u003d new DateTimeFormatterBuilder()\n                .appendValue(HOUR_OF_DAY, 2)\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(MINUTE_OF_HOUR, 2)\n                .optionalStart()\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(SECOND_OF_MINUTE, 2)\n                .optionalStart()\n                .appendFraction(NANO_OF_SECOND, 0, 9, true)\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO time formatter that formats or parses a time with an\n     * offset, such as \u002710:15+01:00\u0027 or \u002710:15:30+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_TIME}\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_OFFSET_TIME;\n    static {\n        ISO_OFFSET_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_TIME)\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO time formatter that formats or parses a time, with the\n     * offset if available, such as \u002710:15\u0027, \u002710:15:30\u0027 or \u002710:15:30+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_TIME}\n     * \u003cli\u003eIf the offset is not available then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_TIME;\n    static {\n        ISO_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_TIME)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date-time formatter that formats or parses a date-time without\n     * an offset, such as \u00272011-12-03T10:15:30\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset date-time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE}\n     * \u003cli\u003eThe letter \u0027T\u0027. Parsing is case insensitive.\n     * \u003cli\u003eThe {@link #ISO_LOCAL_TIME}\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_LOCAL_DATE_TIME;\n    static {\n        ISO_LOCAL_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE)\n                .appendLiteral(\u0027T\u0027)\n                .append(ISO_LOCAL_TIME)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date-time formatter that formats or parses a date-time with an\n     * offset, such as \u00272011-12-03T10:15:30+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset date-time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE_TIME}\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  The offset parsing is lenient, which allows the minutes and seconds to be optional.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_OFFSET_DATE_TIME;\n    static {\n        ISO_OFFSET_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE_TIME)\n                .parseLenient()\n                .appendOffsetId()\n                .parseStrict()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO-like date-time formatter that formats or parses a date-time with\n     * offset and zone, such as \u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * a format that extends the ISO-8601 extended offset date-time format\n     * to add the time-zone.\n     * The section in square brackets is not part of the ISO-8601 standard.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_OFFSET_DATE_TIME}\n     * \u003cli\u003eIf the zone ID is not available or is a {@code ZoneOffset} then the format is complete.\n     * \u003cli\u003eAn open square bracket \u0027[\u0027.\n     * \u003cli\u003eThe {@link ZoneId#getId() zone ID}. This is not part of the ISO-8601 standard.\n     *  Parsing is case sensitive.\n     * \u003cli\u003eA close square bracket \u0027]\u0027.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_ZONED_DATE_TIME;\n    static {\n        ISO_ZONED_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .append(ISO_OFFSET_DATE_TIME)\n                .optionalStart()\n                .appendLiteral(\u0027[\u0027)\n                .parseCaseSensitive()\n                .appendZoneRegionId()\n                .appendLiteral(\u0027]\u0027)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO-like date-time formatter that formats or parses a date-time with\n     * the offset and zone if available, such as \u00272011-12-03T10:15:30\u0027,\n     * \u00272011-12-03T10:15:30+01:00\u0027 or \u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended local or offset date-time format, as well as the\n     * extended non-ISO form specifying the time-zone.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE_TIME}\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     * \u003cli\u003eIf the zone ID is not available or is a {@code ZoneOffset} then the format is complete.\n     * \u003cli\u003eAn open square bracket \u0027[\u0027.\n     * \u003cli\u003eThe {@link ZoneId#getId() zone ID}. This is not part of the ISO-8601 standard.\n     *  Parsing is case sensitive.\n     * \u003cli\u003eA close square bracket \u0027]\u0027.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_DATE_TIME;\n    static {\n        ISO_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .append(ISO_LOCAL_DATE_TIME)\n                .optionalStart()\n                .appendOffsetId()\n                .optionalStart()\n                .appendLiteral(\u0027[\u0027)\n                .parseCaseSensitive()\n                .appendZoneRegionId()\n                .appendLiteral(\u0027]\u0027)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses the ordinal date\n     * without an offset, such as \u00272012-337\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended ordinal date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits or more for the {@link ChronoField#YEAR year}.\n     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.\n     * Years outside that range will have a prefixed positive or negative symbol.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eThree digits for the {@link ChronoField#DAY_OF_YEAR day-of-year}.\n     *  This is pre-padded by zero to ensure three digits.\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_ORDINAL_DATE;\n    static {\n        ISO_ORDINAL_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(DAY_OF_YEAR, 3)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses the week-based date\n     * without an offset, such as \u00272012-W48-6\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended week-based date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits or more for the {@link IsoFields#WEEK_BASED_YEAR week-based-year}.\n     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.\n     * Years outside that range will have a prefixed positive or negative symbol.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eThe letter \u0027W\u0027. Parsing is case insensitive.\n     * \u003cli\u003eTwo digits for the {@link IsoFields#WEEK_OF_WEEK_BASED_YEAR week-of-week-based-year}.\n     *  This is pre-padded by zero to ensure three digits.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eOne digit for the {@link ChronoField#DAY_OF_WEEK day-of-week}.\n     *  The value run from Monday (1) to Sunday (7).\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_WEEK_DATE;\n    static {\n        ISO_WEEK_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendValue(IsoFields.WEEK_BASED_YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n                .appendLiteral(\"-W\")\n                .appendValue(IsoFields.WEEK_OF_WEEK_BASED_YEAR, 2)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(DAY_OF_WEEK, 1)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO instant formatter that formats or parses an instant in UTC,\n     * such as \u00272011-12-03T10:15:30Z\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 instant format.\n     * When formatting, the second-of-minute is always output.\n     * The nano-of-second outputs zero, three, six or nine digits as necessary.\n     * When parsing, time to at least the seconds field is required.\n     * Fractional seconds from zero to nine are parsed.\n     * The localized decimal style is not used.\n     * \u003cp\u003e\n     * This is a special case formatter intended to allow a human readable form\n     * of an {@link java.time.Instant}. The {@code Instant} class is designed to\n     * only represent a point in time and internally stores a value in nanoseconds\n     * from a fixed epoch of 1970-01-01Z. As such, an {@code Instant} cannot be\n     * formatted as a date or time without providing some form of time-zone.\n     * This formatter allows the {@code Instant} to be formatted, by providing\n     * a suitable conversion using {@code ZoneOffset.UTC}.\n     * \u003cp\u003e\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_OFFSET_DATE_TIME} where the instant is converted from\n     *  {@link ChronoField#INSTANT_SECONDS} and {@link ChronoField#NANO_OF_SECOND}\n     *  using the {@code UTC} offset. Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_INSTANT;\n    static {\n        ISO_INSTANT \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendInstant()\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date without an\n     * offset, such as \u002720111203\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 basic local date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits for the {@link ChronoField#YEAR year}.\n     *  Only years in the range 0000 to 9999 are supported.\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MONTH_OF_YEAR month-of-year}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eTwo digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID} without colons. If the offset has\n     *  seconds then they will be handled even though this is not part of the ISO-8601 standard.\n     *  The offset parsing is lenient, which allows the minutes and seconds to be optional.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter BASIC_ISO_DATE;\n    static {\n        BASIC_ISO_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendValue(YEAR, 4)\n                .appendValue(MONTH_OF_YEAR, 2)\n                .appendValue(DAY_OF_MONTH, 2)\n                .optionalStart()\n                .parseLenient()\n                .appendOffset(\"+HHMMss\", \"Z\")\n                .parseStrict()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The RFC-1123 date-time formatter, such as \u0027Tue, 3 Jun 2008 11:05:30 GMT\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * most of the RFC-1123 format.\n     * RFC-1123 updates RFC-822 changing the year from two digits to four.\n     * This implementation requires a four digit year.\n     * This implementation also does not handle North American or military zone\n     * names, only \u0027GMT\u0027 and offset amounts.\n     * \u003cp\u003e\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eIf the day-of-week is not available to format or parse then jump to day-of-month.\n     * \u003cli\u003eThree letter {@link ChronoField#DAY_OF_WEEK day-of-week} in English.\n     * \u003cli\u003eA comma\n     * \u003cli\u003eA space\n     * \u003cli\u003eOne or two digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.\n     * \u003cli\u003eA space\n     * \u003cli\u003eThree letter {@link ChronoField#MONTH_OF_YEAR month-of-year} in English.\n     * \u003cli\u003eA space\n     * \u003cli\u003eFour digits for the {@link ChronoField#YEAR year}.\n     *  Only years in the range 0000 to 9999 are supported.\n     * \u003cli\u003eA space\n     * \u003cli\u003eTwo digits for the {@link ChronoField#HOUR_OF_DAY hour-of-day}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MINUTE_OF_HOUR minute-of-hour}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the second-of-minute is not available then jump to the next space.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#SECOND_OF_MINUTE second-of-minute}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA space\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID} without colons or seconds.\n     *  An offset of zero uses \"GMT\". North American zone names and military zone names are not handled.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Parsing is case insensitive.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     */\n    public static final DateTimeFormatter RFC_1123_DATE_TIME;\n    static {\n        // manually code maps to ensure correct data always used\n        // (locale data can be changed by application code)\n        Map\u003cLong, String\u003e dow \u003d new HashMap\u003c\u003e();\n        dow.put(1L, \"Mon\");\n        dow.put(2L, \"Tue\");\n        dow.put(3L, \"Wed\");\n        dow.put(4L, \"Thu\");\n        dow.put(5L, \"Fri\");\n        dow.put(6L, \"Sat\");\n        dow.put(7L, \"Sun\");\n        Map\u003cLong, String\u003e moy \u003d new HashMap\u003c\u003e();\n        moy.put(1L, \"Jan\");\n        moy.put(2L, \"Feb\");\n        moy.put(3L, \"Mar\");\n        moy.put(4L, \"Apr\");\n        moy.put(5L, \"May\");\n        moy.put(6L, \"Jun\");\n        moy.put(7L, \"Jul\");\n        moy.put(8L, \"Aug\");\n        moy.put(9L, \"Sep\");\n        moy.put(10L, \"Oct\");\n        moy.put(11L, \"Nov\");\n        moy.put(12L, \"Dec\");\n        RFC_1123_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .parseLenient()\n                .optionalStart()\n                .appendText(DAY_OF_WEEK, dow)\n                .appendLiteral(\", \")\n                .optionalEnd()\n                .appendValue(DAY_OF_MONTH, 1, 2, SignStyle.NOT_NEGATIVE)\n                .appendLiteral(\u0027 \u0027)\n                .appendText(MONTH_OF_YEAR, moy)\n                .appendLiteral(\u0027 \u0027)\n                .appendValue(YEAR, 4)  // 2 digit year not handled\n                .appendLiteral(\u0027 \u0027)\n                .appendValue(HOUR_OF_DAY, 2)\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(MINUTE_OF_HOUR, 2)\n                .optionalStart()\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(SECOND_OF_MINUTE, 2)\n                .optionalEnd()\n                .appendLiteral(\u0027 \u0027)\n                .appendOffset(\"+HHMM\", \"GMT\")  // should handle UT/Z/EST/EDT/CST/CDT/MST/MDT/PST/MDT\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * A query that provides access to the excess days that were parsed.\n     * \u003cp\u003e\n     * This returns a singleton {@linkplain TemporalQuery query} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null period, with a zero period returned instead of null.\n     * \u003cp\u003e\n     * There are two situations where this query may return a non-zero period.\n     * \u003cul\u003e\n     * \u003cli\u003eIf the {@code ResolverStyle} is {@code LENIENT} and a time is parsed\n     *  without a date, then the complete result of the parse consists of a\n     *  {@code LocalTime} and an excess {@code Period} in days.\n     *\n     * \u003cli\u003eIf the {@code ResolverStyle} is {@code SMART} and a time is parsed\n     *  without a date where the time is 24:00:00, then the complete result of\n     *  the parse consists of a {@code LocalTime} of 00:00:00 and an excess\n     *  {@code Period} of one day.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * In both cases, if a complete {@code ChronoLocalDateTime} or {@code Instant}\n     * is parsed, then the excess days are added to the date part.\n     * As a result, this query will return a zero period.\n     * \u003cp\u003e\n     * The {@code SMART} behaviour handles the common \"end of day\" 24:00 value.\n     * Processing in {@code LENIENT} mode also produces the same result:\n     * \u003cpre\u003e\n     *  Text to parse        Parsed object                         Excess days\n     *  \"2012-12-03T00:00\"   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO\n     *  \"2012-12-03T24:00\"   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO\n     *  \"00:00\"              LocalTime.of(0, 0)                    ZERO\n     *  \"24:00\"              LocalTime.of(0, 0)                    Period.ofDays(1)\n     * \u003c/pre\u003e\n     * The query can be used as follows:\n     * \u003cpre\u003e\n     *  TemporalAccessor parsed \u003d formatter.parse(str);\n     *  LocalTime time \u003d parsed.query(LocalTime::from);\n     *  Period extraDays \u003d parsed.query(DateTimeFormatter.parsedExcessDays());\n     * \u003c/pre\u003e\n     * @return a query that provides access to the excess days that were parsed\n     */\n    public static final TemporalQuery\u003cPeriod\u003e parsedExcessDays() {\n        return PARSED_EXCESS_DAYS;\n    }\n    private static final TemporalQuery\u003cPeriod\u003e PARSED_EXCESS_DAYS \u003d t -\u003e {\n        if (t instanceof Parsed) {\n            return ((Parsed) t).excessDays;\n        } else {\n            return Period.ZERO;\n        }\n    };\n\n    /**\n     * A query that provides access to whether a leap-second was parsed.\n     * \u003cp\u003e\n     * This returns a singleton {@linkplain TemporalQuery query} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null boolean, true if parsing saw a leap-second, false if not.\n     * \u003cp\u003e\n     * Instant parsing handles the special \"leap second\" time of \u002723:59:60\u0027.\n     * Leap seconds occur at \u002723:59:60\u0027 in the UTC time-zone, but at other\n     * local times in different time-zones. To avoid this potential ambiguity,\n     * the handling of leap-seconds is limited to\n     * {@link DateTimeFormatterBuilder#appendInstant()}, as that method\n     * always parses the instant with the UTC zone offset.\n     * \u003cp\u003e\n     * If the time \u002723:59:60\u0027 is received, then a simple conversion is applied,\n     * replacing the second-of-minute of 60 with 59. This query can be used\n     * on the parse result to determine if the leap-second adjustment was made.\n     * The query will return {@code true} if it did adjust to remove the\n     * leap-second, and {@code false} if not. Note that applying a leap-second\n     * smoothing mechanism, such as UTC-SLS, is the responsibility of the\n     * application, as follows:\n     * \u003cpre\u003e\n     *  TemporalAccessor parsed \u003d formatter.parse(str);\n     *  Instant instant \u003d parsed.query(Instant::from);\n     *  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {\n     *    // validate leap-second is correct and apply correct smoothing\n     *  }\n     * \u003c/pre\u003e\n     * @return a query that provides access to whether a leap-second was parsed\n     */\n    public static final TemporalQuery\u003cBoolean\u003e parsedLeapSecond() {\n        return PARSED_LEAP_SECOND;\n    }\n    private static final TemporalQuery\u003cBoolean\u003e PARSED_LEAP_SECOND \u003d t -\u003e {\n        if (t instanceof Parsed) {\n            return ((Parsed) t).leapSecond;\n        } else {\n            return Boolean.FALSE;\n        }\n    };\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param printerParser  the printer/parser to use, not null\n     * @param locale  the locale to use, not null\n     * @param decimalStyle  the DecimalStyle to use, not null\n     * @param resolverStyle  the resolver style to use, not null\n     * @param resolverFields  the fields to use during resolving, null for all fields\n     * @param chrono  the chronology to use, null for no override\n     * @param zone  the zone to use, null for no override\n     */\n    DateTimeFormatter(CompositePrinterParser printerParser,\n            Locale locale, DecimalStyle decimalStyle,\n            ResolverStyle resolverStyle, Set\u003cTemporalField\u003e resolverFields,\n            Chronology chrono, ZoneId zone) {\n        this.printerParser \u003d Objects.requireNonNull(printerParser, \"printerParser\");\n        this.resolverFields \u003d resolverFields;\n        this.locale \u003d Objects.requireNonNull(locale, \"locale\");\n        this.decimalStyle \u003d Objects.requireNonNull(decimalStyle, \"decimalStyle\");\n        this.resolverStyle \u003d Objects.requireNonNull(resolverStyle, \"resolverStyle\");\n        this.chrono \u003d chrono;\n        this.zone \u003d zone;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the locale to be used during formatting.\n     * \u003cp\u003e\n     * This is used to lookup any part of the formatter needing specific\n     * localization, such as the text or localized pattern.\n     *\n     * @return the locale of this formatter, not null\n     */\n    public Locale getLocale() {\n        return locale;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new locale.\n     * \u003cp\u003e\n     * This is used to lookup any part of the formatter needing specific\n     * localization, such as the text or localized pattern.\n     * \u003cp\u003e\n     * The locale is stored as passed in, without further processing.\n     * If the locale has \u003ca href\u003d\"../../util/Locale.html#def_locale_extension\"\u003e\n     * Unicode extensions\u003c/a\u003e, they may be used later in text\n     * processing. To set the chronology, time-zone and decimal style from\n     * unicode extensions, see {@link #localizedBy localizedBy()}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param locale  the new locale, not null\n     * @return a formatter based on this formatter with the requested locale, not null\n     * @see #localizedBy(Locale)\n     */\n    public DateTimeFormatter withLocale(Locale locale) {\n        if (this.locale.equals(locale)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    /**\n     * Returns a copy of this formatter with localized values of the locale,\n     * calendar, region, decimal style and/or timezone, that supercede values in\n     * this formatter.\n     * \u003cp\u003e\n     * This is used to lookup any part of the formatter needing specific\n     * localization, such as the text or localized pattern. If the locale contains the\n     * \"ca\" (calendar), \"nu\" (numbering system), \"rg\" (region override), and/or\n     * \"tz\" (timezone)\n     * \u003ca href\u003d\"../../util/Locale.html#def_locale_extension\"\u003eUnicode extensions\u003c/a\u003e,\n     * the chronology, numbering system and/or the zone are overridden. If both \"ca\"\n     * and \"rg\" are specified, the chronology from the \"ca\" extension supersedes the\n     * implicit one from the \"rg\" extension. Same is true for the \"nu\" extension.\n     * \u003cp\u003e\n     * Unlike the {@link #withLocale withLocale} method, the call to this method may\n     * produce a different formatter depending on the order of method chaining with\n     * other withXXXX() methods.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param locale  the locale, not null\n     * @return a formatter based on this formatter with localized values of\n     *      the calendar, decimal style and/or timezone, that supercede values in this\n     *      formatter.\n     * @see #withLocale(Locale)\n     * @since 10\n     */\n    public DateTimeFormatter localizedBy(Locale locale) {\n        if (this.locale.equals(locale)) {\n            return this;\n        }\n\n        // Check for decimalStyle/chronology/timezone in locale object\n        Chronology c \u003d locale.getUnicodeLocaleType(\"ca\") !\u003d null ?\n                       Chronology.ofLocale(locale) : chrono;\n        DecimalStyle ds \u003d locale.getUnicodeLocaleType(\"nu\") !\u003d null ?\n                       DecimalStyle.of(locale) : decimalStyle;\n        String tzType \u003d locale.getUnicodeLocaleType(\"tz\");\n        ZoneId z  \u003d tzType !\u003d null ?\n                    TimeZoneNameUtility.convertLDMLShortID(tzType)\n                        .map(ZoneId::of)\n                        .orElse(zone) :\n                    zone;\n        return new DateTimeFormatter(printerParser, locale, ds, resolverStyle, resolverFields, c, z);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the DecimalStyle to be used during formatting.\n     *\n     * @return the locale of this formatter, not null\n     */\n    public DecimalStyle getDecimalStyle() {\n        return decimalStyle;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new DecimalStyle.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param decimalStyle  the new DecimalStyle, not null\n     * @return a formatter based on this formatter with the requested DecimalStyle, not null\n     */\n    public DateTimeFormatter withDecimalStyle(DecimalStyle decimalStyle) {\n        if (this.decimalStyle.equals(decimalStyle)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the overriding chronology to be used during formatting.\n     * \u003cp\u003e\n     * This returns the override chronology, used to convert dates.\n     * By default, a formatter has no override chronology, returning null.\n     * See {@link #withChronology(Chronology)} for more details on overriding.\n     *\n     * @return the override chronology of this formatter, null if no override\n     */\n    public Chronology getChronology() {\n        return chrono;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new override chronology.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but\n     * with the override chronology set.\n     * By default, a formatter has no override chronology, returning null.\n     * \u003cp\u003e\n     * If an override is added, then any date that is formatted or parsed will be affected.\n     * \u003cp\u003e\n     * When formatting, if the temporal object contains a date, then it will\n     * be converted to a date in the override chronology.\n     * Whether the temporal contains a date is determined by querying the\n     * {@link ChronoField#EPOCH_DAY EPOCH_DAY} field.\n     * Any time or zone will be retained unaltered unless overridden.\n     * \u003cp\u003e\n     * If the temporal object does not contain a date, but does contain one\n     * or more {@code ChronoField} date fields, then a {@code DateTimeException}\n     * is thrown. In all other cases, the override chronology is added to the temporal,\n     * replacing any previous chronology, but without changing the date/time.\n     * \u003cp\u003e\n     * When parsing, there are two distinct cases to consider.\n     * If a chronology has been parsed directly from the text, perhaps because\n     * {@link DateTimeFormatterBuilder#appendChronologyId()} was used, then\n     * this override chronology has no effect.\n     * If no zone has been parsed, then this override chronology will be used\n     * to interpret the {@code ChronoField} values into a date according to the\n     * date resolving rules of the chronology.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param chrono  the new chronology, null if no override\n     * @return a formatter based on this formatter with the requested override chronology, not null\n     */\n    public DateTimeFormatter withChronology(Chronology chrono) {\n        if (Objects.equals(this.chrono, chrono)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the overriding zone to be used during formatting.\n     * \u003cp\u003e\n     * This returns the override zone, used to convert instants.\n     * By default, a formatter has no override zone, returning null.\n     * See {@link #withZone(ZoneId)} for more details on overriding.\n     *\n     * @return the override zone of this formatter, null if no override\n     */\n    public ZoneId getZone() {\n        return zone;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new override zone.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but\n     * with the override zone set.\n     * By default, a formatter has no override zone, returning null.\n     * \u003cp\u003e\n     * If an override is added, then any instant that is formatted or parsed will be affected.\n     * \u003cp\u003e\n     * When formatting, if the temporal object contains an instant, then it will\n     * be converted to a zoned date-time using the override zone.\n     * Whether the temporal is an instant is determined by querying the\n     * {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS} field.\n     * If the input has a chronology then it will be retained unless overridden.\n     * If the input does not have a chronology, such as {@code Instant}, then\n     * the ISO chronology will be used.\n     * \u003cp\u003e\n     * If the temporal object does not contain an instant, but does contain\n     * an offset then an additional check is made. If the normalized override\n     * zone is an offset that differs from the offset of the temporal, then\n     * a {@code DateTimeException} is thrown. In all other cases, the override\n     * zone is added to the temporal, replacing any previous zone, but without\n     * changing the date/time.\n     * \u003cp\u003e\n     * When parsing, there are two distinct cases to consider.\n     * If a zone has been parsed directly from the text, perhaps because\n     * {@link DateTimeFormatterBuilder#appendZoneId()} was used, then\n     * this override zone has no effect.\n     * If no zone has been parsed, then this override zone will be included in\n     * the result of the parse where it can be used to build instants and date-times.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the new override zone, null if no override\n     * @return a formatter based on this formatter with the requested override zone, not null\n     */\n    public DateTimeFormatter withZone(ZoneId zone) {\n        if (Objects.equals(this.zone, zone)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the resolver style to use during parsing.\n     * \u003cp\u003e\n     * This returns the resolver style, used during the second phase of parsing\n     * when fields are resolved into dates and times.\n     * By default, a formatter has the {@link ResolverStyle#SMART SMART} resolver style.\n     * See {@link #withResolverStyle(ResolverStyle)} for more details.\n     *\n     * @return the resolver style of this formatter, not null\n     */\n    public ResolverStyle getResolverStyle() {\n        return resolverStyle;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new resolver style.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but\n     * with the resolver style set. By default, a formatter has the\n     * {@link ResolverStyle#SMART SMART} resolver style.\n     * \u003cp\u003e\n     * Changing the resolver style only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver style is used to control how phase 2, resolving, happens.\n     * See {@code ResolverStyle} for more information on the options available.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param resolverStyle  the new resolver style, not null\n     * @return a formatter based on this formatter with the requested resolver style, not null\n     */\n    public DateTimeFormatter withResolverStyle(ResolverStyle resolverStyle) {\n        Objects.requireNonNull(resolverStyle, \"resolverStyle\");\n        if (Objects.equals(this.resolverStyle, resolverStyle)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the resolver fields to use during parsing.\n     * \u003cp\u003e\n     * This returns the resolver fields, used during the second phase of parsing\n     * when fields are resolved into dates and times.\n     * By default, a formatter has no resolver fields, and thus returns null.\n     * See {@link #withResolverFields(Set)} for more details.\n     *\n     * @return the immutable set of resolver fields of this formatter, null if no fields\n     */\n    public Set\u003cTemporalField\u003e getResolverFields() {\n        return resolverFields;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new set of resolver fields.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but with\n     * the resolver fields set. By default, a formatter has no resolver fields.\n     * \u003cp\u003e\n     * Changing the resolver fields only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver fields are used to filter the field-value pairs between phase 1 and 2.\n     * \u003cp\u003e\n     * This can be used to select between two or more ways that a date or time might\n     * be resolved. For example, if the formatter consists of year, month, day-of-month\n     * and day-of-year, then there are two ways to resolve a date.\n     * Calling this method with the arguments {@link ChronoField#YEAR YEAR} and\n     * {@link ChronoField#DAY_OF_YEAR DAY_OF_YEAR} will ensure that the date is\n     * resolved using the year and day-of-year, effectively meaning that the month\n     * and day-of-month are ignored during the resolving phase.\n     * \u003cp\u003e\n     * In a similar manner, this method can be used to ignore secondary fields that\n     * would otherwise be cross-checked. For example, if the formatter consists of year,\n     * month, day-of-month and day-of-week, then there is only one way to resolve a\n     * date, but the parsed value for day-of-week will be cross-checked against the\n     * resolved date. Calling this method with the arguments {@link ChronoField#YEAR YEAR},\n     * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and\n     * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} will ensure that the date is\n     * resolved correctly, but without any cross-check for the day-of-week.\n     * \u003cp\u003e\n     * In implementation terms, this method behaves as follows. The result of the\n     * parsing phase can be considered to be a map of field to value. The behavior\n     * of this method is to cause that map to be filtered between phase 1 and 2,\n     * removing all fields other than those specified as arguments to this method.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param resolverFields  the new set of resolver fields, null if no fields\n     * @return a formatter based on this formatter with the requested resolver style, not null\n     */\n    public DateTimeFormatter withResolverFields(TemporalField... resolverFields) {\n        Set\u003cTemporalField\u003e fields \u003d null;\n        if (resolverFields !\u003d null) {\n            // Set.of cannot be used because it is hostile to nulls and duplicate elements\n            fields \u003d Collections.unmodifiableSet(new HashSet\u003c\u003e(Arrays.asList(resolverFields)));\n        }\n        if (Objects.equals(this.resolverFields, fields)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, fields, chrono, zone);\n    }\n\n    /**\n     * Returns a copy of this formatter with a new set of resolver fields.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but with\n     * the resolver fields set. By default, a formatter has no resolver fields.\n     * \u003cp\u003e\n     * Changing the resolver fields only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver fields are used to filter the field-value pairs between phase 1 and 2.\n     * \u003cp\u003e\n     * This can be used to select between two or more ways that a date or time might\n     * be resolved. For example, if the formatter consists of year, month, day-of-month\n     * and day-of-year, then there are two ways to resolve a date.\n     * Calling this method with the arguments {@link ChronoField#YEAR YEAR} and\n     * {@link ChronoField#DAY_OF_YEAR DAY_OF_YEAR} will ensure that the date is\n     * resolved using the year and day-of-year, effectively meaning that the month\n     * and day-of-month are ignored during the resolving phase.\n     * \u003cp\u003e\n     * In a similar manner, this method can be used to ignore secondary fields that\n     * would otherwise be cross-checked. For example, if the formatter consists of year,\n     * month, day-of-month and day-of-week, then there is only one way to resolve a\n     * date, but the parsed value for day-of-week will be cross-checked against the\n     * resolved date. Calling this method with the arguments {@link ChronoField#YEAR YEAR},\n     * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and\n     * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} will ensure that the date is\n     * resolved correctly, but without any cross-check for the day-of-week.\n     * \u003cp\u003e\n     * In implementation terms, this method behaves as follows. The result of the\n     * parsing phase can be considered to be a map of field to value. The behavior\n     * of this method is to cause that map to be filtered between phase 1 and 2,\n     * removing all fields other than those specified as arguments to this method.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param resolverFields  the new set of resolver fields, null if no fields\n     * @return a formatter based on this formatter with the requested resolver style, not null\n     */\n    public DateTimeFormatter withResolverFields(Set\u003cTemporalField\u003e resolverFields) {\n        if (Objects.equals(this.resolverFields, resolverFields)) {\n            return this;\n        }\n        if (resolverFields !\u003d null) {\n            resolverFields \u003d Collections.unmodifiableSet(new HashSet\u003c\u003e(resolverFields));\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats a date-time object using this formatter.\n     * \u003cp\u003e\n     * This formats the date-time to a String using the rules of the formatter.\n     *\n     * @param temporal  the temporal object to format, not null\n     * @return the formatted string, not null\n     * @throws DateTimeException if an error occurs during formatting\n     */\n    public String format(TemporalAccessor temporal) {\n        StringBuilder buf \u003d new StringBuilder(32);\n        formatTo(temporal, buf);\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats a date-time object to an {@code Appendable} using this formatter.\n     * \u003cp\u003e\n     * This outputs the formatted date-time to the specified destination.\n     * {@link Appendable} is a general purpose interface that is implemented by all\n     * key character output classes including {@code StringBuffer}, {@code StringBuilder},\n     * {@code PrintStream} and {@code Writer}.\n     * \u003cp\u003e\n     * Although {@code Appendable} methods throw an {@code IOException}, this method does not.\n     * Instead, any {@code IOException} is wrapped in a runtime exception.\n     *\n     * @param temporal  the temporal object to format, not null\n     * @param appendable  the appendable to format to, not null\n     * @throws DateTimeException if an error occurs during formatting\n     */\n    public void formatTo(TemporalAccessor temporal, Appendable appendable) {\n        Objects.requireNonNull(temporal, \"temporal\");\n        Objects.requireNonNull(appendable, \"appendable\");\n        try {\n            DateTimePrintContext context \u003d new DateTimePrintContext(temporal, this);\n            if (appendable instanceof StringBuilder) {\n                printerParser.format(context, (StringBuilder) appendable);\n            } else {\n                // buffer output to avoid writing to appendable in case of error\n                StringBuilder buf \u003d new StringBuilder(32);\n                printerParser.format(context, buf);\n                appendable.append(buf);\n            }\n        } catch (IOException ex) {\n            throw new DateTimeException(ex.getMessage(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Fully parses the text producing a temporal object.\n     * \u003cp\u003e\n     * This parses the entire text producing a temporal object.\n     * It is typically more useful to use {@link #parse(CharSequence, TemporalQuery)}.\n     * The result of this method is {@code TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     * \u003cp\u003e\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    public TemporalAccessor parse(CharSequence text) {\n        Objects.requireNonNull(text, \"text\");\n        try {\n            return parseResolved0(text, null);\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    /**\n     * Parses the text using this formatter, providing control over the text position.\n     * \u003cp\u003e\n     * This parses the text without requiring the parse to start from the beginning\n     * of the string or finish at the end.\n     * The result of this method is {@code TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     * \u003cp\u003e\n     * The text will be parsed from the specified start {@code ParsePosition}.\n     * The entire length of the text does not have to be parsed, the {@code ParsePosition}\n     * will be updated with the index at the end of parsing.\n     * \u003cp\u003e\n     * The operation of this method is slightly different to similar methods using\n     * {@code ParsePosition} on {@code java.text.Format}. That class will return\n     * errors using the error index on the {@code ParsePosition}. By contrast, this\n     * method will throw a {@link DateTimeParseException} if an error occurs, with\n     * the exception containing the error index.\n     * This change in behavior is necessary due to the increased complexity of\n     * parsing and resolving dates/times in this API.\n     * \u003cp\u003e\n     * If the formatter parses the same field more than once with different values,\n     * the result will be an error.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, not null\n     * @return the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    public TemporalAccessor parse(CharSequence text, ParsePosition position) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(position, \"position\");\n        try {\n            return parseResolved0(text, position);\n        } catch (DateTimeParseException | IndexOutOfBoundsException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Fully parses the text producing an object of the specified type.\n     * \u003cp\u003e\n     * Most applications should use this method for parsing.\n     * It parses the entire text to produce the required date-time.\n     * The query is typically a method reference to a {@code from(TemporalAccessor)} method.\n     * For example:\n     * \u003cpre\u003e\n     *  LocalDateTime dt \u003d parser.parse(str, LocalDateTime::from);\n     * \u003c/pre\u003e\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param \u003cT\u003e the type of the parsed date-time\n     * @param text  the text to parse, not null\n     * @param query  the query defining the type to parse to, not null\n     * @return the parsed date-time, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    public \u003cT\u003e T parse(CharSequence text, TemporalQuery\u003cT\u003e query) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(query, \"query\");\n        try {\n            return parseResolved0(text, null).query(query);\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    /**\n     * Fully parses the text producing an object of one of the specified types.\n     * \u003cp\u003e\n     * This parse method is convenient for use when the parser can handle optional elements.\n     * For example, a pattern of \u0027uuuu-MM-dd HH.mm[ VV]\u0027 can be fully parsed to a {@code ZonedDateTime},\n     * or partially parsed to a {@code LocalDateTime}.\n     * The queries must be specified in order, starting from the best matching full-parse option\n     * and ending with the worst matching minimal parse option.\n     * The query is typically a method reference to a {@code from(TemporalAccessor)} method.\n     * \u003cp\u003e\n     * The result is associated with the first type that successfully parses.\n     * Normally, applications will use {@code instanceof} to check the result.\n     * For example:\n     * \u003cpre\u003e\n     *  TemporalAccessor dt \u003d parser.parseBest(str, ZonedDateTime::from, LocalDateTime::from);\n     *  if (dt instanceof ZonedDateTime) {\n     *   ...\n     *  } else {\n     *   ...\n     *  }\n     * \u003c/pre\u003e\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param text  the text to parse, not null\n     * @param queries  the queries defining the types to attempt to parse to,\n     *  must implement {@code TemporalAccessor}, not null\n     * @return the parsed date-time, not null\n     * @throws IllegalArgumentException if less than 2 types are specified\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    public TemporalAccessor parseBest(CharSequence text, TemporalQuery\u003c?\u003e... queries) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(queries, \"queries\");\n        if (queries.length \u003c 2) {\n            throw new IllegalArgumentException(\"At least two queries must be specified\");\n        }\n        try {\n            TemporalAccessor resolved \u003d parseResolved0(text, null);\n            for (TemporalQuery\u003c?\u003e query : queries) {\n                try {\n                    return (TemporalAccessor) resolved.query(query);\n                } catch (RuntimeException ex) {\n                    // continue\n                }\n            }\n            throw new DateTimeException(\"Unable to convert parsed text using any of the specified queries\");\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    private DateTimeParseException createError(CharSequence text, RuntimeException ex) {\n        String abbr;\n        if (text.length() \u003e 64) {\n            abbr \u003d text.subSequence(0, 64).toString() + \"...\";\n        } else {\n            abbr \u003d text.toString();\n        }\n        return new DateTimeParseException(\"Text \u0027\" + abbr + \"\u0027 could not be parsed: \" + ex.getMessage(), text, 0, ex);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses and resolves the specified text.\n     * \u003cp\u003e\n     * This parses to a {@code TemporalAccessor} ensuring that the text is fully parsed.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, null if parsing whole string\n     * @return the resolved result of the parse, not null\n     * @throws DateTimeParseException if the parse fails\n     * @throws DateTimeException if an error occurs while resolving the date or time\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    private TemporalAccessor parseResolved0(final CharSequence text, final ParsePosition position) {\n        ParsePosition pos \u003d (position !\u003d null ? position : new ParsePosition(0));\n        DateTimeParseContext context \u003d parseUnresolved0(text, pos);\n        if (context \u003d\u003d null || pos.getErrorIndex() \u003e\u003d 0 || (position \u003d\u003d null \u0026\u0026 pos.getIndex() \u003c text.length())) {\n            String abbr;\n            if (text.length() \u003e 64) {\n                abbr \u003d text.subSequence(0, 64).toString() + \"...\";\n            } else {\n                abbr \u003d text.toString();\n            }\n            if (pos.getErrorIndex() \u003e\u003d 0) {\n                throw new DateTimeParseException(\"Text \u0027\" + abbr + \"\u0027 could not be parsed at index \" +\n                        pos.getErrorIndex(), text, pos.getErrorIndex());\n            } else {\n                throw new DateTimeParseException(\"Text \u0027\" + abbr + \"\u0027 could not be parsed, unparsed text found at index \" +\n                        pos.getIndex(), text, pos.getIndex());\n            }\n        }\n        return context.toResolved(resolverStyle, resolverFields);\n    }\n\n    /**\n     * Parses the text using this formatter, without resolving the result, intended\n     * for advanced use cases.\n     * \u003cp\u003e\n     * Parsing is implemented as a two-phase operation.\n     * First, the text is parsed using the layout defined by the formatter, producing\n     * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.\n     * Second, the parsed data is \u003cem\u003eresolved\u003c/em\u003e, by validating, combining and\n     * simplifying the various fields into more useful ones.\n     * This method performs the parsing stage but not the resolving stage.\n     * \u003cp\u003e\n     * The result of this method is {@code TemporalAccessor} which represents the\n     * data as seen in the input. Values are not validated, thus parsing a date string\n     * of \u00272012-00-65\u0027 would result in a temporal with three fields - year of \u00272012\u0027,\n     * month of \u00270\u0027 and day-of-month of \u002765\u0027.\n     * \u003cp\u003e\n     * The text will be parsed from the specified start {@code ParsePosition}.\n     * The entire length of the text does not have to be parsed, the {@code ParsePosition}\n     * will be updated with the index at the end of parsing.\n     * \u003cp\u003e\n     * Errors are returned using the error index field of the {@code ParsePosition}\n     * instead of {@code DateTimeParseException}.\n     * The returned error index will be set to an index indicative of the error.\n     * Callers must check for errors before using the result.\n     * \u003cp\u003e\n     * If the formatter parses the same field more than once with different values,\n     * the result will be an error.\n     * \u003cp\u003e\n     * This method is intended for advanced use cases that need access to the\n     * internal state during parsing. Typical application code should use\n     * {@link #parse(CharSequence, TemporalQuery)} or the parse method on the target type.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, not null\n     * @return the parsed text, null if the parse results in an error\n     * @throws DateTimeException if some problem occurs during parsing\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    public TemporalAccessor parseUnresolved(CharSequence text, ParsePosition position) {\n        DateTimeParseContext context \u003d parseUnresolved0(text, position);\n        if (context \u003d\u003d null) {\n            return null;\n        }\n        return context.toUnresolved();\n    }\n\n    private DateTimeParseContext parseUnresolved0(CharSequence text, ParsePosition position) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(position, \"position\");\n        DateTimeParseContext context \u003d new DateTimeParseContext(this);\n        int pos \u003d position.getIndex();\n        pos \u003d printerParser.parse(context, text, pos);\n        if (pos \u003c 0) {\n            position.setErrorIndex(~pos);  // index not updated from input\n            return null;\n        }\n        position.setIndex(pos);  // errorIndex not updated from input\n        return context;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the formatter as a composite printer parser.\n     *\n     * @param optional  whether the printer/parser should be optional\n     * @return the printer/parser, not null\n     */\n    CompositePrinterParser toPrinterParser(boolean optional) {\n        return printerParser.withOptional(optional);\n    }\n\n    /**\n     * Returns this formatter as a {@code java.text.Format} instance.\n     * \u003cp\u003e\n     * The returned {@link Format} instance will format any {@link TemporalAccessor}\n     * and parses to a resolved {@link TemporalAccessor}.\n     * \u003cp\u003e\n     * Exceptions will follow the definitions of {@code Format}, see those methods\n     * for details about {@code IllegalArgumentException} during formatting and\n     * {@code ParseException} or null during parsing.\n     * The format does not support attributing of the returned format string.\n     *\n     * @return this formatter as a classic format instance, not null\n     */\n    public Format toFormat() {\n        return new ClassicFormat(this, null);\n    }\n\n    /**\n     * Returns this formatter as a {@code java.text.Format} instance that will\n     * parse using the specified query.\n     * \u003cp\u003e\n     * The returned {@link Format} instance will format any {@link TemporalAccessor}\n     * and parses to the type specified.\n     * The type must be one that is supported by {@link #parse}.\n     * \u003cp\u003e\n     * Exceptions will follow the definitions of {@code Format}, see those methods\n     * for details about {@code IllegalArgumentException} during formatting and\n     * {@code ParseException} or null during parsing.\n     * The format does not support attributing of the returned format string.\n     *\n     * @param parseQuery  the query defining the type to parse to, not null\n     * @return this formatter as a classic format instance, not null\n     */\n    public Format toFormat(TemporalQuery\u003c?\u003e parseQuery) {\n        Objects.requireNonNull(parseQuery, \"parseQuery\");\n        return new ClassicFormat(this, parseQuery);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a description of the underlying formatters.\n     *\n     * @return a description of this formatter, not null\n     */\n    @Override\n    public String toString() {\n        String pattern \u003d printerParser.toString();\n        pattern \u003d pattern.startsWith(\"[\") ? pattern : pattern.substring(1, pattern.length() - 1);\n        return pattern;\n        // TODO: Fix tests to not depend on toString()\n//        return \"DateTimeFormatter[\" + locale +\n//                (chrono !\u003d null ? \",\" + chrono : \"\") +\n//                (zone !\u003d null ? \",\" + zone : \"\") +\n//                pattern + \"]\";\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements the classic Java Format API.\n     * @serial exclude\n     */\n    @SuppressWarnings(\"serial\")  // not actually serializable\n    static class ClassicFormat extends Format {\n        /** The formatter. */\n        private final DateTimeFormatter formatter;\n        /** The type to be parsed. */\n        private final TemporalQuery\u003c?\u003e parseType;\n        /** Constructor. */\n        public ClassicFormat(DateTimeFormatter formatter, TemporalQuery\u003c?\u003e parseType) {\n            this.formatter \u003d formatter;\n            this.parseType \u003d parseType;\n        }\n\n        @Override\n        public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n            Objects.requireNonNull(obj, \"obj\");\n            Objects.requireNonNull(toAppendTo, \"toAppendTo\");\n            Objects.requireNonNull(pos, \"pos\");\n            if (obj instanceof TemporalAccessor \u003d\u003d false) {\n                throw new IllegalArgumentException(\"Format target must implement TemporalAccessor\");\n            }\n            pos.setBeginIndex(0);\n            pos.setEndIndex(0);\n            try {\n                formatter.formatTo((TemporalAccessor) obj, toAppendTo);\n            } catch (RuntimeException ex) {\n                throw new IllegalArgumentException(ex.getMessage(), ex);\n            }\n            return toAppendTo;\n        }\n        @Override\n        public Object parseObject(String text) throws ParseException {\n            Objects.requireNonNull(text, \"text\");\n            try {\n                if (parseType \u003d\u003d null) {\n                    return formatter.parseResolved0(text, null);\n                }\n                return formatter.parse(text, parseType);\n            } catch (DateTimeParseException ex) {\n                throw new ParseException(ex.getMessage(), ex.getErrorIndex());\n            } catch (RuntimeException ex) {\n                throw (ParseException) new ParseException(ex.getMessage(), 0).initCause(ex);\n            }\n        }\n        @Override\n        public Object parseObject(String text, ParsePosition pos) {\n            Objects.requireNonNull(text, \"text\");\n            DateTimeParseContext context;\n            try {\n                context \u003d formatter.parseUnresolved0(text, pos);\n            } catch (IndexOutOfBoundsException ex) {\n                if (pos.getErrorIndex() \u003c 0) {\n                    pos.setErrorIndex(0);\n                }\n                return null;\n            }\n            if (context \u003d\u003d null) {\n                if (pos.getErrorIndex() \u003c 0) {\n                    pos.setErrorIndex(0);\n                }\n                return null;\n            }\n            try {\n                TemporalAccessor resolved \u003d context.toResolved(formatter.resolverStyle, formatter.resolverFields);\n                if (parseType \u003d\u003d null) {\n                    return resolved;\n                }\n                return resolved.query(parseType);\n            } catch (RuntimeException ex) {\n                pos.setErrorIndex(0);\n                return null;\n            }\n        }\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

oct 24, 2024 7:12:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 24, 2024 7:27:54 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-notebook-cell:/c%3A/Proyectos/spark-datos-energia/notebooks/Prueba.ipynb#W0sZmlsZQ%3D%3D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-notebook-cell" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.24 19:28:43 INFO  compiling root (1 scala source)
2024.10.24 19:28:43 INFO  time: compiled root in 0.91s
oct 24, 2024 7:34:32 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
2024.10.28 19:55:28 INFO  compiling root (1 scala source)
2024.10.28 19:55:29 INFO  time: compiled root in 1.3s
2024.10.29 19:42:33 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.29 19:42:33 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.29 19:42:33 INFO  Starting debug proxy for [example.MercadosDownloader]
2024.10.29 19:42:34 INFO  Loaded expression compiler in 407 milliseconds
2024.10.29 19:42:34 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.MercadosDownloader)
2024.10.29 19:42:34 WARN  Found duplicate entry jersey-server in debuggee MainClassDebugAdapter(root, example.MercadosDownloader)
2024.10.29 19:42:34 WARN  Found duplicate entry jersey-client in debuggee MainClassDebugAdapter(root, example.MercadosDownloader)
2024.10.29 19:42:46 INFO  Loaded all sources and classes in 11 seconds
2024.10.29 19:42:46 INFO  Initialized Scala 3 decoder in 3 milliseconds
2024.10.29 19:42:46 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:56544 .
2024.10.29 19:42:46 INFO  Attaching to debuggee VM succeeded.
oct 29, 2024 7:45:16 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5963
2024.10.29 19:49:36 INFO  Canceling debug proxy for [example.MercadosDownloader]
2024.10.29 19:49:36 INFO  Closing debug server tcp://0.0.0.0:56541
2024.10.29 19:49:55 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.29 19:49:55 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.29 19:49:55 INFO  Starting debug proxy for [example.MercadosDownloader]
2024.10.29 19:49:55 INFO  Loaded expression compiler in 1 millisecond
2024.10.29 19:49:55 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.MercadosDownloader)
2024.10.29 19:49:55 WARN  Found duplicate entry jersey-server in debuggee MainClassDebugAdapter(root, example.MercadosDownloader)
2024.10.29 19:49:55 WARN  Found duplicate entry jersey-client in debuggee MainClassDebugAdapter(root, example.MercadosDownloader)
2024.10.29 19:50:00 INFO  Loaded all sources and classes in 4 seconds
2024.10.29 19:50:00 INFO  Initialized Scala 3 decoder in 1 millisecond
2024.10.29 19:50:00 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:57155 .
2024.10.29 19:50:00 INFO  Attaching to debuggee VM succeeded.
oct 29, 2024 7:50:57 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6135
oct 29, 2024 7:50:57 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6136
oct 29, 2024 7:50:57 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6137
oct 29, 2024 7:50:57 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6138
oct 29, 2024 7:50:57 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6139
oct 29, 2024 7:50:57 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6140
2024.10.29 19:53:36 INFO  Closing debug server tcp://0.0.0.0:57152
2024.10.29 19:53:36 INFO  Canceling debug proxy for [example.MercadosDownloader]
2024.10.29 19:57:46 INFO  compiling root (1 scala source)
2024.10.29 19:57:47 INFO  time: compiled root in 1.15s
2024.10.29 19:58:05 INFO  compiling root (1 scala source)
2024.10.29 19:58:05 INFO  time: compiled root in 0.77s
2024.10.29 21:11:46 INFO  compiling root (1 scala source)
2024.10.29 21:11:46 INFO  time: compiled root in 0.91s
2024.10.29 21:16:06 INFO  compiling root (1 scala source)
2024.10.29 21:16:06 INFO  time: compiled root in 0.93s
2024.10.29 21:16:15 INFO  compiling root (1 scala source)
2024.10.29 21:16:15 INFO  time: compiled root in 0.79s
2024.10.29 21:18:31 INFO  compiling root (1 scala source)
2024.10.29 21:18:31 INFO  time: compiled root in 0.87s
2024.10.29 21:20:38 INFO  compiling root (1 scala source)
2024.10.29 21:20:38 INFO  time: compiled root in 0.92s
2024.10.29 21:20:47 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.29 21:20:47 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.29 21:20:47 INFO  Starting debug proxy for [example.MercadosDownloader]
2024.10.29 21:20:47 INFO  Loaded expression compiler in 1 millisecond
2024.10.29 21:20:47 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.MercadosDownloader)
2024.10.29 21:20:47 WARN  Found duplicate entry jersey-server in debuggee MainClassDebugAdapter(root, example.MercadosDownloader)
2024.10.29 21:20:47 WARN  Found duplicate entry jersey-client in debuggee MainClassDebugAdapter(root, example.MercadosDownloader)
2024.10.29 21:20:50 INFO  Loaded all sources and classes in 3 seconds
2024.10.29 21:20:50 INFO  Initialized Scala 3 decoder in 0 milliseconds
2024.10.29 21:20:50 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:59802 .
2024.10.29 21:20:50 INFO  Attaching to debuggee VM succeeded.
2024.10.29 21:21:10 INFO  Canceling debug proxy for [example.MercadosDownloader]
2024.10.29 21:21:10 INFO  Closing debug server tcp://0.0.0.0:59800
2024.10.29 21:24:29 INFO  compiling root (1 scala source)
2024.10.29 21:24:29 INFO  time: compiled root in 0.91s
2024.10.29 21:28:12 INFO  compiling root (1 scala source)
2024.10.29 21:28:12 INFO  time: compiled root in 0.32s
2024.10.29 21:28:37 INFO  compiling root (1 scala source)
2024.10.29 21:28:37 INFO  time: compiled root in 0.28s
2024.10.29 21:28:54 INFO  compiling root (1 scala source)
2024.10.29 21:28:54 INFO  time: compiled root in 0.79s
2024.10.29 21:30:12 INFO  compiling root (1 scala source)
2024.10.29 21:30:12 INFO  time: compiled root in 0.82s
2024.10.29 21:30:18 INFO  compiling root (1 scala source)
2024.10.29 21:30:18 INFO  time: compiled root in 0.79s
2024.10.30 01:15:35 INFO  Shutting down server
2024.10.30 01:15:35 INFO  shutting down Metals
2024.10.30 01:15:35 INFO  Shut down connection with build server.
2024.10.30 01:15:35 INFO  Shut down connection with build server.
2024.10.30 01:15:35 INFO  Exiting server
2024.10.30 12:43:43 INFO  Started: Metals version 1.4.0 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.95.0.
2024.10.30 12:43:44 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.30 12:43:44 INFO  Attempting to connect to the build server...
2024.10.30 12:43:44 INFO  No running Bloop server found, starting one.
2024.10.30 12:43:46 INFO  Starting compilation server
2024.10.30 12:43:50 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.30 12:43:50 INFO  Attempting to connect to the build server...
2024.10.30 12:43:50 INFO  Found a Bloop server running
2024.10.30 12:43:51 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.30 12:43:50 INFO  time: Connected to build server in 6.76s
2024.10.30 12:43:50 INFO  Connected to Build server: Bloop v2.0.3
2024.10.30 12:43:51 INFO  time: Imported build in 0.23s
2024.10.30 12:43:51 INFO  running doctor check
2024.10.30 12:43:51 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.30 12:44:08 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.10.30 12:44:23 INFO  time: indexed workspace in 31s
2024.10.30 12:44:29 INFO  compiling root (5 scala sources)
2024.10.30 12:44:34 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.30 12:44:34 INFO  compiling root-test (1 scala source)
2024.10.30 12:44:34 INFO  time: compiled root in 5.77s
2024.10.30 12:44:34 INFO  time: compiled root-test in 0.54s
oct 30, 2024 1:08:17 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 145
2024.10.30 13:11:21 INFO  compiling root (1 scala source)
2024.10.30 13:11:23 INFO  time: compiled root in 1.66s
2024.10.30 13:11:24 INFO  compiling root-test (1 scala source)
2024.10.30 13:11:24 INFO  time: compiled root-test in 0.39s
oct 30, 2024 1:11:46 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 312
oct 30, 2024 6:22:42 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 341
oct 30, 2024 6:24:01 P. M. scala.meta.internal.pc.CompletionProvider expected$1
ADVERTENCIA: offset 3001, count -23, length 5547
oct 30, 2024 6:24:15 P. M. scala.meta.internal.pc.CompletionProvider expected$1
ADVERTENCIA: offset 3035, count -25, length 5581
oct 30, 2024 6:24:16 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 684
oct 30, 2024 6:24:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 696
oct 30, 2024 6:25:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 893
oct 30, 2024 6:25:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 917
oct 30, 2024 6:25:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 918
oct 30, 2024 6:25:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 919
oct 30, 2024 6:25:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 920
oct 30, 2024 6:25:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 921
oct 30, 2024 6:25:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 922
oct 30, 2024 6:25:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 925
oct 30, 2024 6:25:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 928
2024.10.30 18:26:34 INFO  compiling root (1 scala source)
2024.10.30 18:26:38 INFO  time: compiled root in 3.52s
2024.10.30 18:26:56 INFO  compiling root (1 scala source)
2024.10.30 18:26:58 INFO  time: compiled root in 2.6s
oct 30, 2024 6:27:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1298
oct 30, 2024 6:27:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1297
oct 30, 2024 6:27:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1300
oct 30, 2024 6:27:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1304
oct 30, 2024 6:27:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1309
oct 30, 2024 6:27:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1308
oct 30, 2024 6:27:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1312
oct 30, 2024 6:27:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1310
2024.10.30 18:27:57 INFO  compiling root (1 scala source)
2024.10.30 18:28:00 INFO  time: compiled root in 2.38s
2024.10.30 18:28:00 INFO  compiling root (1 scala source)
2024.10.30 18:28:03 INFO  time: compiled root in 2.33s
oct 30, 2024 6:28:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1423
oct 30, 2024 6:28:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1478
2024.10.30 18:29:43 INFO  compiling root (1 scala source)
2024.10.30 18:29:46 INFO  time: compiled root in 2.5s
2024.10.30 18:29:46 INFO  compiling root (1 scala source)
2024.10.30 18:29:47 INFO  time: compiled root in 1.05s
2024.10.30 18:33:52 INFO  compiling root (1 scala source)
2024.10.30 18:33:55 INFO  time: compiled root in 2.42s
2024.10.30 18:34:01 INFO  compiling root (1 scala source)
2024.10.30 18:34:04 INFO  time: compiled root in 2.62s
2024.10.30 18:41:51 INFO  compiling root (1 scala source)
2024.10.30 18:41:52 INFO  time: compiled root in 1.25s
2024.10.30 18:41:56 INFO  compiling root (1 scala source)
2024.10.30 18:41:57 INFO  time: compiled root in 1.03s
2024.10.30 21:28:13 INFO  compiling root (1 scala source)
2024.10.30 21:28:13 INFO  time: compiled root in 0.67s
2024.10.31 18:19:38 INFO  Shutting down server
2024.10.31 18:19:38 INFO  shutting down Metals
2024.10.31 18:19:38 INFO  Shut down connection with build server.
2024.10.31 18:19:38 INFO  Shut down connection with build server.
2024.10.31 18:19:38 INFO  Exiting server
2024.11.05 12:36:19 INFO  Started: Metals version 1.4.0 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.95.0.
2024.11.05 12:36:19 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.05 12:36:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\DemandaDownloader.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.05 12:36:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\DemandaDownloader.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.05 12:36:22 INFO  Attempting to connect to the build server...
2024.11.05 12:36:22 INFO  No running Bloop server found, starting one.
2024.11.05 12:36:24 INFO  Starting compilation server
2024.11.05 12:36:28 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.05 12:36:28 INFO  Attempting to connect to the build server...
2024.11.05 12:36:28 INFO  Found a Bloop server running
2024.11.05 12:36:29 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.05 12:36:28 INFO  time: Connected to build server in 6.54s
2024.11.05 12:36:28 INFO  Connected to Build server: Bloop v2.0.3
2024.11.05 12:36:29 INFO  time: Imported build in 0.33s
2024.11.05 12:36:29 INFO  running doctor check
2024.11.05 12:36:29 INFO  java targets: spark-datos-energia-build, root-test, root
2024.11.05 12:36:40 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.05 12:36:54 INFO  time: indexed workspace in 24s
nov 05, 2024 12:51:51 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-notebook-cell:/c%3A/Proyectos/spark-datos-energia/notebooks/Queries/PreguntasBalance.ipynb#X16sZmlsZQ%3D%3D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-notebook-cell" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

nov 05, 2024 8:24:31 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 497
2024.11.05 20:24:31 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

nov 05, 2024 8:24:31 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2022, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.nio.charset.CharacterCodingException;\nimport java.security.AccessControlContext;\nimport java.security.ProtectionDomain;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\n\nimport jdk.internal.logger.LoggerFinderLoader.TemporaryLoggerFinder;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.HotSpotIntrinsicCandidate;\nimport jdk.internal.misc.JavaLangAccess;\nimport jdk.internal.misc.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * VM will invoke the initializeSystemClass method to complete\n     * the initialization for this class separated from clinit.\n     * Note that to use properties set by the VM, see the constraints\n     * described in the initializeSystemClass method.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user.\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     */\n    public static final PrintStream err \u003d null;\n\n    /* The security manager for the system.\n     */\n    private static volatile SecurityManager security;\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    /**\n     * Sets the System security.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @param      s   the security manager.\n     * @throws     SecurityException  if the security manager has already\n     *             been set and its {@code checkPermission} method\n     *             doesn\u0027t allow it to be replaced.\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     */\n    public static void setSecurityManager(final SecurityManager s) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (s !\u003d null) {\n            try {\n                s.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(s);\n    }\n\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission\n                                     (\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Cause policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system security interface.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     */\n    public static SecurityManager getSecurityManager() {\n        return security;\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @HotSpotIntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @HotSpotIntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @HotSpotIntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @HotSpotIntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties. The following properties are guaranteed to be defined:\n     * \u003cdl\u003e\n     * \u003cdt\u003ejava.version         \u003cdd\u003eJava version number\n     * \u003cdt\u003ejava.version.date    \u003cdd\u003eJava version date\n     * \u003cdt\u003ejava.vendor          \u003cdd\u003eJava vendor specific string\n     * \u003cdt\u003ejava.vendor.url      \u003cdd\u003eJava vendor URL\n     * \u003cdt\u003ejava.vendor.version  \u003cdd\u003eJava vendor version\n     * \u003cdt\u003ejava.home            \u003cdd\u003eJava installation directory\n     * \u003cdt\u003ejava.class.version   \u003cdd\u003eJava class version number\n     * \u003cdt\u003ejava.class.path      \u003cdd\u003eJava classpath\n     * \u003cdt\u003eos.name              \u003cdd\u003eOperating System Name\n     * \u003cdt\u003eos.arch              \u003cdd\u003eOperating System Architecture\n     * \u003cdt\u003eos.version           \u003cdd\u003eOperating System Version\n     * \u003cdt\u003efile.separator       \u003cdd\u003eFile separator (\"/\" on Unix)\n     * \u003cdt\u003epath.separator       \u003cdd\u003ePath separator (\":\" on Unix)\n     * \u003cdt\u003eline.separator       \u003cdd\u003eLine separator (\"\\n\" on Unix)\n     * \u003cdt\u003euser.name            \u003cdd\u003eUser account name\n     * \u003cdt\u003euser.home            \u003cdd\u003eUser home directory\n     * \u003cdt\u003euser.dir             \u003cdd\u003eUser\u0027s current working directory\n     * \u003c/dl\u003e\n     */\n\n    private static Properties props;\n    private static native Properties initProperties(Properties props);\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties always includes values\n     * for the following keys:\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.specification.maintenance.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification maintenance version,\n     *     may be interpreted as a positive integer \u003cem\u003e(optional, see below)\u003c/em\u003e\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * The {@code java.specification.maintenance.version} property is\n     * defined if the specification implemented by this runtime at the\n     * time of its construction had undergone a \u003ca\n     * href\u003d\"https://jcp.org/en/procedures/jcp2#3.6.4\"\u003emaintenance\n     * release\u003c/a\u003e. When defined, its value identifies that\n     * maintenance release. To indicate the first maintenance release\n     * this property will have the value {@code \"1\"}, to indicate the\n     * second maintenance release this property will have the value\n     * {@code \"2\"}, and so on.\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n        if (props \u003d\u003d null) {\n            props \u003d new Properties();\n            initProperties(props);\n            System.props \u003d props;\n            VersionProps.init();\n        } else {\n            System.props \u003d props;\n        }\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.equals(\"\")) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            LoggerFinder finder \u003d service;\n            if (finder \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                finder \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n                if (finder instanceof TemporaryLoggerFinder) return finder;\n                service \u003d finder;\n            }\n            return finder;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector.\n     *\n     * Calling the {@code gc} method suggests that the Java Virtual\n     * Machine expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for quick reuse.\n     * When control returns from the method call, the Java Virtual\n     * Machine has made a best effort to reclaim space from all discarded\n     * objects.\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an implementation-\n     * dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization, in which it may need access, via\n        // System.getProperty(), to the related system encoding property that\n        // have been initialized (put into \"props\") at early stage of the\n        // initialization. So make sure the \"props\" is available at the\n        // very beginning of the initialization and all system properties to\n        // be put into it directly.\n        props \u003d new Properties(84);\n        initProperties(props);  // initialized by the VM\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // removed from the system properties.\n        //\n        // See java.lang.Integer.IntegerCache and the\n        // VM.saveAndRemoveProperties method for example.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.  Remove\n        // certain system properties that are not intended for public access.\n        VM.saveAndRemoveProperties(props);\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n        VersionProps.init();\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n        // register shared secrets\n        setJavaLangAccess();\n\n        ClassLoader.initLibraryPaths();\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. set security manager\n     * 2. set system class loader\n     * 3. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be custom class from\n     * the application classpath or modulepath.\n     */\n    private static void initPhase3() {\n        // set security manager\n        String cn \u003d System.getProperty(\"java.security.manager\");\n        if (cn !\u003d null) {\n            if (cn.isEmpty() || \"default\".equals(cn)) {\n                System.setSecurityManager(new SecurityManager());\n            } else {\n                try {\n                    Class\u003c?\u003e c \u003d Class.forName(cn, false, ClassLoader.getBuiltinAppClassLoader());\n                    Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                    // Must be a public subclass of SecurityManager with\n                    // a public no-arg constructor\n                    if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                        throw new Error(\"Could not create SecurityManager: \" + ctor.toString());\n                    }\n                    // custom security manager implementation may be in unnamed module\n                    // or a named module but non-exported package\n                    ctor.setAccessible(true);\n                    SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                    System.setSecurityManager(sm);\n                } catch (Exception e) {\n                    throw new Error(\"Could not create SecurityManager\", e);\n                }\n            }\n        }\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(ClassLoader cl, String name) {\n                return cl.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Iterator\u003cString\u003e packages) {\n                m.implAddOpensToAllUnnamed(packages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return StringCoding.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return StringCoding.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return StringCoding.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return StringCoding.getBytesUTF8NoRepl(s);\n            }\n\n            public String getLoaderNameID(ClassLoader loader) {\n                return loader !\u003d null ? loader.nameAndId() : \"null\";\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

nov 05, 2024 8:24:31 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

nov 05, 2024 8:24:32 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 501
nov 05, 2024 8:25:21 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 632
2024.11.05 20:25:42 INFO  compiling root (1 scala source)
2024.11.05 20:25:44 INFO  time: compiled root in 1.5s
2024.11.05 20:25:52 INFO  compiling root (1 scala source)
2024.11.05 20:25:54 INFO  time: compiled root in 2.1s
2024.11.05 20:30:07 WARN  Could not find 'responseToDF' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.05 20:30:07 INFO  compiling root (1 scala source)
2024.11.05 20:30:07 WARN  Could not find 'responseToDF' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.05 20:30:07 INFO  time: compiled root in 0.54s
2024.11.05 20:30:30 INFO  compiling root (1 scala source)
2024.11.05 20:30:30 INFO  time: compiled root in 0.29s
nov 05, 2024 8:31:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1157
nov 05, 2024 8:31:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1158
nov 05, 2024 8:31:49 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1348
2024.11.05 20:32:07 INFO  compiling root (1 scala source)
2024.11.05 20:32:08 INFO  time: compiled root in 1.04s
2024.11.05 20:32:18 INFO  compiling root (1 scala source)
2024.11.05 20:32:18 INFO  time: compiled root in 0.89s
2024.11.05 20:32:36 INFO  compiling root (1 scala source)
2024.11.05 20:32:36 INFO  time: compiled root in 0.8s
nov 05, 2024 8:32:44 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1631
2024.11.05 20:32:48 INFO  compiling root (1 scala source)
2024.11.05 20:32:48 INFO  time: compiled root in 0.8s
2024.11.05 20:34:35 INFO  compiling root (1 scala source)
2024.11.05 20:34:35 INFO  time: compiled root in 0.85s
nov 06, 2024 6:40:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1910
nov 06, 2024 6:53:06 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 2277
nov 06, 2024 6:55:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 2410
2024.11.06 18:56:42 INFO  compiling root (1 scala source)
2024.11.06 18:56:43 INFO  time: compiled root in 1.21s
2024.11.06 18:57:10 INFO  compiling root (1 scala source)
2024.11.06 18:57:10 INFO  time: compiled root in 0.87s
2024.11.06 18:57:50 INFO  compiling root (1 scala source)
2024.11.06 18:57:51 INFO  time: compiled root in 1.07s
nov 06, 2024 6:58:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 2705
2024.11.06 18:58:47 INFO  compiling root (1 scala source)
2024.11.06 18:58:47 INFO  time: compiled root in 0.91s
nov 06, 2024 7:01:53 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 2972
2024.11.06 19:02:19 INFO  compiling root (1 scala source)
2024.11.06 19:02:19 INFO  time: compiled root in 0.95s
2024.11.06 19:02:52 INFO  compiling root (1 scala source)
2024.11.06 19:02:52 INFO  time: compiled root in 0.81s
2024.11.06 19:04:37 INFO  compiling root (1 scala source)
2024.11.06 19:04:37 INFO  time: compiled root in 0.86s
2024.11.06 19:05:52 INFO  compiling root (1 scala source)
2024.11.06 19:05:52 INFO  time: compiled root in 0.97s
2024.11.06 19:06:19 INFO  compiling root (1 scala source)
2024.11.06 19:06:19 INFO  time: compiled root in 0.77s
2024.11.06 19:06:45 INFO  compiling root (1 scala source)
2024.11.06 19:06:45 INFO  time: compiled root in 0.77s
2024.11.06 19:14:38 INFO  compiling root (1 scala source)
2024.11.06 19:14:38 INFO  time: compiled root in 0.9s
2024.11.06 19:30:58 INFO  compiling root (1 scala source)
2024.11.06 19:30:59 INFO  time: compiled root in 1.31s
nov 07, 2024 7:11:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3743
nov 07, 2024 7:11:27 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3810
nov 07, 2024 7:11:27 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3812
nov 07, 2024 7:11:27 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3818
nov 07, 2024 7:12:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-notebook-cell:/c%3A/TFG/spark-datos-energia/notebooks/CreacionModelos.ipynb#W0sZmlsZQ%3D%3D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-notebook-cell" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor19.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

nov 07, 2024 7:13:43 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-notebook-cell:/c%3A/Proyectos/spark-datos-energia/notebooks/CreacionModelos.ipynb#W0sZmlsZQ%3D%3D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-notebook-cell" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor19.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

nov 07, 2024 8:01:05 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-notebook-cell:/c%3A/Proyectos/spark-datos-energia/notebooks/CreacionModelos.ipynb#X52sZmlsZQ%3D%3D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-notebook-cell" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor19.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.07 20:01:12 INFO  compiling root (2 scala sources)
2024.11.07 20:01:12 INFO  time: compiled root in 0.43s
2024.11.07 20:01:26 INFO  compiling root (2 scala sources)
2024.11.07 20:01:26 INFO  time: compiled root in 0.22s
2024.11.07 20:02:01 INFO  compiling root (2 scala sources)
2024.11.07 20:02:01 INFO  time: compiled root in 0.26s
2024.11.07 20:02:03 INFO  compiling root (2 scala sources)
2024.11.07 20:02:03 INFO  time: compiled root in 0.31s
2024.11.07 20:02:06 INFO  compiling root (2 scala sources)
2024.11.07 20:02:06 INFO  time: compiled root in 0.2s
2024.11.07 20:02:34 INFO  compiling root (2 scala sources)
2024.11.07 20:02:34 INFO  time: compiled root in 0.21s
2024.11.07 20:02:36 INFO  compiling root (2 scala sources)
2024.11.07 20:02:36 INFO  time: compiled root in 0.23s
2024.11.07 20:02:59 INFO  compiling root (2 scala sources)
2024.11.07 20:02:59 INFO  time: compiled root in 0.2s
nov 07, 2024 8:05:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-notebook-cell:/c%3A/Proyectos/spark-datos-energia/notebooks/.ipynb_checkpoints/CreacionModelos-checkpoint.ipynb#W0sZmlsZQ%3D%3D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-notebook-cell" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor19.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

nov 07, 2024 8:05:56 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-notebook-cell:/c%3A/Proyectos/spark-datos-energia/notebooks/.ipynb_checkpoints/Prueba-checkpoint.ipynb#W0sZmlsZQ%3D%3D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-notebook-cell" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor19.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

nov 07, 2024 8:07:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-notebook-cell:/c%3A/Proyectos/spark-datos-energia/notebooks/.ipynb_checkpoints/CreacionModelos-checkpoint.ipynb#X56sZmlsZQ%3D%3D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-notebook-cell" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor19.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

nov 07, 2024 8:07:17 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-notebook-cell:/c%3A/Proyectos/spark-datos-energia/notebooks/.ipynb_checkpoints/CreacionModelos-checkpoint.ipynb#X56sZmlsZQ%3D%3D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-notebook-cell" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor19.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

nov 07, 2024 8:07:26 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-notebook-cell:/c%3A/Proyectos/spark-datos-energia/notebooks/.ipynb_checkpoints/CreacionModelos-checkpoint.ipynb#X56sZmlsZQ%3D%3D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-notebook-cell" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor19.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

nov 07, 2024 8:07:26 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-notebook-cell:/c%3A/Proyectos/spark-datos-energia/notebooks/.ipynb_checkpoints/CreacionModelos-checkpoint.ipynb#X56sZmlsZQ%3D%3D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-notebook-cell" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor19.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

nov 07, 2024 8:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-notebook-cell:/c%3A/Proyectos/spark-datos-energia/notebooks/.ipynb_checkpoints/CreacionModelos-checkpoint.ipynb#X52sZmlsZQ%3D%3D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-notebook-cell" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor19.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.07 20:07:44 INFO  compiling root (2 scala sources)
2024.11.07 20:07:44 INFO  time: compiled root in 0.25s
2024.11.07 20:08:00 INFO  compiling root (2 scala sources)
2024.11.07 20:08:01 INFO  time: compiled root in 1.1s
2024.11.07 20:08:05 INFO  compiling root (1 scala source)
2024.11.07 20:08:05 INFO  time: compiled root in 0.83s
2024.11.07 20:08:07 INFO  compiling root (2 scala sources)
2024.11.07 20:08:07 INFO  time: compiled root in 0.19s
nov 07, 2024 8:09:02 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-notebook-cell:/c%3A/Proyectos/spark-datos-energia/notebooks/.ipynb_checkpoints/CreacionModelos-checkpoint.ipynb#X52sZmlsZQ%3D%3D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-notebook-cell" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor19.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

nov 07, 2024 8:09:06 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "vscode-notebook-cell:/c%3A/Proyectos/spark-datos-energia/notebooks/.ipynb_checkpoints/Prueba-checkpoint.ipynb#W0sZmlsZQ%3D%3D"
  ]
}
java.nio.file.FileSystemNotFoundException: Provider "vscode-notebook-cell" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:130)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:187)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor19.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.11.07 20:12:00 INFO  compiling root (2 scala sources)
2024.11.07 20:12:00 INFO  time: compiled root in 0.25s
2024.11.07 20:12:26 INFO  compiling root (1 scala source)
2024.11.07 20:12:26 INFO  time: compiled root in 0.84s
2024.11.07 21:16:12 INFO  compiling root (1 scala source)
2024.11.07 21:16:12 INFO  time: compiled root in 0.29s
2024.11.07 21:16:50 INFO  compiling root (1 scala source)
2024.11.07 21:16:51 INFO  time: compiled root in 1.04s
2024.11.07 21:22:58 INFO  compiling root (1 scala source)
2024.11.07 21:22:59 INFO  time: compiled root in 1.1s
2024.11.11 12:43:14 INFO  Started: Metals version 1.4.0 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.95.0.
2024.11.11 12:43:19 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.11 12:43:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.11 12:43:19 INFO  Attempting to connect to the build server...
2024.11.11 12:43:19 INFO  No running Bloop server found, starting one.
2024.11.11 12:43:21 INFO  Starting compilation server
2024.11.11 12:43:26 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.11 12:43:27 INFO  Attempting to connect to the build server...
2024.11.11 12:43:27 INFO  Found a Bloop server running
2024.11.11 12:43:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.11 12:43:27 INFO  time: Connected to build server in 8.18s
2024.11.11 12:43:27 INFO  Connected to Build server: Bloop v2.0.3
2024.11.11 12:43:27 INFO  time: Imported build in 0.21s
2024.11.11 12:43:27 INFO  running doctor check
2024.11.11 12:43:27 INFO  java targets: spark-datos-energia-build, root-test, root
2024.11.11 12:43:42 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.11 12:43:55 INFO  time: indexed workspace in 27s
2024.11.13 16:16:25 INFO  Started: Metals version 1.4.0 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.95.0.
2024.11.13 16:16:29 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.13 16:16:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.13 16:16:29 INFO  Attempting to connect to the build server...
2024.11.13 16:16:29 INFO  No running Bloop server found, starting one.
2024.11.13 16:16:31 INFO  Starting compilation server
2024.11.13 16:16:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.13 16:16:35 INFO  Attempting to connect to the build server...
2024.11.13 16:16:35 INFO  Found a Bloop server running
2024.11.13 16:16:36 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.13 16:16:35 INFO  time: Connected to build server in 6.6s
2024.11.13 16:16:35 INFO  Connected to Build server: Bloop v2.0.3
2024.11.13 16:16:36 INFO  time: Imported build in 0.17s
2024.11.13 16:16:36 INFO  running doctor check
2024.11.13 16:16:36 INFO  java targets: spark-datos-energia-build, root-test, root
2024.11.13 16:16:50 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.13 16:17:04 INFO  time: indexed workspace in 27s
2024.11.13 16:31:34 INFO  Shutting down server
2024.11.13 16:31:34 INFO  shutting down Metals
2024.11.13 16:31:34 INFO  Shut down connection with build server.
2024.11.13 16:31:34 INFO  Shut down connection with build server.
2024.11.13 16:31:34 INFO  Exiting server
2024.11.13 16:31:46 INFO  Started: Metals version 1.4.0 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.95.2.
2024.11.13 16:31:46 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.13 16:31:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\BalanceDownloader.scala. Using presentation compiler with project's scala-library version: 3.3.4
2024.11.13 16:31:47 INFO  Attempting to connect to the build server...
2024.11.13 16:31:47 INFO  Found a Bloop server running
2024.11.13 16:31:47 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.13 16:31:48 INFO  Attempting to connect to the build server...
2024.11.13 16:31:48 INFO  Found a Bloop server running
2024.11.13 16:31:48 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.13 16:31:47 INFO  time: Connected to build server in 1.35s
2024.11.13 16:31:47 INFO  Connected to Build server: Bloop v2.0.3
2024.11.13 16:31:48 INFO  time: Imported build in 0.2s
2024.11.13 16:31:48 INFO  running doctor check
2024.11.13 16:31:48 INFO  java targets: spark-datos-energia-build, root-test, root
2024.11.13 16:31:51 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.13 16:31:54 INFO  time: indexed workspace in 5.57s
nov 13, 2024 7:28:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 68
nov 13, 2024 7:28:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 70
nov 13, 2024 7:28:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 76
nov 13, 2024 7:28:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 79
nov 13, 2024 7:34:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1181
nov 13, 2024 7:35:41 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1732
nov 13, 2024 7:38:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 2760
nov 13, 2024 7:40:05 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3542
nov 13, 2024 7:41:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3787
nov 13, 2024 7:42:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4020
2024.11.13 19:45:13 INFO  compiling root (1 scala source)
2024.11.13 19:45:15 INFO  time: compiled root in 1.98s
2024.11.13 19:46:44 INFO  compiling root (1 scala source)
2024.11.13 19:46:53 INFO  time: compiled root in 8.81s
2024.11.13 19:47:29 INFO  compiling root (1 scala source)
2024.11.13 19:47:30 INFO  time: compiled root in 1.16s
2024.11.13 19:47:56 INFO  compiling root (1 scala source)
2024.11.13 19:47:56 INFO  time: compiled root in 0.91s
nov 13, 2024 7:50:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5887
2024.11.13 19:50:19 INFO  compiling root (1 scala source)
2024.11.13 19:50:19 INFO  time: compiled root in 0.92s
2024.11.13 19:50:52 INFO  compiling root (1 scala source)
2024.11.13 19:50:52 INFO  time: compiled root in 0.91s
2024.11.13 19:53:23 INFO  compiling root (1 scala source)
2024.11.13 19:53:23 INFO  time: compiled root in 0.86s
2024.11.13 19:53:58 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala
2024.11.13 19:53:58 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala
2024.11.13 19:53:58 INFO  compiling root (1 scala source)
2024.11.13 19:53:58 INFO  time: compiled root in 0.29s
2024.11.13 19:53:59 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala
2024.11.13 19:54:11 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala
2024.11.13 19:54:12 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala
2024.11.13 19:54:14 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala
2024.11.13 19:54:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala
2024.11.13 19:55:00 INFO  compiling root (1 scala source)
2024.11.13 19:55:00 INFO  time: compiled root in 0.87s
2024.11.18 18:05:25 INFO  compiling root (1 scala source)
2024.11.18 18:05:25 INFO  time: compiled root in 0.46s
2024.11.18 18:05:32 INFO  compiling root (1 scala source)
2024.11.18 18:05:32 INFO  time: compiled root in 0.95s
2024.11.18 18:07:40 INFO  compiling root (1 scala source)
2024.11.18 18:07:40 INFO  time: compiled root in 0.81s
nov 18, 2024 6:08:51 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6657
nov 18, 2024 6:08:57 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6725
2024.11.18 18:09:10 INFO  compiling root (1 scala source)
2024.11.18 18:09:10 INFO  time: compiled root in 0.3s
2024.11.18 18:09:21 INFO  compiling root (1 scala source)
2024.11.18 18:09:21 INFO  time: compiled root in 0.74s
2024.11.18 18:11:26 INFO  compiling root (1 scala source)
2024.11.18 18:11:27 INFO  time: compiled root in 1.5s
2024.11.18 18:16:50 INFO  compiling root (1 scala source)
2024.11.18 18:16:50 INFO  time: compiled root in 0.88s
nov 18, 2024 7:15:01 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 7562
2024.11.18 19:15:01 INFO  compiling root (1 scala source)
2024.11.18 19:15:01 INFO  time: compiled root in 0.93s
2024.11.19 17:57:56 INFO  compiling root (1 scala source)
2024.11.19 17:57:56 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala
2024.11.19 17:57:57 INFO  time: compiled root in 1.28s
2024.11.19 18:54:08 INFO  compiling root (1 scala source)
2024.11.19 18:54:08 INFO  time: compiled root in 0.51s
nov 19, 2024 6:54:20 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 7862
2024.11.19 18:54:43 INFO  compiling root (1 scala source)
2024.11.19 18:54:43 INFO  time: compiled root in 0.28s
nov 19, 2024 6:54:50 P. M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMACIÓN: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
nov 19, 2024 6:54:50 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-11-19\r_compiler-error_(root)_18-54-50-617.md
2024.11.19 18:54:54 INFO  compiling root (1 scala source)
2024.11.19 18:54:54 INFO  time: compiled root in 0.88s
2024.11.19 18:54:56 INFO  compiling root (1 scala source)
2024.11.19 18:54:56 INFO  time: compiled root in 0.4s
2024.11.19 18:55:36 INFO  compiling root (1 scala source)
2024.11.19 18:55:36 INFO  time: compiled root in 0.28s
2024.11.19 18:55:40 INFO  compiling root (1 scala source)
2024.11.19 18:55:40 INFO  time: compiled root in 0.29s
2024.11.19 18:55:44 INFO  compiling root (1 scala source)
2024.11.19 18:55:44 INFO  time: compiled root in 0.24s
nov 19, 2024 6:55:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 8090
2024.11.19 18:55:52 INFO  compiling root (1 scala source)
2024.11.19 18:55:52 INFO  time: compiled root in 0.24s
2024.11.19 18:56:02 INFO  compiling root (1 scala source)
2024.11.19 18:56:02 INFO  time: compiled root in 0.23s
2024.11.19 18:56:10 INFO  compiling root (1 scala source)
2024.11.19 18:56:10 INFO  time: compiled root in 0.25s
2024.11.19 18:56:21 INFO  compiling root (1 scala source)
2024.11.19 18:56:21 INFO  time: compiled root in 0.69s
2024.11.19 18:56:21 INFO  compiling root (2 scala sources)
2024.11.19 18:56:21 INFO  time: compiled root in 84ms
2024.11.19 18:56:46 INFO  compiling root (3 scala sources)
2024.11.19 18:56:46 INFO  time: compiled root in 0.19s
2024.11.19 18:58:39 INFO  compiling root (3 scala sources)
2024.11.19 18:58:39 INFO  time: compiled root in 0.27s
2024.11.19 18:58:57 INFO  compiling root (3 scala sources)
2024.11.19 18:58:58 INFO  time: compiled root in 1.18s
2024.11.19 19:01:19 INFO  compiling root (1 scala source)
2024.11.19 19:01:19 INFO  time: compiled root in 0.84s
2024.11.19 19:04:33 INFO  compiling root (1 scala source)
2024.11.19 19:04:33 INFO  time: compiled root in 0.75s
2024.11.19 19:19:46 INFO  compiling root (1 scala source)
2024.11.19 19:19:46 INFO  time: compiled root in 0.92s
2024.11.19 19:20:08 INFO  compiling root (1 scala source)
2024.11.19 19:20:08 INFO  time: compiled root in 0.68s
2024.11.19 19:20:40 INFO  compiling root (1 scala source)
2024.11.19 19:20:40 INFO  time: compiled root in 0.68s
2024.11.19 19:22:58 INFO  compiling root (1 scala source)
2024.11.19 19:22:58 INFO  time: compiled root in 0.54s
2024.11.19 19:23:48 INFO  compiling root (1 scala source)
2024.11.19 19:23:48 INFO  time: compiled root in 0.32s
2024.11.19 19:24:14 INFO  compiling root (1 scala source)
2024.11.19 19:24:14 INFO  time: compiled root in 0.28s
nov 19, 2024 7:26:10 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 10060
2024.11.19 19:26:18 INFO  compiling root (1 scala source)
2024.11.19 19:26:18 INFO  time: compiled root in 0.64s
2024.11.19 19:27:10 INFO  compiling root (1 scala source)
2024.11.19 19:27:10 INFO  time: compiled root in 0.34s
2024.11.19 19:29:10 INFO  compiling root (1 scala source)
2024.11.19 19:29:10 INFO  time: compiled root in 0.34s
2024.11.19 19:29:19 INFO  compiling root (1 scala source)
2024.11.19 19:29:19 INFO  time: compiled root in 0.2s
2024.11.19 19:29:27 INFO  compiling root (1 scala source)
2024.11.19 19:29:27 INFO  time: compiled root in 0.18s
2024.11.19 19:29:38 INFO  compiling root (1 scala source)
2024.11.19 19:29:38 INFO  time: compiled root in 0.28s
2024.11.19 19:29:49 INFO  compiling root (1 scala source)
2024.11.19 19:29:49 INFO  time: compiled root in 0.18s
2024.11.19 19:29:58 INFO  compiling root (1 scala source)
2024.11.19 19:29:58 INFO  time: compiled root in 0.27s
2024.11.19 19:31:16 INFO  compiling root (1 scala source)
2024.11.19 19:31:16 INFO  time: compiled root in 0.36s
2024.11.19 19:31:18 INFO  compiling root (1 scala source)
2024.11.19 19:31:18 INFO  time: compiled root in 0.32s
nov 19, 2024 7:32:11 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 10559
2024.11.19 19:32:15 INFO  compiling root (1 scala source)
2024.11.19 19:32:15 INFO  time: compiled root in 0.31s
2024.11.19 19:32:59 WARN  Could not find 'String' using presentation compiler nor semanticdb. Trying to guess the definition using available information from local class context. 
2024.11.19 19:33:22 INFO  compiling root (1 scala source)
2024.11.19 19:33:22 INFO  time: compiled root in 0.33s
2024.11.19 19:33:51 INFO  compiling root (1 scala source)
2024.11.19 19:33:51 INFO  time: compiled root in 0.27s
Exception in thread "pool-6-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.11.19 19:34:54 INFO  compiling root (1 scala source)
2024.11.19 19:34:54 INFO  time: compiled root in 0.31s
2024.11.19 19:39:29 INFO  compiling root (1 scala source)
2024.11.19 19:39:31 INFO  time: compiled root in 1.56s
nov 19, 2024 7:39:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 10894
2024.11.19 19:39:39 INFO  compiling root (1 scala source)
2024.11.19 19:39:40 INFO  time: compiled root in 1.06s
2024.11.19 19:40:05 INFO  compiling root (1 scala source)
2024.11.19 19:40:05 INFO  time: compiled root in 0.86s
nov 20, 2024 2:13:46 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 11340
2024.11.20 14:14:00 INFO  compiling root (1 scala source)
2024.11.20 14:14:01 INFO  time: compiled root in 1.42s
2024.11.20 14:16:36 INFO  compiling root (1 scala source)
2024.11.20 14:16:36 INFO  time: compiled root in 0.32s
2024.11.20 14:16:48 INFO  compiling root (1 scala source)
2024.11.20 14:16:48 INFO  time: compiled root in 0.87s
nov 20, 2024 6:26:41 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 12601
nov 20, 2024 6:26:42 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 12615
2024.11.20 18:27:52 INFO  compiling root (1 scala source)
2024.11.20 18:27:52 INFO  time: compiled root in 0.45s
2024.11.20 18:28:03 INFO  compiling root (1 scala source)
2024.11.20 18:28:03 INFO  time: compiled root in 0.32s
nov 20, 2024 6:28:41 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 13252
nov 20, 2024 6:28:41 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 13263
nov 20, 2024 6:28:42 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 13298
2024.11.20 18:31:37 INFO  compiling root (1 scala source)
2024.11.20 18:31:37 INFO  time: compiled root in 0.33s
2024.11.20 18:31:59 INFO  compiling root (1 scala source)
2024.11.20 18:31:59 INFO  time: compiled root in 0.96s
nov 20, 2024 6:32:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 13915
2024.11.20 18:32:14 INFO  compiling root (1 scala source)
2024.11.20 18:32:14 INFO  time: compiled root in 0.81s
nov 20, 2024 6:33:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 14270
2024.11.20 18:33:39 INFO  compiling root (1 scala source)
2024.11.20 18:33:39 INFO  time: compiled root in 0.93s
nov 20, 2024 6:37:20 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 14502
2024.11.20 18:38:40 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:757)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

nov 20, 2024 6:38:40 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2022, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.nio.charset.CharacterCodingException;\nimport java.security.AccessControlContext;\nimport java.security.ProtectionDomain;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\n\nimport jdk.internal.logger.LoggerFinderLoader.TemporaryLoggerFinder;\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.HotSpotIntrinsicCandidate;\nimport jdk.internal.misc.JavaLangAccess;\nimport jdk.internal.misc.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport sun.nio.fs.DefaultFileSystemProvider;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * VM will invoke the initializeSystemClass method to complete\n     * the initialization for this class separated from clinit.\n     * Note that to use properties set by the VM, see the constraints\n     * described in the initializeSystemClass method.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user.\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     */\n    public static final PrintStream err \u003d null;\n\n    /* The security manager for the system.\n     */\n    private static volatile SecurityManager security;\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    /**\n     * Sets the System security.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @param      s   the security manager.\n     * @throws     SecurityException  if the security manager has already\n     *             been set and its {@code checkPermission} method\n     *             doesn\u0027t allow it to be replaced.\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     */\n    public static void setSecurityManager(final SecurityManager s) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n            // ensure the default file system is initialized\n            DefaultFileSystemProvider.theFileSystem();\n        }\n        if (s !\u003d null) {\n            try {\n                s.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(s);\n    }\n\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission\n                                     (\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Cause policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system security interface.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     */\n    public static SecurityManager getSecurityManager() {\n        return security;\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @HotSpotIntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @HotSpotIntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @HotSpotIntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @HotSpotIntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties. The following properties are guaranteed to be defined:\n     * \u003cdl\u003e\n     * \u003cdt\u003ejava.version         \u003cdd\u003eJava version number\n     * \u003cdt\u003ejava.version.date    \u003cdd\u003eJava version date\n     * \u003cdt\u003ejava.vendor          \u003cdd\u003eJava vendor specific string\n     * \u003cdt\u003ejava.vendor.url      \u003cdd\u003eJava vendor URL\n     * \u003cdt\u003ejava.vendor.version  \u003cdd\u003eJava vendor version\n     * \u003cdt\u003ejava.home            \u003cdd\u003eJava installation directory\n     * \u003cdt\u003ejava.class.version   \u003cdd\u003eJava class version number\n     * \u003cdt\u003ejava.class.path      \u003cdd\u003eJava classpath\n     * \u003cdt\u003eos.name              \u003cdd\u003eOperating System Name\n     * \u003cdt\u003eos.arch              \u003cdd\u003eOperating System Architecture\n     * \u003cdt\u003eos.version           \u003cdd\u003eOperating System Version\n     * \u003cdt\u003efile.separator       \u003cdd\u003eFile separator (\"/\" on Unix)\n     * \u003cdt\u003epath.separator       \u003cdd\u003ePath separator (\":\" on Unix)\n     * \u003cdt\u003eline.separator       \u003cdd\u003eLine separator (\"\\n\" on Unix)\n     * \u003cdt\u003euser.name            \u003cdd\u003eUser account name\n     * \u003cdt\u003euser.home            \u003cdd\u003eUser home directory\n     * \u003cdt\u003euser.dir             \u003cdd\u003eUser\u0027s current working directory\n     * \u003c/dl\u003e\n     */\n\n    private static Properties props;\n    private static native Properties initProperties(Properties props);\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties always includes values\n     * for the following keys:\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.specification.maintenance.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification maintenance version,\n     *     may be interpreted as a positive integer \u003cem\u003e(optional, see below)\u003c/em\u003e\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * The {@code java.specification.maintenance.version} property is\n     * defined if the specification implemented by this runtime at the\n     * time of its construction had undergone a \u003ca\n     * href\u003d\"https://jcp.org/en/procedures/jcp2#3.6.4\"\u003emaintenance\n     * release\u003c/a\u003e. When defined, its value identifies that\n     * maintenance release. To indicate the first maintenance release\n     * this property will have the value {@code \"1\"}, to indicate the\n     * second maintenance release this property will have the value\n     * {@code \"2\"}, and so on.\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n        if (props \u003d\u003d null) {\n            props \u003d new Properties();\n            initProperties(props);\n            System.props \u003d props;\n            VersionProps.init();\n        } else {\n            System.props \u003d props;\n        }\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.equals(\"\")) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            LoggerFinder finder \u003d service;\n            if (finder \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                finder \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n                if (finder instanceof TemporaryLoggerFinder) return finder;\n                service \u003d finder;\n            }\n            return finder;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector.\n     *\n     * Calling the {@code gc} method suggests that the Java Virtual\n     * Machine expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for quick reuse.\n     * When control returns from the method call, the Java Virtual\n     * Machine has made a best effort to reclaim space from all discarded\n     * objects.\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an implementation-\n     * dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization, in which it may need access, via\n        // System.getProperty(), to the related system encoding property that\n        // have been initialized (put into \"props\") at early stage of the\n        // initialization. So make sure the \"props\" is available at the\n        // very beginning of the initialization and all system properties to\n        // be put into it directly.\n        props \u003d new Properties(84);\n        initProperties(props);  // initialized by the VM\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // removed from the system properties.\n        //\n        // See java.lang.Integer.IntegerCache and the\n        // VM.saveAndRemoveProperties method for example.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.  Remove\n        // certain system properties that are not intended for public access.\n        VM.saveAndRemoveProperties(props);\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n        VersionProps.init();\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n        // register shared secrets\n        setJavaLangAccess();\n\n        ClassLoader.initLibraryPaths();\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. set security manager\n     * 2. set system class loader\n     * 3. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be custom class from\n     * the application classpath or modulepath.\n     */\n    private static void initPhase3() {\n        // set security manager\n        String cn \u003d System.getProperty(\"java.security.manager\");\n        if (cn !\u003d null) {\n            if (cn.isEmpty() || \"default\".equals(cn)) {\n                System.setSecurityManager(new SecurityManager());\n            } else {\n                try {\n                    Class\u003c?\u003e c \u003d Class.forName(cn, false, ClassLoader.getBuiltinAppClassLoader());\n                    Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                    // Must be a public subclass of SecurityManager with\n                    // a public no-arg constructor\n                    if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                        throw new Error(\"Could not create SecurityManager: \" + ctor.toString());\n                    }\n                    // custom security manager implementation may be in unnamed module\n                    // or a named module but non-exported package\n                    ctor.setAccessible(true);\n                    SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                    System.setSecurityManager(sm);\n                } catch (Exception e) {\n                    throw new Error(\"Could not create SecurityManager\", e);\n                }\n            }\n        }\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(ClassLoader cl, String name) {\n                return cl.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Iterator\u003cString\u003e packages) {\n                m.implAddOpensToAllUnnamed(packages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return StringCoding.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return StringCoding.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return StringCoding.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return StringCoding.getBytesUTF8NoRepl(s);\n            }\n\n            public String getLoaderNameID(ClassLoader loader) {\n                return loader !\u003d null ? loader.nameAndId() : \"null\";\n            }\n        });\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor29.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

nov 20, 2024 6:38:41 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:774)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:771)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/System.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

nov 20, 2024 6:38:41 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 14612
nov 20, 2024 6:38:41 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 14614
nov 20, 2024 6:38:41 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 14613
nov 20, 2024 6:40:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 14952
nov 20, 2024 6:40:33 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 15098
2024.11.20 18:43:05 INFO  compiling root (1 scala source)
2024.11.20 18:43:06 INFO  time: compiled root in 1.08s
nov 20, 2024 6:43:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 15493
something's wrong: no file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/RegionesBalanceDownloader.scala in org.apache.spark.sql.Dataset[<error>]RangePosition(file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/RegionesBalanceDownloader.scala, 1063, 1063, 1080)
something's wrong: no file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/RegionesBalanceDownloader.scala in org.apache.spark.sql.Dataset[<error>]RangePosition(file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/RegionesBalanceDownloader.scala, 1063, 1063, 1074)
something's wrong: no file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/RegionesBalanceDownloader.scala in org.apache.spark.sql.Dataset[<error>]RangePosition(file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/RegionesBalanceDownloader.scala, 1063, 1063, 1078)
something's wrong: no file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/RegionesBalanceDownloader.scala in org.apache.spark.sql.Dataset[<error>]RangePosition(file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/RegionesBalanceDownloader.scala, 1063, 1063, 1076)
2024.11.20 18:49:02 INFO  compiling root (1 scala source)
2024.11.20 18:49:02 INFO  time: compiled root in 0.99s
2024.11.20 18:52:19 INFO  compiling root (1 scala source)
2024.11.20 18:52:19 INFO  time: compiled root in 0.34s
nov 20, 2024 6:52:24 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 16926
2024.11.20 18:52:31 INFO  compiling root (1 scala source)
2024.11.20 18:52:31 INFO  time: compiled root in 0.29s
2024.11.20 18:52:41 INFO  compiling root (1 scala source)
2024.11.20 18:52:42 INFO  time: compiled root in 1s
2024.11.20 18:53:55 INFO  compiling root (1 scala source)
2024.11.20 18:53:55 INFO  time: compiled root in 0.33s
2024.11.20 18:54:12 INFO  compiling root (1 scala source)
2024.11.20 18:54:12 INFO  time: compiled root in 0.27s
2024.11.20 18:54:49 INFO  compiling root (1 scala source)
2024.11.20 18:54:49 INFO  time: compiled root in 0.35s
2024.11.20 18:54:50 INFO  compiling root (1 scala source)
2024.11.20 18:54:50 INFO  time: compiled root in 0.28s
2024.11.20 18:55:02 INFO  compiling root (1 scala source)
2024.11.20 18:55:02 INFO  time: compiled root in 0.95s
2024.11.20 18:56:08 INFO  compiling root (1 scala source)
2024.11.20 18:56:08 INFO  time: compiled root in 0.95s
2024.11.20 18:56:43 INFO  compiling root (1 scala source)
2024.11.20 18:56:43 INFO  time: compiled root in 0.35s
nov 20, 2024 6:56:47 P. M. scala.meta.internal.pc.CompletionProvider expected$1
ADVERTENCIA: offset 2798, count -1, length 5436
2024.11.20 18:57:20 INFO  compiling root (1 scala source)
2024.11.20 18:57:20 INFO  time: compiled root in 0.36s
nov 20, 2024 6:57:26 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 17890
2024.11.20 18:57:43 INFO  compiling root (1 scala source)
2024.11.20 18:57:43 INFO  time: compiled root in 0.96s
2024.11.20 18:58:28 INFO  compiling root (1 scala source)
2024.11.20 18:58:29 INFO  time: compiled root in 1.02s
2024.11.20 18:58:37 INFO  compiling root (1 scala source)
2024.11.20 18:58:37 INFO  time: compiled root in 0.89s
2024.11.20 19:04:50 INFO  Shutting down server
2024.11.20 19:04:50 INFO  shutting down Metals
2024.11.20 19:04:50 INFO  Shut down connection with build server.
2024.11.20 19:04:50 INFO  Shut down connection with build server.
2024.11.20 19:04:50 INFO  Exiting server
2024.11.20 19:05:05 INFO  Started: Metals version 1.4.1 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.95.2.
2024.11.20 19:05:05 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.20 19:05:06 INFO  Attempting to connect to the build server...
2024.11.20 19:05:06 INFO  Found a Bloop server running
2024.11.20 19:05:07 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.20 19:05:07 INFO  Attempting to connect to the build server...
2024.11.20 19:05:07 INFO  Found a Bloop server running
2024.11.20 19:05:08 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.20 19:05:08 INFO  time: Connected to build server in 1.31s
2024.11.20 19:05:08 INFO  Connected to Build server: Bloop v2.0.3
2024.11.20 19:05:07 INFO  time: Imported build in 0.12s
2024.11.20 19:05:07 INFO  running doctor check
2024.11.20 19:05:07 INFO  java targets: spark-datos-energia-build, root-test, root
2024.11.20 19:05:13 INFO  compiling root (1 scala source)
2024.11.20 19:05:14 WARN  Flyway upgrade recommended: H2 2.3.232 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.224.
2024.11.20 19:05:15 INFO  time: compiled root in 1.35s
2024.11.20 19:05:28 INFO  time: indexed workspace in 20s
2024.11.20 19:05:56 INFO  Disconnecting from Bloop session...
2024.11.20 19:05:56 INFO  Shut down connection with build server.
2024.11.20 19:05:56 INFO  Shut down connection with build server.
2024.11.20 19:05:56 INFO  Attempting to connect to the build server...
2024.11.20 19:05:56 INFO  No running Bloop server found, starting one.
2024.11.20 19:05:59 INFO  Starting compilation server
2024.11.20 19:06:01 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.20 19:06:02 INFO  Attempting to connect to the build server...
2024.11.20 19:06:02 INFO  Found a Bloop server running
2024.11.20 19:06:02 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.11.20 19:06:01 INFO  time: Connected to build server in 6.4s
2024.11.20 19:06:01 INFO  Connected to Build server: Bloop v2.0.5
2024.11.20 19:06:03 INFO  time: Imported build in 0.17s
2024.11.20 19:06:03 INFO  running doctor check
2024.11.20 19:06:03 INFO  java targets: spark-datos-energia-build, root-test, root
2024.11.20 19:06:06 INFO  time: indexed workspace in 3.59s
nov 20, 2024 7:13:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 340
nov 20, 2024 7:13:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 338
nov 20, 2024 7:15:53 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 910
nov 20, 2024 7:15:53 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 911
2024.11.20 19:16:05 INFO  compiling root (1 scala source)
2024.11.20 19:16:07 INFO  time: compiled root in 2.17s
2024.11.20 19:16:13 INFO  compiling root (1 scala source)
2024.11.20 19:16:13 INFO  time: compiled root in 0.57s
2024.11.20 19:16:59 INFO  compiling root (1 scala source)
2024.11.20 19:16:59 INFO  time: compiled root in 0.56s
2024.11.20 19:18:00 INFO  compiling root (1 scala source)
2024.11.20 19:18:00 INFO  time: compiled root in 0.47s
nov 20, 2024 7:19:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1585
2024.11.20 19:19:37 INFO  compiling root (1 scala source)
2024.11.20 19:19:37 INFO  time: compiled root in 0.42s
2024.11.20 19:19:56 INFO  compiling root (1 scala source)
2024.11.20 19:19:56 INFO  time: compiled root in 0.37s
2024.11.20 19:20:14 INFO  compiling root (1 scala source)
2024.11.20 19:20:16 INFO  time: compiled root in 1.85s
2024.11.20 19:20:33 INFO  compiling root (1 scala source)
2024.11.20 19:20:34 INFO  time: compiled root in 1.18s
2024.11.20 19:21:06 INFO  compiling root (1 scala source)
2024.11.20 19:21:07 INFO  time: compiled root in 1.17s
2024.11.20 19:22:28 INFO  compiling root (1 scala source)
2024.11.20 19:22:28 INFO  time: compiled root in 0.4s
nov 20, 2024 7:23:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 2520
2024.11.20 19:26:11 INFO  compiling root (1 scala source)
2024.11.20 19:26:11 INFO  time: compiled root in 0.38s
2024.11.20 19:26:14 INFO  compiling root (1 scala source)
2024.11.20 19:26:14 INFO  time: compiled root in 0.32s
2024.11.20 19:26:16 INFO  compiling root (1 scala source)
2024.11.20 19:26:16 INFO  time: compiled root in 0.37s
2024.11.20 19:26:18 INFO  compiling root (1 scala source)
2024.11.20 19:26:18 INFO  time: compiled root in 0.36s
2024.11.20 19:27:36 INFO  compiling root (1 scala source)
2024.11.20 19:27:36 INFO  time: compiled root in 0.37s
2024.11.20 19:27:44 INFO  compiling root (1 scala source)
2024.11.20 19:27:44 INFO  time: compiled root in 0.32s
nov 20, 2024 7:27:45 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 2990
2024.11.20 19:27:56 INFO  compiling root (1 scala source)
2024.11.20 19:27:56 INFO  time: compiled root in 0.32s
nov 20, 2024 7:28:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3057
2024.11.20 19:28:10 INFO  compiling root (1 scala source)
2024.11.20 19:28:10 INFO  time: compiled root in 0.29s
2024.11.20 19:30:54 INFO  compiling root (1 scala source)
2024.11.20 19:30:54 INFO  time: compiled root in 0.4s
nov 20, 2024 7:33:33 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-11-20\r_compiler-error_(root)_19-33-33-962.md
2024.11.20 19:33:33 WARN  Could not find semantic tokens for: file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/RegionesBalanceDownloader.scala
2024.11.20 19:33:47 INFO  compiling root (1 scala source)
2024.11.20 19:33:47 INFO  time: compiled root in 0.37s
2024.11.20 19:34:06 INFO  compiling root (1 scala source)
2024.11.20 19:34:07 INFO  time: compiled root in 1.19s
2024.11.20 19:35:53 INFO  compiling root (1 scala source)
2024.11.20 19:35:54 INFO  time: compiled root in 1.08s
2024.11.20 19:36:44 INFO  compiling root (1 scala source)
2024.11.20 19:36:45 INFO  time: compiled root in 1s
2024.11.20 19:36:58 INFO  compiling root (1 scala source)
2024.11.20 19:36:58 INFO  time: compiled root in 0.26s
2024.11.20 19:37:04 INFO  compiling root (1 scala source)
2024.11.20 19:37:04 INFO  time: compiled root in 0.93s
nov 20, 2024 7:37:44 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4666
2024.11.20 19:37:58 INFO  compiling root (1 scala source)
2024.11.20 19:37:58 INFO  time: compiled root in 0.95s
2024.11.20 19:38:42 INFO  compiling root (1 scala source)
2024.11.20 19:38:43 INFO  time: compiled root in 1s
nov 20, 2024 7:56:16 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5919
2024.11.20 21:20:34 INFO  compiling root (1 scala source)
2024.11.20 21:20:35 INFO  time: compiled root in 1.21s
2024.11.20 21:20:35 INFO  compiling root (1 scala source)
2024.11.20 21:20:35 INFO  time: compiled root in 0.33s
2024.11.20 21:21:58 INFO  compiling root (1 scala source)
2024.11.20 21:21:58 INFO  time: compiled root in 0.38s
2024.11.20 21:22:14 INFO  compiling root (2 scala sources)
2024.11.20 21:22:14 INFO  time: compiled root in 0.33s
nov 20, 2024 9:22:28 P. M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMACIÓN: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
nov 20, 2024 9:22:37 P. M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMACIÓN: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
nov 20, 2024 9:22:41 P. M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMACIÓN: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
nov 20, 2024 9:23:34 P. M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMACIÓN: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.11.20 21:23:50 INFO  compiling root (2 scala sources)
2024.11.20 21:23:51 INFO  time: compiled root in 1.12s
2024.11.20 21:25:40 INFO  compiling root (1 scala source)
2024.11.20 21:25:41 INFO  time: compiled root in 1.02s
2024.11.21 13:38:44 INFO  compiling root (1 scala source)
2024.11.21 13:38:45 INFO  time: compiled root in 1.43s
2024.11.21 13:38:56 INFO  compiling root (1 scala source)
2024.11.21 13:38:56 INFO  time: compiled root in 0.95s
