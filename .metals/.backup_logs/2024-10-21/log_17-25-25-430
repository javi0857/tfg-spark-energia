2024.10.11 20:45:23 INFO  Started: Metals version 1.3.5 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.94.2.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@715d48f4]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@24250cb0]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@715d48f4]
2024.10.11 20:45:24 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.11 20:45:41 INFO  running 'C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals14738877386896704440\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.11 20:45:42 INFO  [info] welcome to sbt 1.10.2 (Oracle Corporation Java 1.8.0_202)
2024.10.11 20:45:42 INFO  [info] loading global plugins from C:\Users\jalva\.sbt\1.0\plugins
2024.10.11 20:45:45 INFO  [info] loading settings for project spark-datos-energia-build-build from metals.sbt ...
2024.10.11 20:45:45 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project\project
2024.10.11 20:45:46 INFO  [info] loading settings for project spark-datos-energia-build from metals.sbt ...
2024.10.11 20:45:46 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project
2024.10.11 20:45:49 INFO  [success] Generated .bloop\spark-datos-energia-build.json
2024.10.11 20:45:49 INFO  [success] Total time: 3 s, completed 11-oct-2024 20:45:49
2024.10.11 20:45:51 INFO  [info] loading settings for project root from build.sbt ...
2024.10.11 20:45:51 INFO  [info] set current project to spark-datos-energia (in build file:/C:/Proyectos/spark-datos-energia/)
2024.10.11 20:45:51 INFO  [success] Generated .bloop\root-test.json
2024.10.11 20:45:51 INFO  [success] Generated .bloop\root.json
2024.10.11 20:45:51 INFO  [success] Total time: 1 s, completed 11-oct-2024 20:45:52
2024.10.11 20:45:52 INFO  time: ran 'sbt bloopInstall' in 10s
2024.10.11 20:45:52 INFO  Attempting to connect to the build server...
2024.10.11 20:45:52 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.11 20:45:53 INFO  Attempting to connect to the build server...
2024.10.11 20:45:53 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.11 20:45:55 INFO  time: Connected to build server in 2.9s
2024.10.11 20:45:55 INFO  Connected to Build server: Bloop v1.6.0
2024.10.11 20:45:55 INFO  running doctor check
2024.10.11 20:45:55 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.11 20:46:02 INFO  running 'C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals15358992348003287332\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.11 20:46:03 INFO  [info] welcome to sbt 1.10.2 (Oracle Corporation Java 1.8.0_202)
2024.10.11 20:46:03 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.11 20:46:04 INFO  [info] loading global plugins from C:\Users\jalva\.sbt\1.0\plugins
2024.10.11 20:46:05 INFO  [info] loading settings for project spark-datos-energia-build-build from metals.sbt ...
2024.10.11 20:46:05 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project\project
2024.10.11 20:46:05 INFO  [info] loading settings for project spark-datos-energia-build from metals.sbt ...
2024.10.11 20:46:05 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project
2024.10.11 20:46:08 INFO  [success] Generated .bloop\spark-datos-energia-build.json
2024.10.11 20:46:08 INFO  [success] Total time: 2 s, completed 11-oct-2024 20:46:08
2024.10.11 20:46:08 INFO  [info] loading settings for project root from build.sbt ...
2024.10.11 20:46:08 INFO  [info] set current project to spark-datos-energia (in build file:/C:/Proyectos/spark-datos-energia/)
2024.10.11 20:46:09 INFO  [success] Generated .bloop\root-test.json
2024.10.11 20:46:09 INFO  [success] Generated .bloop\root.json
2024.10.11 20:46:09 INFO  [success] Total time: 0 s, completed 11-oct-2024 20:46:09
2024.10.11 20:46:09 INFO  time: ran 'sbt bloopInstall' in 6.94s
2024.10.11 20:46:09 INFO  Disconnecting from Bloop session...
2024.10.11 20:46:09 INFO  Shut down connection with build server.
2024.10.11 20:46:09 INFO  Shut down connection with build server.
2024.10.11 20:46:09 INFO  Attempting to connect to the build server...
2024.10.11 20:46:09 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.11 20:46:09 INFO  Attempting to connect to the build server...
2024.10.11 20:46:09 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.11 20:46:09 INFO  time: Connected to build server in 74ms
2024.10.11 20:46:09 INFO  Connected to Build server: Bloop v1.6.0
2024.10.11 20:46:09 INFO  running doctor check
2024.10.11 20:46:09 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.11 20:46:14 INFO  time: indexed workspace in 5.19s
2024.10.11 20:46:14 INFO  time: indexed workspace in 19s
2024.10.11 20:46:30 INFO  compiling spark-datos-energia-build (1 scala source)
2024.10.11 20:46:33 INFO  time: code lens generation in 2.53s
2024.10.11 20:46:43 INFO  time: compiled spark-datos-energia-build in 12s
oct 11, 2024 8:49:41 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 11, 2024 8:49:47 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
2024.10.11 20:50:34 INFO  compiling root (1 scala source)
2024.10.11 20:50:36 INFO  time: compiled root in 2.14s
2024.10.11 20:52:45 INFO  compiling root (1 scala source)
2024.10.11 20:52:45 INFO  time: compiled root in 0.66s
2024.10.11 20:53:01 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.11 20:53:01 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.11 20:53:01 INFO  Starting debug proxy for [example.Hello]
2024.10.11 20:53:02 INFO  Loaded expression compiler in 321 milliseconds
2024.10.11 20:53:03 INFO  Loaded all sources and classes in 1 second
2024.10.11 20:53:03 INFO  Initialized Scala 3 decoder in 10 milliseconds
2024.10.11 20:53:03 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:55387 .
2024.10.11 20:53:03 INFO  Attaching to debuggee VM succeeded.
2024.10.11 20:53:03 INFO  Closing debug server tcp://0.0.0.0:55385
2024.10.11 20:53:04 INFO  Canceling debug proxy for [example.Hello]
2024.10.11 20:53:38 INFO  compiling root-test (1 scala source)
2024.10.11 20:53:38 INFO  time: compiled root-test in 0.84s
oct 11, 2024 8:53:50 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 222
2024.10.11 20:54:03 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.11 20:54:03 INFO  compiling root-test (1 scala source)
2024.10.11 20:54:03 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.11 20:54:04 INFO  Starting debug proxy for [example.HelloSpec()]
2024.10.11 20:54:03 INFO  Initialized Scala 3 decoder in 0 milliseconds
2024.10.11 20:54:03 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:55403 .
2024.10.11 20:54:03 INFO  Attaching to debuggee VM succeeded.
2024.10.11 20:54:03 INFO  time: compiled root-test in 0.79s
2024.10.11 20:54:05 INFO  Canceling debug proxy for [example.HelloSpec()]
2024.10.11 20:54:05 INFO  Closing debug server tcp://0.0.0.0:55398
2024.10.11 21:19:03 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.11 21:19:03 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.11 21:19:03 INFO  Starting debug proxy for [example.HelloSpec()]
2024.10.11 21:19:03 INFO  Initialized Scala 3 decoder in 0 milliseconds
2024.10.11 21:19:03 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:55745 .
2024.10.11 21:19:03 INFO  Attaching to debuggee VM succeeded.
2024.10.11 21:19:03 INFO  Canceling debug proxy for [example.HelloSpec()]
2024.10.11 21:19:03 INFO  Closing debug server tcp://0.0.0.0:55738
2024.10.11 21:19:39 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.11 21:19:39 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.11 21:19:39 INFO  Starting debug proxy for [example.HelloSpec(say hello)]
2024.10.11 21:19:39 INFO  Initialized Scala 3 decoder in 0 milliseconds
2024.10.11 21:19:39 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:55764 .
2024.10.11 21:19:39 INFO  Attaching to debuggee VM succeeded.
2024.10.11 21:19:40 INFO  Canceling debug proxy for [example.HelloSpec(say hello)]
2024.10.11 21:19:39 INFO  Closing debug server tcp://0.0.0.0:55760
2024.10.12 02:20:10 INFO  Shutting down server
2024.10.12 02:20:10 INFO  shutting down Metals
2024.10.12 02:20:10 INFO  Shut down connection with build server.
2024.10.12 02:20:10 INFO  Shut down connection with build server.
2024.10.12 02:20:10 INFO  Exiting server
2024.10.14 18:06:21 INFO  Started: Metals version 1.3.5 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.94.2.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@6f275c9f]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@1c816bc0]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@6f275c9f]
2024.10.14 18:06:21 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.14 18:06:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\test\scala\example\HelloSpec.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.14 18:06:22 INFO  Attempting to connect to the build server...
2024.10.14 18:06:28 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.14 18:06:28 INFO  Attempting to connect to the build server...
2024.10.14 18:06:28 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.14 18:06:28 INFO  time: Connected to build server in 6.42s
2024.10.14 18:06:28 INFO  Connected to Build server: Bloop v1.6.0
2024.10.14 18:06:28 INFO  time: Imported build in 0.12s
2024.10.14 18:06:28 INFO  running doctor check
2024.10.14 18:06:28 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.14 18:06:32 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.14 18:06:37 INFO  time: indexed workspace in 9.03s
2024.10.14 18:06:38 INFO  compiling root (1 scala source)
2024.10.14 18:06:41 INFO  compiling root-test (1 scala source)
2024.10.14 18:06:41 INFO  time: compiled root in 2.77s
2024.10.14 18:06:41 INFO  time: compiled root-test in 0.65s
2024.10.14 18:07:31 INFO  compiling spark-datos-energia-build (1 scala source)
2024.10.14 18:07:33 INFO  time: compiled spark-datos-energia-build in 2.49s
2024.10.14 18:07:34 INFO  time: code lens generation in 1.49s
2024.10.14 18:21:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\project\metals.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.10.14 18:21:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\project\metals.sbt. Using presentation compiler with project's scala-library version: 2.13.12
oct 14, 2024 6:25:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: scala.reflect.internal.Symbols$CyclicReference: illegal cyclic reference involving object Main
java.util.concurrent.CompletionException: scala.reflect.internal.Symbols$CyclicReference: illegal cyclic reference involving object Main
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: scala.reflect.internal.Symbols$CyclicReference: illegal cyclic reference involving object Main

oct 14, 2024 6:25:37 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-14\r_compiler-error_(spark-datos-energia-build)_18-25-37-267.md
oct 14, 2024 6:25:38 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-14\r_compiler-error_(spark-datos-energia-build)_18-25-38-399.md
oct 14, 2024 6:25:40 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-14\r_compiler-error_(spark-datos-energia-build)_18-25-40-301.md
oct 14, 2024 6:25:41 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-14\r_compiler-error_(spark-datos-energia-build)_18-25-41-117.md
2024.10.14 18:29:57 INFO  compiling root (1 scala source)
2024.10.14 18:29:57 INFO  time: compiled root in 0.37s
2024.10.14 18:31:05 INFO  compiling root (1 scala source)
2024.10.14 18:31:05 INFO  time: compiled root in 0.28s
2024.10.14 18:37:54 INFO  no build target found for C:\Proyectos\spark-datos-energia\project\metals.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.10.14 18:37:55 INFO  no build target found for C:\Proyectos\spark-datos-energia\project\metals.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.10.14 18:45:27 INFO  Shutting down server
2024.10.14 18:45:27 INFO  shutting down Metals
2024.10.14 18:45:27 INFO  Shut down connection with build server.
2024.10.14 18:45:27 INFO  Shut down connection with build server.
2024.10.14 18:45:27 INFO  Exiting server
2024.10.15 14:02:39 INFO  Started: Metals version 1.3.5 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.94.2.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@1db2c22]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@71448cff]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@1db2c22]
2024.10.15 14:02:39 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.15 14:02:39 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Hello.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.15 14:02:39 INFO  Attempting to connect to the build server...
2024.10.15 14:02:43 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 14:02:43 INFO  Attempting to connect to the build server...
2024.10.15 14:02:43 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 14:02:43 INFO  time: Connected to build server in 3.65s
2024.10.15 14:02:43 INFO  Connected to Build server: Bloop v1.6.0
2024.10.15 14:02:43 INFO  time: Imported build in 0.15s
2024.10.15 14:02:43 INFO  running doctor check
2024.10.15 14:02:43 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.15 14:02:45 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.15 14:02:46 INFO  time: indexed workspace in 2.83s
oct 15, 2024 3:02:04 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-15\r_compiler-error_(spark-datos-energia-build)_15-02-04-570.md
oct 15, 2024 3:02:07 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-15\r_compiler-error_(spark-datos-energia-build)_15-02-07-731.md
oct 15, 2024 3:02:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 191
oct 15, 2024 3:02:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 192
oct 15, 2024 3:02:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 197
oct 15, 2024 3:02:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 193
oct 15, 2024 3:02:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 196
oct 15, 2024 3:02:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 199
oct 15, 2024 3:02:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 203
oct 15, 2024 3:02:27 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 229
oct 15, 2024 3:02:27 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 234
oct 15, 2024 3:02:27 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 233
oct 15, 2024 3:02:27 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 237
oct 15, 2024 3:02:27 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 236
oct 15, 2024 3:03:53 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-15\r_compiler-error_(spark-datos-energia-build)_15-03-53-425.md
oct 15, 2024 3:03:55 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-15\r_compiler-error_(spark-datos-energia-build)_15-03-54-998.md
oct 15, 2024 3:03:58 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-15\r_compiler-error_(spark-datos-energia-build)_15-03-58-661.md
oct 15, 2024 3:04:00 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-15\r_compiler-error_(spark-datos-energia-build)_15-04-00-181.md
oct 15, 2024 3:04:01 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-15\r_compiler-error_(spark-datos-energia-build)_15-04-01-076.md
oct 15, 2024 3:04:15 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-15\r_compiler-error_(spark-datos-energia-build)_15-04-15-010.md
2024.10.15 15:07:46 INFO  running 'C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals515328745190726453\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.15 15:07:48 INFO  [info] welcome to sbt 1.10.2 (Oracle Corporation Java 1.8.0_202)
2024.10.15 15:07:48 INFO  [info] loading global plugins from C:\Users\jalva\.sbt\1.0\plugins
2024.10.15 15:07:50 INFO  [info] loading settings for project spark-datos-energia-build-build from metals.sbt ...
2024.10.15 15:07:50 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project\project
2024.10.15 15:07:50 INFO  [info] loading settings for project spark-datos-energia-build from metals.sbt ...
2024.10.15 15:07:50 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project
2024.10.15 15:07:52 INFO  [success] Generated .bloop\spark-datos-energia-build.json
2024.10.15 15:07:52 INFO  [success] Total time: 2 s, completed 15-oct-2024 15:07:53
2024.10.15 15:07:54 ERROR C:\Proyectos\spark-datos-energia\build.sbt:11: error: No Append.Value[Seq[sbt.librarymanagement.ModuleID], Seq[sbt.librarymanagement.ModuleID]] found, so Seq[sbt.librarymanagement.ModuleID] cannot be appended to Seq[sbt.librarymanagement.ModuleID]
2024.10.15 15:07:54 ERROR     libraryDependencies += Seq(
2024.10.15 15:07:54 ERROR                         ^
2024.10.15 15:07:54 ERROR sbt.compiler.EvalException: Type error in expression
2024.10.15 15:07:54 INFO  [error] sbt.compiler.EvalException: Type error in expression
2024.10.15 15:07:54 INFO  [error] Use 'last' for the full log.
2024.10.15 15:07:54 INFO  [warn] Project loading failed: (r)etry, (q)uit, (l)ast, or (i)gnore? (default: r)
2024.10.15 15:07:54 INFO  time: ran 'sbt bloopInstall' in 7.2s
2024.10.15 15:07:54 ERROR sbt command failed: C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals515328745190726453\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.10.15 15:07:54 INFO  Disconnecting from Bloop session...
2024.10.15 15:07:54 INFO  Shut down connection with build server.
2024.10.15 15:07:54 INFO  Shut down connection with build server.
2024.10.15 15:07:54 INFO  Attempting to connect to the build server...
2024.10.15 15:07:54 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 15:07:54 INFO  Attempting to connect to the build server...
2024.10.15 15:07:54 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 15:07:54 INFO  time: Connected to build server in 83ms
2024.10.15 15:07:54 INFO  Connected to Build server: Bloop v1.6.0
2024.10.15 15:07:54 INFO  running doctor check
2024.10.15 15:07:54 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.15 15:07:58 INFO  time: indexed workspace in 4.3s
2024.10.15 15:15:51 INFO  compiling root (1 scala source)
2024.10.15 15:15:52 INFO  time: compiled root in 1.65s
oct 15, 2024 3:19:50 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
2024.10.15 15:24:02 INFO  running 'C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals12853461940716765781\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.15 15:24:02 INFO  sbt thinks that server is already booting because of this exception:
2024.10.15 15:24:02 ERROR sbt.internal.ServerAlreadyBootingException: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-4528240900712198192_lock, error 5
2024.10.15 15:24:02 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:357)
2024.10.15 15:24:02 ERROR 	at sbt.internal.BootServerSocket.<init>(BootServerSocket.java:296)
2024.10.15 15:24:02 ERROR 	at sbt.xMain$.getSocketOrExit(Main.scala:152)
2024.10.15 15:24:02 ERROR 	at sbt.xMain$.bootServerSocket$lzycompute$1(Main.scala:78)
2024.10.15 15:24:02 ERROR 	at sbt.xMain$.bootServerSocket$1(Main.scala:78)
2024.10.15 15:24:02 ERROR 	at sbt.xMain$.withStreams$1(Main.scala:86)
2024.10.15 15:24:02 ERROR 	at sbt.xMain$.run(Main.scala:123)
2024.10.15 15:24:02 ERROR 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
2024.10.15 15:24:02 ERROR 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
2024.10.15 15:24:02 ERROR 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
2024.10.15 15:24:02 ERROR 	at java.lang.reflect.Method.invoke(Method.java:498)
2024.10.15 15:24:02 ERROR 	at sbt.internal.XMainConfiguration.run(XMainConfiguration.java:59)
2024.10.15 15:24:02 ERROR 	at sbt.xMain.run(Main.scala:47)
2024.10.15 15:24:02 ERROR 	at xsbt.boot.Launch$.$anonfun$run$1(Launch.scala:149)
2024.10.15 15:24:02 ERROR 	at xsbt.boot.Launch$.withContextLoader(Launch.scala:176)
2024.10.15 15:24:02 ERROR 	at xsbt.boot.Launch$.run(Launch.scala:149)
2024.10.15 15:24:02 ERROR 	at xsbt.boot.Launch$.$anonfun$apply$1(Launch.scala:44)
2024.10.15 15:24:02 ERROR 	at xsbt.boot.Launch$.launch(Launch.scala:159)
2024.10.15 15:24:02 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:44)
2024.10.15 15:24:02 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:21)
2024.10.15 15:24:02 ERROR 	at xsbt.boot.Boot$.runImpl(Boot.scala:78)
2024.10.15 15:24:02 ERROR 	at xsbt.boot.Boot$.run(Boot.scala:73)
2024.10.15 15:24:02 ERROR 	at xsbt.boot.Boot$.main(Boot.scala:21)
2024.10.15 15:24:02 ERROR 	at xsbt.boot.Boot.main(Boot.scala)
2024.10.15 15:24:02 ERROR Caused by: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-4528240900712198192_lock, error 5
2024.10.15 15:24:02 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:129)
2024.10.15 15:24:02 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:48)
2024.10.15 15:24:02 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:351)
2024.10.15 15:24:02 ERROR 	... 23 more
2024.10.15 15:24:02 INFO  time: ran 'sbt bloopInstall' in 0.95s
2024.10.15 15:24:03 ERROR sbt command failed: C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals12853461940716765781\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.10.15 15:24:02 INFO  Disconnecting from Bloop session...
2024.10.15 15:24:03 INFO  Shut down connection with build server.
2024.10.15 15:24:03 INFO  Shut down connection with build server.
2024.10.15 15:24:03 INFO  Attempting to connect to the build server...
2024.10.15 15:24:03 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 15:24:03 INFO  Attempting to connect to the build server...
2024.10.15 15:24:03 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 15:24:03 INFO  time: Connected to build server in 45ms
2024.10.15 15:24:03 INFO  Connected to Build server: Bloop v1.6.0
2024.10.15 15:24:03 INFO  running doctor check
2024.10.15 15:24:03 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.15 15:24:04 INFO  time: indexed workspace in 1.18s
oct 15, 2024 7:00:33 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:00:43 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:00:54 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:01:05 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:01:13 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:01:27 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:01:34 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:01:44 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:02:01 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:02:13 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:03:42 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:03:49 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:03:54 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:04:03 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:05:15 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:05:25 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:05:31 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:05:38 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:05:43 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:05:50 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:05:58 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:06:04 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
something's wrong: no file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/Main.scala in Array[<error>]RangePosition(file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/Main.scala, 53, 53, 68)
oct 15, 2024 7:06:32 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 995
something's wrong: no file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/Main.scala in Array[<error>]RangePosition(file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/Main.scala, 53, 53, 61)
something's wrong: no file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/Main.scala in Array[<error>]RangePosition(file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/Main.scala, 53, 53, 62)
something's wrong: no file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/Main.scala in Array[<error>]RangePosition(file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/Main.scala, 53, 53, 63)
oct 15, 2024 7:11:56 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:12:10 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 15, 2024 7:12:18 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
2024.10.15 19:15:11 INFO  running 'C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals1455552927791450993\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.15 19:15:12 INFO  sbt thinks that server is already booting because of this exception:
2024.10.15 19:15:12 ERROR sbt.internal.ServerAlreadyBootingException: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-4528240900712198192_lock, error 5
2024.10.15 19:15:12 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:357)
2024.10.15 19:15:12 ERROR 	at sbt.internal.BootServerSocket.<init>(BootServerSocket.java:296)
2024.10.15 19:15:12 ERROR 	at sbt.xMain$.getSocketOrExit(Main.scala:152)
2024.10.15 19:15:12 ERROR 	at sbt.xMain$.bootServerSocket$lzycompute$1(Main.scala:78)
2024.10.15 19:15:12 ERROR 	at sbt.xMain$.bootServerSocket$1(Main.scala:78)
2024.10.15 19:15:12 ERROR 	at sbt.xMain$.withStreams$1(Main.scala:86)
2024.10.15 19:15:12 ERROR 	at sbt.xMain$.run(Main.scala:123)
2024.10.15 19:15:12 ERROR 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
2024.10.15 19:15:12 ERROR 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
2024.10.15 19:15:12 ERROR 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
2024.10.15 19:15:12 ERROR 	at java.lang.reflect.Method.invoke(Method.java:498)
2024.10.15 19:15:12 ERROR 	at sbt.internal.XMainConfiguration.run(XMainConfiguration.java:59)
2024.10.15 19:15:12 ERROR 	at sbt.xMain.run(Main.scala:47)
2024.10.15 19:15:12 ERROR 	at xsbt.boot.Launch$.$anonfun$run$1(Launch.scala:149)
2024.10.15 19:15:12 ERROR 	at xsbt.boot.Launch$.withContextLoader(Launch.scala:176)
2024.10.15 19:15:12 ERROR 	at xsbt.boot.Launch$.run(Launch.scala:149)
2024.10.15 19:15:12 ERROR 	at xsbt.boot.Launch$.$anonfun$apply$1(Launch.scala:44)
2024.10.15 19:15:12 ERROR 	at xsbt.boot.Launch$.launch(Launch.scala:159)
2024.10.15 19:15:12 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:44)
2024.10.15 19:15:12 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:21)
2024.10.15 19:15:12 ERROR 	at xsbt.boot.Boot$.runImpl(Boot.scala:78)
2024.10.15 19:15:12 ERROR 	at xsbt.boot.Boot$.run(Boot.scala:73)
2024.10.15 19:15:12 ERROR 	at xsbt.boot.Boot$.main(Boot.scala:21)
2024.10.15 19:15:12 ERROR 	at xsbt.boot.Boot.main(Boot.scala)
2024.10.15 19:15:12 ERROR Caused by: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-4528240900712198192_lock, error 5
2024.10.15 19:15:12 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:129)
2024.10.15 19:15:12 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:48)
2024.10.15 19:15:12 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:351)
2024.10.15 19:15:12 ERROR 	... 23 more
2024.10.15 19:15:12 INFO  time: ran 'sbt bloopInstall' in 0.95s
2024.10.15 19:15:12 ERROR sbt command failed: C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals1455552927791450993\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.10.15 19:15:12 INFO  Disconnecting from Bloop session...
2024.10.15 19:15:12 INFO  Shut down connection with build server.
2024.10.15 19:15:12 INFO  Shut down connection with build server.
2024.10.15 19:15:12 INFO  Attempting to connect to the build server...
2024.10.15 19:15:12 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 19:15:12 INFO  Attempting to connect to the build server...
2024.10.15 19:15:12 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 19:15:12 INFO  time: Connected to build server in 57ms
2024.10.15 19:15:12 INFO  Connected to Build server: Bloop v1.6.0
2024.10.15 19:15:12 INFO  running doctor check
2024.10.15 19:15:12 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.15 19:15:16 INFO  time: indexed workspace in 3.52s
2024.10.15 19:17:04 INFO  skipping build import with status 'Installed'
2024.10.15 19:17:04 INFO  Disconnecting from Bloop session...
2024.10.15 19:17:04 INFO  Shut down connection with build server.
2024.10.15 19:17:04 INFO  Shut down connection with build server.
2024.10.15 19:17:04 INFO  Cancelling compilation on Bloop server
oct 15, 2024 7:17:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint notify
INFORMACIÓN: Failed to send notification message.
org.eclipse.lsp4j.jsonrpc.JsonRpcException: java.nio.channels.ClosedChannelException
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:72)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.notify(RemoteEndpoint.java:135)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.sendCancelNotification(RemoteEndpoint.java:191)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint$1.cancel(RemoteEndpoint.java:160)
	at scala.meta.internal.metals.utils.FutureWithTimeout$$anon$1.$anonfun$cancel$1(FutureWithTimeout.scala:37)
	at scala.runtime.java8.JFunction0$mcZ$sp.apply(JFunction0$mcZ$sp.scala:17)
	at scala.util.Try$.apply(Try.scala:217)
	at scala.meta.internal.metals.utils.FutureWithTimeout$$anon$1.cancel(FutureWithTimeout.scala:37)
	at scala.meta.internal.metals.Cancelable$.$anonfun$cancelAll$1(Cancelable.scala:29)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.metals.Cancelable$.cancelAll(Cancelable.scala:28)
	at scala.meta.internal.metals.MutableCancelable.cancel(MutableCancelable.scala:25)
	at scala.meta.internal.metals.utils.RequestRegistry.cancel(RequestRegistry.scala:94)
	at scala.meta.internal.metals.BuildServerConnection.cancel(BuildServerConnection.scala:450)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1(BuildServerConnection.scala:182)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1$adapted(BuildServerConnection.scala:174)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.nio.channels.ClosedChannelException
	at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:215)
	at java.base/sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:527)
	at java.base/sun.nio.ch.SinkChannelImpl.write(SinkChannelImpl.java:123)
	at java.base/java.nio.channels.Channels.writeFullyImpl(Channels.java:74)
	at java.base/java.nio.channels.Channels.writeFully(Channels.java:93)
	at java.base/java.nio.channels.Channels$1.write(Channels.java:171)
	at java.base/java.io.OutputStream.write(OutputStream.java:127)
	at java.base/java.nio.channels.Channels$1.write(Channels.java:151)
	at scala.meta.internal.metals.ClosableOutputStream.write(ClosableOutputStream.scala:26)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:137)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:108)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:67)
	... 19 more

2024.10.15 19:17:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.10.15 19:17:04 INFO  Attempting to connect to the build server...
2024.10.15 19:17:04 INFO  Scala main classes not supported by server
2024.10.15 19:17:04 INFO  Scala test classes not supported by server
2024.10.15 19:17:04 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 19:17:04 INFO  Attempting to connect to the build server...
2024.10.15 19:17:04 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 19:17:04 INFO  time: Connected to build server in 44ms
2024.10.15 19:17:04 INFO  Connected to Build server: Bloop v1.6.0
2024.10.15 19:17:04 INFO  running doctor check
2024.10.15 19:17:04 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.15 19:17:05 INFO  time: indexed workspace in 1.17s
2024.10.15 19:17:09 INFO  running 'C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals11802018949227771067\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.15 19:17:10 INFO  [info] welcome to sbt 1.10.2 (Oracle Corporation Java 1.8.0_202)
2024.10.15 19:17:10 INFO  [info] loading global plugins from C:\Users\jalva\.sbt\1.0\plugins
2024.10.15 19:17:12 INFO  [info] loading settings for project spark-datos-energia-build-build from metals.sbt ...
2024.10.15 19:17:12 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project\project
2024.10.15 19:17:12 INFO  [info] loading settings for project spark-datos-energia-build from metals.sbt ...
2024.10.15 19:17:12 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project
2024.10.15 19:17:13 INFO  [success] Generated .bloop\spark-datos-energia-build.json
2024.10.15 19:17:13 INFO  [success] Total time: 2 s, completed 15-oct-2024 19:17:14
2024.10.15 19:17:16 INFO  [info] loading settings for project root from build.sbt ...
2024.10.15 19:17:16 INFO  [info] set current project to spark-datos-energia (in build file:/C:/Proyectos/spark-datos-energia/)
2024.10.15 19:17:26 INFO  [success] Generated .bloop\root.json
2024.10.15 19:17:26 INFO  [success] Generated .bloop\root-test.json
2024.10.15 19:17:26 INFO  [success] Total time: 10 s, completed 15-oct-2024 19:17:26
2024.10.15 19:17:26 INFO  time: ran 'sbt bloopInstall' in 17s
2024.10.15 19:17:26 INFO  Disconnecting from Bloop session...
2024.10.15 19:17:26 INFO  Shut down connection with build server.
2024.10.15 19:17:26 INFO  Shut down connection with build server.
2024.10.15 19:17:26 INFO  Attempting to connect to the build server...
2024.10.15 19:17:26 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 19:17:26 INFO  Attempting to connect to the build server...
2024.10.15 19:17:26 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 19:17:26 INFO  time: Connected to build server in 0.1s
2024.10.15 19:17:26 INFO  Connected to Build server: Bloop v1.6.0
2024.10.15 19:17:26 INFO  running doctor check
2024.10.15 19:17:26 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.15 19:17:49 INFO  time: indexed workspace in 22s
2024.10.15 19:17:49 INFO  compiling root-test (1 scala source)
2024.10.15 19:17:49 INFO  time: compiled root-test in 0.54s
2024.10.15 19:18:08 INFO  compiling root (1 scala source)
2024.10.15 19:18:08 INFO  time: compiled root in 0.24s
2024.10.15 19:18:08 INFO  compiling root (1 scala source)
2024.10.15 19:18:08 INFO  time: compiled root in 0.12s
2024.10.15 19:21:26 INFO  compiling root (1 scala source)
2024.10.15 19:21:26 INFO  time: compiled root in 0.18s
2024.10.15 19:21:33 INFO  compiling root (1 scala source)
2024.10.15 19:21:33 INFO  time: compiled root in 0.19s
2024.10.15 19:21:42 INFO  compiling root (1 scala source)
2024.10.15 19:21:42 INFO  time: compiled root in 0.16s
2024.10.15 19:21:48 INFO  compiling root (1 scala source)
2024.10.15 19:21:48 INFO  time: compiled root in 0.83s
2024.10.15 19:21:53 INFO  compiling root-test (1 scala source)
2024.10.15 19:21:53 INFO  time: compiled root-test in 0.2s
2024.10.15 19:22:49 INFO  running 'C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals4713580111736585979\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.15 19:22:50 INFO  [info] welcome to sbt 1.10.2 (Oracle Corporation Java 1.8.0_202)
2024.10.15 19:22:50 INFO  [info] loading global plugins from C:\Users\jalva\.sbt\1.0\plugins
2024.10.15 19:22:52 INFO  [info] loading settings for project spark-datos-energia-build-build from metals.sbt ...
2024.10.15 19:22:52 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project\project
2024.10.15 19:22:52 INFO  [info] loading settings for project spark-datos-energia-build from metals.sbt ...
2024.10.15 19:22:52 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project
2024.10.15 19:22:53 INFO  [success] Generated .bloop\spark-datos-energia-build.json
2024.10.15 19:22:53 INFO  [success] Total time: 2 s, completed 15-oct-2024 19:22:54
2024.10.15 19:22:55 INFO  [info] loading settings for project root from build.sbt ...
2024.10.15 19:22:55 INFO  [info] set current project to spark-datos-energia (in build file:/C:/Proyectos/spark-datos-energia/)
2024.10.15 19:22:58 INFO  [success] Generated .bloop\root-test.json
2024.10.15 19:22:58 INFO  [success] Generated .bloop\root.json
2024.10.15 19:22:58 INFO  [success] Total time: 3 s, completed 15-oct-2024 19:22:58
2024.10.15 19:22:58 INFO  time: ran 'sbt bloopInstall' in 9.14s
2024.10.15 19:22:58 INFO  Disconnecting from Bloop session...
2024.10.15 19:22:58 INFO  Shut down connection with build server.
2024.10.15 19:22:58 INFO  Shut down connection with build server.
2024.10.15 19:22:58 INFO  Attempting to connect to the build server...
2024.10.15 19:22:58 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 19:22:58 INFO  Attempting to connect to the build server...
2024.10.15 19:22:58 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 19:22:58 INFO  time: Connected to build server in 96ms
2024.10.15 19:22:58 INFO  Connected to Build server: Bloop v1.6.0
2024.10.15 19:22:58 INFO  time: Imported build in 0.41s
2024.10.15 19:22:59 INFO  running doctor check
2024.10.15 19:22:59 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.15 19:23:11 INFO  time: indexed workspace in 12s
oct 15, 2024 7:27:17 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-15\r_compiler-error_(spark-datos-energia-build)_19-27-17-287.md
oct 15, 2024 7:36:49 P. M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMACIÓN: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
oct 15, 2024 7:36:49 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-15\r_compiler-error_(spark-datos-energia-build)_19-36-49-460.md
oct 15, 2024 7:37:28 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-15\r_compiler-error_(spark-datos-energia-build)_19-37-28-292.md
2024.10.15 19:38:03 INFO  running 'C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals13084861986959166370\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.15 19:38:04 INFO  [info] welcome to sbt 1.10.2 (Oracle Corporation Java 1.8.0_202)
2024.10.15 19:38:04 INFO  [info] loading global plugins from C:\Users\jalva\.sbt\1.0\plugins
2024.10.15 19:38:06 INFO  [info] loading settings for project spark-datos-energia-build-build from metals.sbt ...
2024.10.15 19:38:06 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project\project
2024.10.15 19:38:06 INFO  [info] loading settings for project spark-datos-energia-build from metals.sbt ...
2024.10.15 19:38:06 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project
2024.10.15 19:38:08 INFO  [success] Generated .bloop\spark-datos-energia-build.json
2024.10.15 19:38:08 INFO  [success] Total time: 2 s, completed 15-oct-2024 19:38:08
2024.10.15 19:38:10 INFO  [info] loading settings for project root from build.sbt ...
2024.10.15 19:38:10 INFO  [info] set current project to spark-datos-energia (in build file:/C:/Proyectos/spark-datos-energia/)
2024.10.15 19:38:12 INFO  [success] Generated .bloop\root.json
2024.10.15 19:38:12 INFO  [success] Generated .bloop\root-test.json
2024.10.15 19:38:12 INFO  [success] Total time: 3 s, completed 15-oct-2024 19:38:12
2024.10.15 19:38:13 INFO  time: ran 'sbt bloopInstall' in 9.23s
2024.10.15 19:38:13 INFO  Disconnecting from Bloop session...
2024.10.15 19:38:13 INFO  Shut down connection with build server.
2024.10.15 19:38:13 INFO  Shut down connection with build server.
2024.10.15 19:38:13 INFO  Attempting to connect to the build server...
2024.10.15 19:38:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 19:38:13 INFO  Attempting to connect to the build server...
2024.10.15 19:38:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 19:38:13 INFO  time: Connected to build server in 58ms
2024.10.15 19:38:13 INFO  Connected to Build server: Bloop v1.6.0
2024.10.15 19:38:13 INFO  running doctor check
2024.10.15 19:38:13 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.15 19:38:15 INFO  time: indexed workspace in 2.31s
2024.10.15 19:51:47 INFO  compiling root (1 scala source)
2024.10.15 19:51:47 INFO  time: compiled root in 0.19s
2024.10.15 20:00:21 INFO  compiling root (1 scala source)
2024.10.15 20:00:21 INFO  time: compiled root in 0.64s
oct 15, 2024 8:05:56 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3055
oct 15, 2024 8:11:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3118
oct 15, 2024 8:11:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3119
oct 15, 2024 8:11:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3122
oct 15, 2024 8:11:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3123
2024.10.15 20:11:45 INFO  compiling root (1 scala source)
2024.10.15 20:11:45 INFO  time: compiled root in 0.62s
2024.10.15 20:16:04 INFO  compiling root (1 scala source)
2024.10.15 20:16:04 INFO  time: compiled root in 0.66s
2024.10.15 20:21:19 WARN  Using indexes to guess the definition of DataFrame
2024.10.15 20:21:20 WARN  Using indexes to guess the definition of DataFrame
2024.10.15 20:26:13 INFO  compiling root (1 scala source)
2024.10.15 20:26:13 INFO  time: compiled root in 0.21s
2024.10.15 20:29:11 INFO  compiling root (1 scala source)
2024.10.15 20:29:11 INFO  time: compiled root in 0.14s
oct 15, 2024 8:29:15 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3839
2024.10.15 20:30:07 INFO  compiling root (1 scala source)
2024.10.15 20:30:07 INFO  time: compiled root in 0.15s
2024.10.15 20:30:19 INFO  compiling root (1 scala source)
2024.10.15 20:30:19 WARN  1 deprecation (since 2.13.3); re-run with -deprecation for details
2024.10.15 20:30:19 INFO  time: compiled root in 0.68s
2024.10.15 20:34:27 INFO  compiling root (1 scala source)
2024.10.15 20:34:27 INFO  time: compiled root in 0.28s
2024.10.15 20:57:24 ERROR C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
scala.meta.internal.tokenizers.package$UnexpectedInputEndException
	at scala.meta.internal.tokenizers.LegacyScanner.$anonfun$nextToken$1(LegacyScanner.scala:172)
	at scala.Function0.apply$mcV$sp(Function0.scala:42)
	at scala.meta.internal.tokenizers.LegacyScanner.scala$meta$internal$tokenizers$LegacyScanner$$nextToken(LegacyScanner.scala:178)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:172)
	at scala.meta.internal.mtags.ScalaToplevelMtags$XtensionScanner.mtagsNextToken(ScalaToplevelMtags.scala:72)
	at scala.meta.internal.mtags.ScalaToplevelMtags.emitMember(ScalaToplevelMtags.scala:709)
	at scala.meta.internal.mtags.ScalaToplevelMtags.loop(ScalaToplevelMtags.scala:247)
	at scala.meta.internal.mtags.ScalaToplevelMtags.indexRoot(ScalaToplevelMtags.scala:84)
	at scala.meta.internal.metals.SemanticdbDefinition$.foreachWithReturnMtags(SemanticdbDefinition.scala:81)
	at scala.meta.internal.metals.Indexer.indexSourceFile(Indexer.scala:595)
	at scala.meta.internal.metals.Indexer.$anonfun$reindexWorkspaceSources$3(Indexer.scala:693)
	at scala.meta.internal.metals.Indexer.$anonfun$reindexWorkspaceSources$3$adapted(Indexer.scala:690)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:619)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:617)
	at scala.collection.AbstractIterator.foreach(Iterator.scala:1303)
	at scala.meta.internal.metals.Indexer.reindexWorkspaceSources(Indexer.scala:690)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$onChange$2(MetalsLspService.scala:952)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.10.15 20:57:24 INFO  compiling root (3 scala sources)
2024.10.15 20:57:24 INFO  time: compiled root in 0.2s
2024.10.15 20:57:24 INFO  compiling root (3 scala sources)
2024.10.15 20:57:24 INFO  time: compiled root in 78ms
2024.10.15 20:57:40 INFO  compiling root (3 scala sources)
2024.10.15 20:57:40 INFO  time: compiled root in 0.12s
2024.10.15 20:58:00 INFO  compiling root (3 scala sources)
2024.10.15 20:58:00 INFO  time: compiled root in 0.17s
2024.10.15 20:58:09 INFO  compiling root (3 scala sources)
2024.10.15 20:58:10 INFO  time: compiled root in 1.01s
2024.10.15 20:58:57 INFO  compiling root (1 scala source)
2024.10.15 20:58:57 INFO  time: compiled root in 0.66s
2024.10.15 20:59:26 INFO  compiling root (1 scala source)
2024.10.15 20:59:26 INFO  time: compiled root in 0.63s
oct 15, 2024 9:05:21 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4708
2024.10.15 21:05:25 INFO  compiling root (1 scala source)
2024.10.15 21:05:25 INFO  time: compiled root in 0.25s
oct 15, 2024 9:06:02 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4887
oct 15, 2024 9:06:02 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4890
oct 15, 2024 9:06:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4941
oct 15, 2024 9:06:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4942
oct 15, 2024 9:06:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4943
oct 15, 2024 9:06:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4944
oct 15, 2024 9:06:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4946
oct 15, 2024 9:06:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4947
2024.10.15 21:06:18 INFO  compiling root (1 scala source)
2024.10.15 21:06:18 INFO  time: compiled root in 0.59s
2024.10.15 21:07:04 INFO  compiling root (1 scala source)
2024.10.15 21:07:04 INFO  time: compiled root in 0.69s
2024.10.15 21:15:59 INFO  running 'C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals14428289359958026273\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.15 21:16:00 INFO  [info] welcome to sbt 1.10.2 (Oracle Corporation Java 1.8.0_202)
2024.10.15 21:16:00 INFO  [info] loading global plugins from C:\Users\jalva\.sbt\1.0\plugins
2024.10.15 21:16:02 INFO  [info] loading settings for project spark-datos-energia-build-build from metals.sbt ...
2024.10.15 21:16:02 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project\project
2024.10.15 21:16:02 INFO  [info] loading settings for project spark-datos-energia-build from metals.sbt ...
2024.10.15 21:16:02 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project
oct 15, 2024 9:16:03 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-15\r_compiler-error_(spark-datos-energia-build)_21-16-03-782.md
2024.10.15 21:16:04 INFO  [success] Generated .bloop\spark-datos-energia-build.json
2024.10.15 21:16:04 INFO  [success] Total time: 2 s, completed 15-oct-2024 21:16:04
2024.10.15 21:16:06 INFO  [info] loading settings for project root from build.sbt ...
2024.10.15 21:16:06 INFO  [info] set current project to spark-datos-energia (in build file:/C:/Proyectos/spark-datos-energia/)
oct 15, 2024 9:16:06 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-15\r_compiler-error_(spark-datos-energia-build)_21-16-06-422.md
oct 15, 2024 9:16:06 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-15\r_compiler-error_(spark-datos-energia-build)_21-16-06-892.md
2024.10.15 21:16:11 INFO  [success] Generated .bloop\root-test.json
2024.10.15 21:16:11 INFO  [success] Generated .bloop\root.json
2024.10.15 21:16:11 INFO  [success] Total time: 5 s, completed 15-oct-2024 21:16:11
2024.10.15 21:16:11 INFO  time: ran 'sbt bloopInstall' in 11s
2024.10.15 21:16:11 INFO  Disconnecting from Bloop session...
2024.10.15 21:16:11 INFO  Shut down connection with build server.
2024.10.15 21:16:11 INFO  Shut down connection with build server.
2024.10.15 21:16:11 INFO  Attempting to connect to the build server...
2024.10.15 21:16:11 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 21:16:11 INFO  Attempting to connect to the build server...
2024.10.15 21:16:11 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.15 21:16:11 INFO  time: Connected to build server in 86ms
2024.10.15 21:16:11 INFO  Connected to Build server: Bloop v1.6.0
2024.10.15 21:16:11 INFO  no build target found for C:\Proyectos\spark-datos-energia\build.sbt. Using presentation compiler with project's scala-library version: 2.13.12
2024.10.15 21:16:11 INFO  running doctor check
2024.10.15 21:16:11 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.15 21:16:16 INFO  time: indexed workspace in 4.58s
2024.10.15 21:16:26 INFO  skipping build import with status 'Dismissed'
2024.10.15 21:16:27 INFO  skipping build import with status 'Dismissed'
2024.10.15 21:17:21 INFO  compiling root (1 scala source)
2024.10.15 21:17:21 INFO  time: compiled root in 0.33s
2024.10.15 21:17:21 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:17:23 INFO  compiling root (1 scala source)
2024.10.15 21:17:23 INFO  time: compiled root in 0.28s
2024.10.15 21:17:23 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:19:42 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:19:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:32 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:36 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:37 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:37 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:49 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:57 WARN  Using indexes to guess the definition of downloadApiData
2024.10.15 21:20:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:20:59 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:21:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:21:01 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:21:03 INFO  compiling root (1 scala source)
2024.10.15 21:21:03 INFO  time: compiled root in 0.25s
2024.10.15 21:21:03 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:21:13 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:21:29 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:21:45 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:21:45 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:21:46 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.15 21:22:13 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:25:20 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:25:32 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:25:33 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:25:34 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:25:34 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:25:43 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:25:44 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:25:48 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:25:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:25:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:25:51 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:26:04 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:26:08 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:26:10 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:26:12 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:26:14 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:26:14 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:26:15 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:26:16 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:27:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:27:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:27:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:27:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:27:56 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:27:58 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:27:59 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:02 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:03 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:06 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:09 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:10 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:13 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:14 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:15 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:17 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:18 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:18 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:19 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:20 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:22 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:24 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:24 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:26 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:27 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:29 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:29 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:31 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:40 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:42 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:43 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:43 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:44 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:46 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:47 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:28:51 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:03 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:05 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:07 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:08 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:09 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:11 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:11 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:12 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:13 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:13 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:14 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:15 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:15 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:16 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:17 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:21 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:23 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:25 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:27 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:28 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:31 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:31 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:32 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:34 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:36 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:37 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:37 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:46 INFO  compiling root (1 scala source)
2024.10.16 14:29:46 INFO  time: compiled root in 0.28s
2024.10.16 14:29:47 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:55 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:29:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 14:30:00 INFO  compiling root (1 scala source)
2024.10.16 14:30:00 WARN  2 deprecations (since 2.13.0); re-run with -deprecation for details
2024.10.16 14:30:00 INFO  time: compiled root in 0.96s
oct 16, 2024 2:30:24 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6833
2024.10.16 14:33:23 INFO  compiling root (1 scala source)
2024.10.16 14:33:23 WARN  2 deprecations (since 2.13.0); re-run with -deprecation for details
2024.10.16 14:33:23 INFO  time: compiled root in 0.7s
2024.10.16 14:33:27 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.16 14:33:27 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.16 14:33:27 INFO  Starting debug proxy for [example.ApiDataDownloader]
2024.10.16 14:33:28 INFO  Loaded expression compiler in 702 milliseconds
2024.10.16 14:33:28 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.ApiDataDownloader)
2024.10.16 14:33:36 INFO  Loaded all sources and classes in 7 seconds
2024.10.16 14:33:36 INFO  Initialized Scala 3 decoder in 2 milliseconds
2024.10.16 14:33:36 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:61791 .
2024.10.16 14:33:36 INFO  Attaching to debuggee VM succeeded.
2024.10.16 14:33:36 INFO  Canceling debug proxy for [example.ApiDataDownloader]
2024.10.16 14:33:36 INFO  Closing debug server tcp://0.0.0.0:61788
2024.10.16 14:33:53 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5' (since 17h 17m 42.112s)
2024.10.16 14:33:53 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.16 14:33:53 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.16 14:33:53 INFO  Starting debug proxy for [example.ApiDataDownloader]
2024.10.16 14:33:53 INFO  Loaded expression compiler in 1 millisecond
2024.10.16 14:33:53 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.ApiDataDownloader)
2024.10.16 14:33:55 INFO  Loaded all sources and classes in 1 second
2024.10.16 14:33:55 INFO  Initialized Scala 3 decoder in 0 milliseconds
2024.10.16 14:33:55 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:61799 .
2024.10.16 14:33:55 INFO  Attaching to debuggee VM succeeded.
2024.10.16 14:36:18 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5' (since 17h 20m 7.101s)
2024.10.16 14:36:18 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.16 14:36:18 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.16 14:36:18 INFO  Starting debug proxy for [example.ApiDataDownloader]
2024.10.16 14:36:18 INFO  Loaded expression compiler in 0 milliseconds
2024.10.16 14:36:18 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.ApiDataDownloader)
2024.10.16 14:36:20 INFO  Loaded all sources and classes in 1 second
2024.10.16 14:36:20 INFO  Initialized Scala 3 decoder in 0 milliseconds
2024.10.16 14:36:20 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:61816 .
2024.10.16 14:36:20 INFO  Attaching to debuggee VM succeeded.
2024.10.16 14:36:31 INFO  Canceling debug proxy for [example.ApiDataDownloader]
2024.10.16 14:36:31 INFO  Closing debug server tcp://0.0.0.0:61813
2024.10.16 14:36:35 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.16 14:36:37 INFO  Canceling debug proxy for [example.ApiDataDownloader]
2024.10.16 14:36:38 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.16 14:36:37 INFO  Starting debug proxy for [example.ApiDataDownloader]
2024.10.16 14:36:38 INFO  Loaded expression compiler in 1 millisecond
2024.10.16 14:36:38 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.ApiDataDownloader)
2024.10.16 14:36:39 INFO  Loaded all sources and classes in 1 second
2024.10.16 14:36:39 INFO  Initialized Scala 3 decoder in 0 milliseconds
2024.10.16 14:36:39 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:61823 .
2024.10.16 14:36:39 INFO  Attaching to debuggee VM succeeded.
2024.10.16 14:40:13 INFO  Canceling debug proxy for [example.ApiDataDownloader]
2024.10.16 14:40:18 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5' (since 17h 24m 6.849s)
2024.10.16 14:40:18 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.16 14:40:18 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.16 14:40:18 INFO  Starting debug proxy for [example.ApiDataDownloader]
2024.10.16 14:40:18 INFO  Loaded expression compiler in 1 millisecond
2024.10.16 14:40:18 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.ApiDataDownloader)
2024.10.16 14:40:20 INFO  Loaded all sources and classes in 2 seconds
2024.10.16 14:40:20 INFO  Initialized Scala 3 decoder in 0 milliseconds
2024.10.16 14:40:20 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:61903 .
2024.10.16 14:40:20 INFO  Attaching to debuggee VM succeeded.
2024.10.16 14:46:46 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5' (since 17h 30m 34.878s)
2024.10.16 14:46:46 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.16 14:46:46 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.16 14:46:46 INFO  Starting debug proxy for [example.ApiDataDownloader]
2024.10.16 14:46:46 INFO  Loaded expression compiler in 0 milliseconds
2024.10.16 14:46:46 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.ApiDataDownloader)
2024.10.16 14:46:48 INFO  Loaded all sources and classes in 1 second
2024.10.16 14:46:48 INFO  Initialized Scala 3 decoder in 0 milliseconds
2024.10.16 14:46:48 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:62020 .
2024.10.16 14:46:48 INFO  Attaching to debuggee VM succeeded.
2024.10.16 14:48:24 INFO  Canceling debug proxy for [example.ApiDataDownloader]
2024.10.16 14:48:24 INFO  Closing debug server tcp://0.0.0.0:62017
2024.10.16 14:48:29 INFO  Canceling debug proxy for [example.ApiDataDownloader]
oct 16, 2024 2:50:26 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 7215
oct 16, 2024 2:50:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 7277
oct 16, 2024 2:50:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 7278
2024.10.16 14:50:41 INFO  compiling root (1 scala source)
2024.10.16 14:50:41 WARN  2 deprecations (since 2.13.0); re-run with -deprecation for details
2024.10.16 14:50:41 INFO  time: compiled root in 0.79s
oct 16, 2024 2:59:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 9593
2024.10.16 15:00:29 INFO  compiling root (1 scala source)
2024.10.16 15:00:29 INFO  time: compiled root in 0.23s
oct 16, 2024 3:01:41 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 10084
2024.10.16 15:01:53 INFO  compiling root (1 scala source)
2024.10.16 15:01:53 INFO  time: compiled root in 0.2s
oct 16, 2024 3:48:44 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 10267
2024.10.16 15:48:44 INFO  compiling root (1 scala source)
2024.10.16 15:48:44 INFO  time: compiled root in 0.22s
2024.10.16 15:49:24 INFO  compiling root (1 scala source)
2024.10.16 15:49:24 INFO  time: compiled root in 0.22s
2024.10.16 15:51:52 INFO  compiling root (1 scala source)
2024.10.16 15:51:52 INFO  time: compiled root in 0.18s
2024.10.16 15:52:17 INFO  compiling root (1 scala source)
2024.10.16 15:52:17 INFO  time: compiled root in 0.17s
oct 16, 2024 3:58:20 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_(spark-datos-energia-build)_15-58-20-466.md
2024.10.16 15:58:20 INFO  time: code lens generation in 2.37s
2024.10.16 15:58:26 INFO  running 'C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals5118273903696130171\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.16 15:58:27 INFO  [info] welcome to sbt 1.10.2 (Oracle Corporation Java 1.8.0_202)
2024.10.16 15:58:27 INFO  [info] loading global plugins from C:\Users\jalva\.sbt\1.0\plugins
2024.10.16 15:58:28 INFO  [info] loading settings for project spark-datos-energia-build-build from metals.sbt ...
2024.10.16 15:58:28 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project\project
2024.10.16 15:58:28 INFO  [info] loading settings for project spark-datos-energia-build from metals.sbt ...
2024.10.16 15:58:28 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project
2024.10.16 15:58:30 INFO  [success] Generated .bloop\spark-datos-energia-build.json
2024.10.16 15:58:30 INFO  [success] Total time: 2 s, completed 16-oct-2024 15:58:31
2024.10.16 15:58:32 INFO  [info] loading settings for project root from build.sbt ...
2024.10.16 15:58:32 INFO  [info] set current project to spark-datos-energia (in build file:/C:/Proyectos/spark-datos-energia/)
2024.10.16 15:58:35 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.10.16 15:58:35 INFO  [warn] Removed stale C:\Proyectos\spark-datos-energia\.bloop\root-test.json
2024.10.16 15:58:35 INFO  [warn] Removed stale C:\Proyectos\spark-datos-energia\.bloop\root.json
2024.10.16 15:58:35 INFO  [error] java.lang.RuntimeException: expected `spark-datos-energia/scalaVersion` to be "2.13.15" or later,
2024.10.16 15:58:35 INFO  [error] but found "2.13.12"; upgrade scalaVersion to fix the build.
2024.10.16 15:58:35 INFO  [error] 
2024.10.16 15:58:35 INFO  [error] to support backwards-only binary compatibility (SIP-51),
2024.10.16 15:58:35 INFO  [error] the Scala 2.13 compiler cannot be older than scala-library on the
2024.10.16 15:58:35 INFO  [error] dependency classpath.
2024.10.16 15:58:35 INFO  [error] see `spark-datos-energia/evicted` to know why scala-library 2.13.15 is getting pulled in.
2024.10.16 15:58:35 INFO  [error] 
2024.10.16 15:58:35 INFO  [error] 	at scala.sys.package$.error(package.scala:30)
2024.10.16 15:58:35 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$14(Defaults.scala:1195)
2024.10.16 15:58:35 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$14$adapted(Defaults.scala:1184)
2024.10.16 15:58:35 INFO  [error] 	at scala.Option.foreach(Option.scala:407)
2024.10.16 15:58:35 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$12(Defaults.scala:1184)
2024.10.16 15:58:35 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$12$adapted(Defaults.scala:1182)
2024.10.16 15:58:35 INFO  [error] 	at scala.collection.Iterator.foreach(Iterator.scala:943)
2024.10.16 15:58:35 INFO  [error] 	at scala.collection.Iterator.foreach$(Iterator.scala:943)
2024.10.16 15:58:35 INFO  [error] 	at scala.collection.AbstractIterator.foreach(Iterator.scala:1431)
2024.10.16 15:58:35 INFO  [error] 	at scala.collection.IterableLike.foreach(IterableLike.scala:74)
2024.10.16 15:58:35 INFO  [error] 	at scala.collection.IterableLike.foreach$(IterableLike.scala:73)
2024.10.16 15:58:35 INFO  [error] 	at scala.collection.AbstractIterable.foreach(Iterable.scala:56)
2024.10.16 15:58:35 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$11(Defaults.scala:1182)
2024.10.16 15:58:35 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$11$adapted(Defaults.scala:1181)
2024.10.16 15:58:35 INFO  [error] 	at scala.Option.foreach(Option.scala:407)
2024.10.16 15:58:35 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$1(Defaults.scala:1181)
2024.10.16 15:58:35 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.10.16 15:58:35 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.10.16 15:58:35 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.10.16 15:58:35 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.10.16 15:58:35 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.10.16 15:58:35 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.10.16 15:58:35 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.10.16 15:58:35 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.10.16 15:58:35 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.10.16 15:58:35 INFO  [error] 	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
2024.10.16 15:58:35 INFO  [error] 	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
2024.10.16 15:58:35 INFO  [error] 	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
2024.10.16 15:58:35 INFO  [error] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
2024.10.16 15:58:35 INFO  [error] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
2024.10.16 15:58:35 INFO  [error] 	at java.lang.Thread.run(Thread.java:748)
2024.10.16 15:58:35 INFO  [error] (scalaInstance) expected `spark-datos-energia/scalaVersion` to be "2.13.15" or later,
2024.10.16 15:58:35 INFO  [error] but found "2.13.12"; upgrade scalaVersion to fix the build.
2024.10.16 15:58:35 INFO  [error] 
2024.10.16 15:58:35 INFO  [error] to support backwards-only binary compatibility (SIP-51),
2024.10.16 15:58:35 INFO  [error] the Scala 2.13 compiler cannot be older than scala-library on the
2024.10.16 15:58:35 INFO  [error] dependency classpath.
2024.10.16 15:58:35 INFO  [error] see `spark-datos-energia/evicted` to know why scala-library 2.13.15 is getting pulled in.
2024.10.16 15:58:35 INFO  [error] Total time: 3 s, completed 16-oct-2024 15:58:35
2024.10.16 15:58:36 INFO  time: ran 'sbt bloopInstall' in 9.99s
2024.10.16 15:58:36 ERROR sbt command failed: C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals5118273903696130171\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.10.16 15:58:36 INFO  Disconnecting from Bloop session...
2024.10.16 15:58:36 INFO  Shut down connection with build server.
2024.10.16 15:58:36 INFO  Shut down connection with build server.
2024.10.16 15:58:36 INFO  Attempting to connect to the build server...
2024.10.16 15:58:36 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 15:58:36 INFO  Attempting to connect to the build server...
2024.10.16 15:58:36 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 15:58:36 INFO  time: Connected to build server in 72ms
2024.10.16 15:58:36 INFO  Connected to Build server: Bloop v1.6.0
2024.10.16 15:58:36 INFO  running doctor check
2024.10.16 15:58:36 INFO  java targets: spark-datos-energia-build
2024.10.16 15:58:39 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:58:39 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:58:39 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:58:40 INFO  time: indexed workspace in 4.6s
2024.10.16 15:58:40 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\Hello.scala
2024.10.16 15:58:40 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 15:58:40 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala
2024.10.16 15:58:40 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:58:45 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:58:47 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 15:58:47 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:58:59 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:58:59 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:58:59 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:58:59 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:01 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:01 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:25 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:25 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:25 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:25 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:25 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:25 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:25 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:28 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:28 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:28 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:28 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:28 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:28 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 3:59:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 10718
2024.10.16 15:59:28 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:28 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:28 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:28 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:28 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:28 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 3:59:29 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_15-59-29-429.md
2024.10.16 15:59:28 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:30 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:30 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 3:59:30 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_15-59-30-225.md
2024.10.16 15:59:30 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:30 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:30 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:30 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:30 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:30 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 3:59:31 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_15-59-31-033.md
2024.10.16 15:59:30 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:32 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:32 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 3:59:32 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_15-59-32-062.md
2024.10.16 15:59:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:32 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:32 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:32 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:32 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:32 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:32 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:32 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:32 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:33 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:33 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
something's wrong: no file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/ApiDataIngestion.scala in Option[<error>]RangePosition(file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/ApiDataIngestion.scala, 2738, 2738, 2754)
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 3:59:35 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_15-59-35-892.md
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
something's wrong: no file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/ApiDataIngestion.scala in Option[<error>]RangePosition(file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/ApiDataIngestion.scala, 2738, 2738, 2747)
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:37 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:38 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:39 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:39 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:39 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:39 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:39 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 3:59:39 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_15-59-39-593.md
2024.10.16 15:59:39 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:39 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:39 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:39 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:39 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:39 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:40 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:40 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:40 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:40 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:40 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:40 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:42 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:42 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:42 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:42 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 3:59:46 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_15-59-46-991.md
2024.10.16 15:59:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:47 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:47 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:47 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:47 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:47 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:47 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 3:59:47 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_15-59-47-887.md
2024.10.16 15:59:47 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:47 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:47 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 3:59:48 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_15-59-48-664.md
2024.10.16 15:59:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:49 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:49 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 3:59:49 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_15-59-49-471.md
2024.10.16 15:59:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:49 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:49 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 3:59:50 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_15-59-50-023.md
2024.10.16 15:59:50 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:50 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:50 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 3:59:50 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_15-59-50-755.md
2024.10.16 15:59:51 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:51 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:51 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:52 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 15:59:52 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 3:59:52 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_15-59-52-320.md
2024.10.16 16:00:00 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:00 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:01 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:00 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:00 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:01 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:01 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:01 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:02 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:02 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:00:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 10983
2024.10.16 16:00:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:06 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:06 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:06 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:06 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:06 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:06 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:08 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:08 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:08 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:08 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:00:23 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_16-00-23-602.md
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:00:24 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_16-00-24-258.md
2024.10.16 16:00:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:25 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:25 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:25 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:30 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:32 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:32 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:32 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:32 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:33 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:00:33 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_16-00-33-072.md
2024.10.16 16:00:33 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:44 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:00:44 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_16-00-44-525.md
2024.10.16 16:00:45 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:45 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:45 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:00:45 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:01:09 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_16-01-09-626.md
2024.10.16 16:01:10 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:10 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:10 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:10 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:10 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:10 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:10 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:11 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:10 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:10 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:11 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:11 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:11 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:01:11 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_16-01-11-605.md
2024.10.16 16:01:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:01:12 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_16-01-12-931.md
2024.10.16 16:01:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:15 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:15 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:15 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:01:16 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 11295
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:17 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:18 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:18 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:18 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:18 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:18 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:18 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:18 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:20 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:20 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:20 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:21 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:21 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:21 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:22 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:01:23 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_16-01-23-574.md
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:01:24 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_16-01-24-469.md
2024.10.16 16:01:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:01:25 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_16-01-25-075.md
2024.10.16 16:01:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:28 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:28 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:30 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:30 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:33 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:33 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:33 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:33 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:33 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:34 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:34 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:40 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:49 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:49 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:51 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 16:01:51 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:55 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:57 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:01:57 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:08 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:08 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:08 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:16 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 16:02:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:18 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:34 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:34 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:34 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:34 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:34 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:34 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:34 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:34 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:34 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:34 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:34 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:34 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:34 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:35 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:37 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:37 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:37 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:37 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:37 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:37 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:37 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:37 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:37 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:37 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:38 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:38 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:38 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:38 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:39 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:40 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:40 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:40 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:41 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:41 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:45 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:45 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:45 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:45 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:45 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:45 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:45 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:45 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:45 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:47 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:47 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:48 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:51 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:51 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:51 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:53 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:53 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:53 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:53 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:53 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:53 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:02:54 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:06 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:06 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:06 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:06 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:06 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:06 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:08 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:08 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:08 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:03:08 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_16-03-08-875.md
2024.10.16 16:03:08 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:09 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:11 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 16:03:11 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:18 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Hello.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Hello.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Hello.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:24 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:25 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:25 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:03:35 INFO  running 'C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals8928606632208954940\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.16 16:03:36 INFO  [info] welcome to sbt 1.10.2 (Oracle Corporation Java 1.8.0_202)
2024.10.16 16:03:36 INFO  [info] loading global plugins from C:\Users\jalva\.sbt\1.0\plugins
2024.10.16 16:03:38 INFO  [info] loading settings for project spark-datos-energia-build-build from metals.sbt ...
2024.10.16 16:03:38 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project\project
2024.10.16 16:03:38 INFO  [info] loading settings for project spark-datos-energia-build from metals.sbt ...
2024.10.16 16:03:38 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project
2024.10.16 16:03:40 INFO  [success] Generated .bloop\spark-datos-energia-build.json
2024.10.16 16:03:40 INFO  [success] Total time: 2 s, completed 16-oct-2024 16:03:40
2024.10.16 16:03:40 INFO  [info] loading settings for project root from build.sbt ...
2024.10.16 16:03:40 INFO  [info] set current project to spark-datos-energia (in build file:/C:/Proyectos/spark-datos-energia/)
2024.10.16 16:03:41 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.10.16 16:03:41 INFO  [error] java.lang.RuntimeException: expected `spark-datos-energia/scalaVersion` to be "2.13.15" or later,
2024.10.16 16:03:41 INFO  [error] but found "2.13.12"; upgrade scalaVersion to fix the build.
2024.10.16 16:03:41 INFO  [error] 
2024.10.16 16:03:41 INFO  [error] to support backwards-only binary compatibility (SIP-51),
2024.10.16 16:03:41 INFO  [error] the Scala 2.13 compiler cannot be older than scala-library on the
2024.10.16 16:03:41 INFO  [error] dependency classpath.
2024.10.16 16:03:41 INFO  [error] see `spark-datos-energia/evicted` to know why scala-library 2.13.15 is getting pulled in.
2024.10.16 16:03:41 INFO  [error] 
2024.10.16 16:03:41 INFO  [error] 	at scala.sys.package$.error(package.scala:30)
2024.10.16 16:03:41 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$14(Defaults.scala:1195)
2024.10.16 16:03:41 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$14$adapted(Defaults.scala:1184)
2024.10.16 16:03:41 INFO  [error] 	at scala.Option.foreach(Option.scala:407)
2024.10.16 16:03:41 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$12(Defaults.scala:1184)
2024.10.16 16:03:41 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$12$adapted(Defaults.scala:1182)
2024.10.16 16:03:41 INFO  [error] 	at scala.collection.Iterator.foreach(Iterator.scala:943)
2024.10.16 16:03:41 INFO  [error] 	at scala.collection.Iterator.foreach$(Iterator.scala:943)
2024.10.16 16:03:41 INFO  [error] 	at scala.collection.AbstractIterator.foreach(Iterator.scala:1431)
2024.10.16 16:03:41 INFO  [error] 	at scala.collection.IterableLike.foreach(IterableLike.scala:74)
2024.10.16 16:03:41 INFO  [error] 	at scala.collection.IterableLike.foreach$(IterableLike.scala:73)
2024.10.16 16:03:41 INFO  [error] 	at scala.collection.AbstractIterable.foreach(Iterable.scala:56)
2024.10.16 16:03:41 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$11(Defaults.scala:1182)
2024.10.16 16:03:41 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$11$adapted(Defaults.scala:1181)
2024.10.16 16:03:41 INFO  [error] 	at scala.Option.foreach(Option.scala:407)
2024.10.16 16:03:41 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$1(Defaults.scala:1181)
2024.10.16 16:03:41 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.10.16 16:03:41 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.10.16 16:03:41 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.10.16 16:03:41 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.10.16 16:03:41 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.10.16 16:03:41 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.10.16 16:03:41 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.10.16 16:03:41 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.10.16 16:03:41 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.10.16 16:03:41 INFO  [error] 	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
2024.10.16 16:03:41 INFO  [error] 	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
2024.10.16 16:03:41 INFO  [error] 	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
2024.10.16 16:03:41 INFO  [error] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
2024.10.16 16:03:41 INFO  [error] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
2024.10.16 16:03:41 INFO  [error] 	at java.lang.Thread.run(Thread.java:748)
2024.10.16 16:03:41 INFO  [error] (scalaInstance) expected `spark-datos-energia/scalaVersion` to be "2.13.15" or later,
2024.10.16 16:03:41 INFO  [error] but found "2.13.12"; upgrade scalaVersion to fix the build.
2024.10.16 16:03:41 INFO  [error] 
2024.10.16 16:03:41 INFO  [error] to support backwards-only binary compatibility (SIP-51),
2024.10.16 16:03:41 INFO  [error] the Scala 2.13 compiler cannot be older than scala-library on the
2024.10.16 16:03:41 INFO  [error] dependency classpath.
2024.10.16 16:03:41 INFO  [error] see `spark-datos-energia/evicted` to know why scala-library 2.13.15 is getting pulled in.
2024.10.16 16:03:41 INFO  [error] Total time: 1 s, completed 16-oct-2024 16:03:41
2024.10.16 16:03:41 INFO  time: ran 'sbt bloopInstall' in 6.02s
2024.10.16 16:03:41 ERROR sbt command failed: C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals8928606632208954940\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.10.16 16:03:41 INFO  Disconnecting from Bloop session...
2024.10.16 16:03:41 INFO  Shut down connection with build server.
2024.10.16 16:03:41 INFO  Shut down connection with build server.
2024.10.16 16:03:41 INFO  Attempting to connect to the build server...
2024.10.16 16:03:41 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 16:03:41 INFO  Attempting to connect to the build server...
2024.10.16 16:03:41 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 16:03:41 INFO  time: Connected to build server in 57ms
2024.10.16 16:03:41 INFO  Connected to Build server: Bloop v1.6.0
2024.10.16 16:03:41 INFO  running doctor check
2024.10.16 16:03:41 INFO  java targets: spark-datos-energia-build
2024.10.16 16:03:43 INFO  time: indexed workspace in 1.1s
2024.10.16 16:03:43 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 16:03:43 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala
2024.10.16 16:04:26 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:04:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:04:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:04:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:04:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:04:32 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:04:32 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:04:46 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:05:49 INFO  running 'C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals10259471946535668653\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.16 16:05:50 INFO  [info] welcome to sbt 1.10.2 (Oracle Corporation Java 1.8.0_202)
2024.10.16 16:05:50 INFO  [info] loading global plugins from C:\Users\jalva\.sbt\1.0\plugins
2024.10.16 16:05:51 INFO  [info] loading settings for project spark-datos-energia-build-build from metals.sbt ...
2024.10.16 16:05:51 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project\project
2024.10.16 16:05:51 INFO  [info] loading settings for project spark-datos-energia-build from metals.sbt ...
2024.10.16 16:05:51 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project
2024.10.16 16:05:53 INFO  [success] Generated .bloop\spark-datos-energia-build.json
2024.10.16 16:05:53 INFO  [success] Total time: 2 s, completed 16-oct-2024 16:05:54
2024.10.16 16:05:55 INFO  [info] loading settings for project root from build.sbt ...
2024.10.16 16:05:55 INFO  [info] set current project to spark-datos-energia (in build file:/C:/Proyectos/spark-datos-energia/)
2024.10.16 16:05:59 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.10.16 16:05:59 INFO  [error] java.lang.RuntimeException: expected `spark-datos-energia/scalaVersion` to be "2.13.15" or later,
2024.10.16 16:05:59 INFO  [error] but found "2.13.12"; upgrade scalaVersion to fix the build.
2024.10.16 16:05:59 INFO  [error] 
2024.10.16 16:05:59 INFO  [error] to support backwards-only binary compatibility (SIP-51),
2024.10.16 16:05:59 INFO  [error] the Scala 2.13 compiler cannot be older than scala-library on the
2024.10.16 16:05:59 INFO  [error] dependency classpath.
2024.10.16 16:05:59 INFO  [error] see `spark-datos-energia/evicted` to know why scala-library 2.13.15 is getting pulled in.
2024.10.16 16:05:59 INFO  [error] 
2024.10.16 16:05:59 INFO  [error] 	at scala.sys.package$.error(package.scala:30)
2024.10.16 16:05:59 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$14(Defaults.scala:1195)
2024.10.16 16:05:59 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$14$adapted(Defaults.scala:1184)
2024.10.16 16:05:59 INFO  [error] 	at scala.Option.foreach(Option.scala:407)
2024.10.16 16:05:59 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$12(Defaults.scala:1184)
2024.10.16 16:05:59 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$12$adapted(Defaults.scala:1182)
2024.10.16 16:05:59 INFO  [error] 	at scala.collection.Iterator.foreach(Iterator.scala:943)
2024.10.16 16:05:59 INFO  [error] 	at scala.collection.Iterator.foreach$(Iterator.scala:943)
2024.10.16 16:05:59 INFO  [error] 	at scala.collection.AbstractIterator.foreach(Iterator.scala:1431)
2024.10.16 16:05:59 INFO  [error] 	at scala.collection.IterableLike.foreach(IterableLike.scala:74)
2024.10.16 16:05:59 INFO  [error] 	at scala.collection.IterableLike.foreach$(IterableLike.scala:73)
2024.10.16 16:05:59 INFO  [error] 	at scala.collection.AbstractIterable.foreach(Iterable.scala:56)
2024.10.16 16:05:59 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$11(Defaults.scala:1182)
2024.10.16 16:05:59 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$11$adapted(Defaults.scala:1181)
2024.10.16 16:05:59 INFO  [error] 	at scala.Option.foreach(Option.scala:407)
2024.10.16 16:05:59 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$1(Defaults.scala:1181)
2024.10.16 16:05:59 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.10.16 16:05:59 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.10.16 16:05:59 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.10.16 16:05:59 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.10.16 16:05:59 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.10.16 16:05:59 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.10.16 16:05:59 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.10.16 16:05:59 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.10.16 16:05:59 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.10.16 16:05:59 INFO  [error] 	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
2024.10.16 16:05:59 INFO  [error] 	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
2024.10.16 16:05:59 INFO  [error] 	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
2024.10.16 16:05:59 INFO  [error] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
2024.10.16 16:05:59 INFO  [error] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
2024.10.16 16:05:59 INFO  [error] 	at java.lang.Thread.run(Thread.java:748)
2024.10.16 16:05:59 INFO  [error] (scalaInstance) expected `spark-datos-energia/scalaVersion` to be "2.13.15" or later,
2024.10.16 16:05:59 INFO  [error] but found "2.13.12"; upgrade scalaVersion to fix the build.
2024.10.16 16:05:59 INFO  [error] 
2024.10.16 16:05:59 INFO  [error] to support backwards-only binary compatibility (SIP-51),
2024.10.16 16:05:59 INFO  [error] the Scala 2.13 compiler cannot be older than scala-library on the
2024.10.16 16:05:59 INFO  [error] dependency classpath.
2024.10.16 16:05:59 INFO  [error] see `spark-datos-energia/evicted` to know why scala-library 2.13.15 is getting pulled in.
2024.10.16 16:05:59 INFO  [error] Total time: 4 s, completed 16-oct-2024 16:05:59
2024.10.16 16:05:59 INFO  time: ran 'sbt bloopInstall' in 10s
2024.10.16 16:05:59 ERROR sbt command failed: C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals10259471946535668653\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.10.16 16:05:59 INFO  Disconnecting from Bloop session...
2024.10.16 16:05:59 INFO  Shut down connection with build server.
2024.10.16 16:05:59 INFO  Shut down connection with build server.
2024.10.16 16:05:59 INFO  Attempting to connect to the build server...
2024.10.16 16:05:59 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 16:05:59 INFO  Attempting to connect to the build server...
2024.10.16 16:05:59 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 16:05:59 INFO  time: Connected to build server in 43ms
2024.10.16 16:05:59 INFO  Connected to Build server: Bloop v1.6.0
2024.10.16 16:05:59 INFO  running doctor check
2024.10.16 16:05:59 INFO  java targets: spark-datos-energia-build
2024.10.16 16:06:00 INFO  time: indexed workspace in 1.15s
2024.10.16 16:06:00 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 16:06:00 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala
2024.10.16 16:06:01 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:02 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:02 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:06:05 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_16-06-05-669.md
2024.10.16 16:06:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:06 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:05 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:07 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:08 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:10 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:06:12 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_16-06-12-826.md
2024.10.16 16:06:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:06:13 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_16-06-13-416.md
2024.10.16 16:06:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:14 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:16 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 16:06:16 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:33 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:33 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:33 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:38 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:06:40 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 16:06:40 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:07:28 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:07:29 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 16:07:29 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:07:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:07:31 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:07:34 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:07:36 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:07:43 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:09:10 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:09:12 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:09:15 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:09:15 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:09:23 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:09:27 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:10:08 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:10:08 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:10:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:10:15 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:10:15 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:10:15 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:10:15 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:10:17 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 16:10:17 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:10:18 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 2.12.19
oct 16, 2024 4:10:25 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_(spark-datos-energia-build)_16-10-25-605.md
oct 16, 2024 4:10:27 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_(spark-datos-energia-build)_16-10-27-134.md
oct 16, 2024 4:10:27 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_(spark-datos-energia-build)_16-10-27-500.md
oct 16, 2024 4:10:28 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_(spark-datos-energia-build)_16-10-28-259.md
oct 16, 2024 4:10:40 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_(spark-datos-energia-build)_16-10-40-821.md
oct 16, 2024 4:10:41 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_(spark-datos-energia-build)_16-10-41-185.md
oct 16, 2024 4:10:41 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_(spark-datos-energia-build)_16-10-41-773.md
oct 16, 2024 4:10:42 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_(spark-datos-energia-build)_16-10-42-285.md
2024.10.16 16:10:51 INFO  skipping build import with status 'Installed'
2024.10.16 16:10:51 INFO  Disconnecting from Bloop session...
2024.10.16 16:10:51 INFO  Cancelling compilation on Bloop server
2024.10.16 16:10:51 INFO  Shut down connection with build server.
2024.10.16 16:10:51 INFO  no build target found for C:\Proyectos\spark-datos-energia\build.sbt. Using presentation compiler with project's scala-library version: 2.12.19
2024.10.16 16:10:51 INFO  Shut down connection with build server.
2024.10.16 16:10:51 INFO  Attempting to connect to the build server...
2024.10.16 16:10:51 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 16:10:51 INFO  Attempting to connect to the build server...
2024.10.16 16:10:51 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 16:10:51 INFO  time: Connected to build server in 36ms
2024.10.16 16:10:51 INFO  Connected to Build server: Bloop v1.6.0
2024.10.16 16:10:51 INFO  running doctor check
2024.10.16 16:10:51 INFO  java targets: spark-datos-energia-build
2024.10.16 16:10:52 INFO  time: indexed workspace in 1.17s
2024.10.16 16:10:52 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 16:10:52 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala
2024.10.16 16:11:06 INFO  running 'C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals2369163214754066189\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.16 16:11:08 INFO  [info] welcome to sbt 1.10.2 (Oracle Corporation Java 1.8.0_202)
2024.10.16 16:11:08 INFO  [info] loading global plugins from C:\Users\jalva\.sbt\1.0\plugins
2024.10.16 16:11:09 INFO  [info] loading settings for project spark-datos-energia-build-build from metals.sbt ...
2024.10.16 16:11:09 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project\project
2024.10.16 16:11:09 INFO  [info] loading settings for project spark-datos-energia-build from metals.sbt ...
2024.10.16 16:11:09 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project
2024.10.16 16:11:11 INFO  [success] Generated .bloop\spark-datos-energia-build.json
2024.10.16 16:11:11 INFO  [success] Total time: 2 s, completed 16-oct-2024 16:11:11
2024.10.16 16:11:13 INFO  [info] loading settings for project root from build.sbt ...
2024.10.16 16:11:13 INFO  [info] set current project to spark-datos-energia (in build file:/C:/Proyectos/spark-datos-energia/)
2024.10.16 16:11:13 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.10.16 16:11:13 INFO  [error] java.lang.RuntimeException: expected `spark-datos-energia/scalaVersion` to be "2.13.15" or later,
2024.10.16 16:11:13 INFO  [error] but found "2.13.12"; upgrade scalaVersion to fix the build.
2024.10.16 16:11:13 INFO  [error] 
2024.10.16 16:11:13 INFO  [error] to support backwards-only binary compatibility (SIP-51),
2024.10.16 16:11:13 INFO  [error] the Scala 2.13 compiler cannot be older than scala-library on the
2024.10.16 16:11:13 INFO  [error] dependency classpath.
2024.10.16 16:11:13 INFO  [error] see `spark-datos-energia/evicted` to know why scala-library 2.13.15 is getting pulled in.
2024.10.16 16:11:13 INFO  [error] 
2024.10.16 16:11:13 INFO  [error] 	at scala.sys.package$.error(package.scala:30)
2024.10.16 16:11:13 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$14(Defaults.scala:1195)
2024.10.16 16:11:13 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$14$adapted(Defaults.scala:1184)
2024.10.16 16:11:13 INFO  [error] 	at scala.Option.foreach(Option.scala:407)
2024.10.16 16:11:13 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$12(Defaults.scala:1184)
2024.10.16 16:11:13 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$12$adapted(Defaults.scala:1182)
2024.10.16 16:11:13 INFO  [error] 	at scala.collection.Iterator.foreach(Iterator.scala:943)
2024.10.16 16:11:13 INFO  [error] 	at scala.collection.Iterator.foreach$(Iterator.scala:943)
2024.10.16 16:11:13 INFO  [error] 	at scala.collection.AbstractIterator.foreach(Iterator.scala:1431)
2024.10.16 16:11:13 INFO  [error] 	at scala.collection.IterableLike.foreach(IterableLike.scala:74)
2024.10.16 16:11:13 INFO  [error] 	at scala.collection.IterableLike.foreach$(IterableLike.scala:73)
2024.10.16 16:11:13 INFO  [error] 	at scala.collection.AbstractIterable.foreach(Iterable.scala:56)
2024.10.16 16:11:13 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$11(Defaults.scala:1182)
2024.10.16 16:11:13 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$11$adapted(Defaults.scala:1181)
2024.10.16 16:11:13 INFO  [error] 	at scala.Option.foreach(Option.scala:407)
2024.10.16 16:11:13 INFO  [error] 	at sbt.Defaults$.$anonfun$scalaInstanceFromUpdate$1(Defaults.scala:1181)
2024.10.16 16:11:13 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.10.16 16:11:13 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.10.16 16:11:13 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.10.16 16:11:13 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.10.16 16:11:13 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.10.16 16:11:13 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.10.16 16:11:13 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.10.16 16:11:13 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.10.16 16:11:13 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.10.16 16:11:13 INFO  [error] 	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
2024.10.16 16:11:13 INFO  [error] 	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
2024.10.16 16:11:13 INFO  [error] 	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
2024.10.16 16:11:13 INFO  [error] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
2024.10.16 16:11:13 INFO  [error] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
2024.10.16 16:11:13 INFO  [error] 	at java.lang.Thread.run(Thread.java:748)
2024.10.16 16:11:13 INFO  [error] (scalaInstance) expected `spark-datos-energia/scalaVersion` to be "2.13.15" or later,
2024.10.16 16:11:13 INFO  [error] but found "2.13.12"; upgrade scalaVersion to fix the build.
2024.10.16 16:11:13 INFO  [error] 
2024.10.16 16:11:13 INFO  [error] to support backwards-only binary compatibility (SIP-51),
2024.10.16 16:11:13 INFO  [error] the Scala 2.13 compiler cannot be older than scala-library on the
2024.10.16 16:11:13 INFO  [error] dependency classpath.
2024.10.16 16:11:13 INFO  [error] see `spark-datos-energia/evicted` to know why scala-library 2.13.15 is getting pulled in.
2024.10.16 16:11:13 INFO  [error] Total time: 1 s, completed 16-oct-2024 16:11:14
2024.10.16 16:11:14 INFO  time: ran 'sbt bloopInstall' in 7.11s
2024.10.16 16:11:14 ERROR sbt command failed: C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals2369163214754066189\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.10.16 16:11:14 INFO  Disconnecting from Bloop session...
2024.10.16 16:11:14 INFO  Shut down connection with build server.
2024.10.16 16:11:14 INFO  Shut down connection with build server.
2024.10.16 16:11:14 INFO  Attempting to connect to the build server...
2024.10.16 16:11:14 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 16:11:14 INFO  Attempting to connect to the build server...
2024.10.16 16:11:14 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 16:11:14 INFO  time: Connected to build server in 52ms
2024.10.16 16:11:14 INFO  Connected to Build server: Bloop v1.6.0
2024.10.16 16:11:14 INFO  running doctor check
2024.10.16 16:11:14 INFO  java targets: spark-datos-energia-build
2024.10.16 16:11:15 INFO  time: indexed workspace in 1.04s
2024.10.16 16:11:15 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala
2024.10.16 16:11:15 WARN  no build target for: C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.16 16:12:22 INFO  running 'C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals3295453907012747563\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.16 16:12:24 INFO  [info] welcome to sbt 1.10.2 (Oracle Corporation Java 1.8.0_202)
2024.10.16 16:12:24 INFO  [info] loading global plugins from C:\Users\jalva\.sbt\1.0\plugins
2024.10.16 16:12:25 INFO  [info] loading settings for project spark-datos-energia-build-build from metals.sbt ...
2024.10.16 16:12:25 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project\project
2024.10.16 16:12:25 INFO  [info] loading settings for project spark-datos-energia-build from metals.sbt ...
2024.10.16 16:12:25 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project
2024.10.16 16:12:27 INFO  [success] Generated .bloop\spark-datos-energia-build.json
2024.10.16 16:12:27 INFO  [success] Total time: 2 s, completed 16-oct-2024 16:12:27
2024.10.16 16:12:28 INFO  [info] loading settings for project root from build.sbt ...
2024.10.16 16:12:28 INFO  [info] set current project to spark-datos-energia (in build file:/C:/Proyectos/spark-datos-energia/)
2024.10.16 16:12:32 INFO  [success] Generated .bloop\root.json
2024.10.16 16:12:32 INFO  [success] Generated .bloop\root-test.json
2024.10.16 16:12:32 INFO  [success] Total time: 3 s, completed 16-oct-2024 16:12:32
2024.10.16 16:12:32 INFO  time: ran 'sbt bloopInstall' in 9.11s
2024.10.16 16:12:32 INFO  Disconnecting from Bloop session...
2024.10.16 16:12:32 INFO  Shut down connection with build server.
2024.10.16 16:12:32 INFO  Shut down connection with build server.
2024.10.16 16:12:32 INFO  Attempting to connect to the build server...
2024.10.16 16:12:33 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 16:12:33 INFO  Attempting to connect to the build server...
2024.10.16 16:12:33 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 16:12:33 INFO  time: Connected to build server in 1.72s
2024.10.16 16:12:33 INFO  Connected to Build server: Bloop v1.6.0
2024.10.16 16:12:33 INFO  running doctor check
2024.10.16 16:12:33 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.16 16:12:37 INFO  compiling root (3 scala sources)
2024.10.16 16:12:39 INFO  time: compiled root in 1.95s
oct 16, 2024 4:12:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 12350
oct 16, 2024 4:12:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 12351
oct 16, 2024 4:12:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 12355
2024.10.16 16:12:46 INFO  time: indexed workspace in 12s
2024.10.16 16:12:46 INFO  compiling root (3 scala sources)
2024.10.16 16:12:46 INFO  time: compiled root in 0.38s
2024.10.16 16:12:46 INFO  compiling root (3 scala sources)
2024.10.16 16:12:47 INFO  time: compiled root in 0.42s
2024.10.16 16:12:56 INFO  compiling root (3 scala sources)
2024.10.16 16:12:58 INFO  time: compiled root in 1.51s
something's wrong: no file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/ApiDataIngestion.scala in Option[<error>]RangePosition(file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/ApiDataIngestion.scala, 272, 272, 288)
something's wrong: no file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/ApiDataIngestion.scala in Option[<error>]RangePosition(file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/ApiDataIngestion.scala, 272, 272, 281)
something's wrong: no file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/ApiDataIngestion.scala in Option[<error>]RangePosition(file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/ApiDataIngestion.scala, 272, 272, 282)
oct 16, 2024 4:13:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 12760
oct 16, 2024 4:14:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 13007
2024.10.16 16:15:06 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.16 16:15:07 INFO  no build target found for /scala/Predef.scala. Using presentation compiler with project's scala-library version: 3.3.3
oct 16, 2024 4:15:09 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\jalva\AppData\Local\Temp\fallback-service8746810634179966999\.metals\.reports\metals-full\2024-10-16\r_compiler-error_16-15-09-071.md
2024.10.16 16:15:48 INFO  no build target found for /scala/Predef.scala. Using presentation compiler with project's scala-library version: 3.3.3
oct 16, 2024 4:15:48 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\jalva\AppData\Local\Temp\fallback-service8746810634179966999\.metals\.reports\metals-full\2024-10-16\r_compiler-error_16-15-48-841.md
2024.10.16 16:15:50 INFO  compiling root (1 scala source)
2024.10.16 16:15:50 INFO  time: compiled root in 0.27s
2024.10.16 16:16:14 INFO  compiling root (1 scala source)
2024.10.16 16:16:14 INFO  time: compiled root in 0.2s
2024.10.16 16:16:21 INFO  compiling root (1 scala source)
2024.10.16 16:16:21 INFO  time: compiled root in 0.21s
oct 16, 2024 4:17:20 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 13525
2024.10.16 16:21:05 INFO  compiling root (1 scala source)
2024.10.16 16:21:05 INFO  time: compiled root in 0.85s
2024.10.16 17:02:00 INFO  Shutting down server
2024.10.16 17:02:00 INFO  shutting down Metals
2024.10.16 17:02:00 INFO  Shut down connection with build server.
2024.10.16 17:02:00 INFO  Shut down connection with build server.
2024.10.16 17:02:00 INFO  Exiting server
2024.10.16 17:02:12 INFO  Started: Metals version 1.3.5 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.94.2.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@6193620c]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@3aaf5871]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@6193620c]
2024.10.16 17:02:12 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.16 17:02:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.16 17:02:13 INFO  Attempting to connect to the build server...
2024.10.16 17:02:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 17:02:13 INFO  Attempting to connect to the build server...
2024.10.16 17:02:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 17:02:13 INFO  time: Connected to build server in 0.81s
2024.10.16 17:02:13 INFO  Connected to Build server: Bloop v1.6.0
2024.10.16 17:02:14 INFO  time: Imported build in 0.11s
2024.10.16 17:02:14 INFO  running doctor check
2024.10.16 17:02:14 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.16 17:02:20 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.16 17:02:23 INFO  time: indexed workspace in 8.46s
2024.10.16 17:02:23 INFO  compiling root-test (1 scala source)
2024.10.16 17:02:23 INFO  time: compiled root-test in 0.8s
2024.10.16 17:02:41 INFO  running 'C:\Program Files\Java\jdk1.8.0_202\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals18385053547379420284\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.16 17:02:42 INFO  [info] welcome to sbt 1.10.2 (Oracle Corporation Java 1.8.0_202)
2024.10.16 17:02:42 INFO  [info] loading global plugins from C:\Users\jalva\.sbt\1.0\plugins
2024.10.16 17:02:44 INFO  [info] loading settings for project spark-datos-energia-build-build from metals.sbt ...
2024.10.16 17:02:44 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project\project
2024.10.16 17:02:44 INFO  [info] loading settings for project spark-datos-energia-build from metals.sbt ...
2024.10.16 17:02:44 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project
2024.10.16 17:02:45 INFO  [success] Generated .bloop\spark-datos-energia-build.json
2024.10.16 17:02:45 INFO  [success] Total time: 2 s, completed 16-oct-2024 17:02:46
2024.10.16 17:02:45 INFO  [info] loading settings for project root from build.sbt ...
2024.10.16 17:02:45 INFO  [info] set current project to spark-datos-energia (in build file:/C:/Proyectos/spark-datos-energia/)
2024.10.16 17:02:48 INFO  [success] Generated .bloop\root.json
2024.10.16 17:02:48 INFO  [success] Generated .bloop\root-test.json
2024.10.16 17:02:48 INFO  [success] Total time: 1 s, completed 16-oct-2024 17:02:48
2024.10.16 17:02:48 INFO  time: ran 'sbt bloopInstall' in 7.14s
2024.10.16 17:02:48 INFO  Disconnecting from Bloop session...
2024.10.16 17:02:48 INFO  Shut down connection with build server.
2024.10.16 17:02:48 INFO  Shut down connection with build server.
2024.10.16 17:02:48 INFO  Attempting to connect to the build server...
2024.10.16 17:02:48 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 17:02:48 INFO  Attempting to connect to the build server...
2024.10.16 17:02:48 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 17:02:48 INFO  time: Connected to build server in 69ms
2024.10.16 17:02:48 INFO  Connected to Build server: Bloop v1.6.0
2024.10.16 17:02:48 INFO  running doctor check
2024.10.16 17:02:48 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.16 17:02:50 INFO  time: indexed workspace in 2.47s
2024.10.16 17:04:30 INFO  Shutting down server
2024.10.16 17:04:30 INFO  shutting down Metals
2024.10.16 17:04:30 INFO  Shut down connection with build server.
2024.10.16 17:04:30 INFO  Shut down connection with build server.
2024.10.16 17:04:30 INFO  Exiting server
2024.10.16 17:04:37 INFO  Started: Metals version 1.3.5 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.94.2.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@23eb989a]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@57e91981]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@23eb989a]
2024.10.16 17:04:37 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.16 17:04:38 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.16 17:04:38 INFO  Attempting to connect to the build server...
2024.10.16 17:04:39 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 17:04:39 INFO  Attempting to connect to the build server...
2024.10.16 17:04:39 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 17:04:39 INFO  time: Connected to build server in 0.84s
2024.10.16 17:04:39 INFO  Connected to Build server: Bloop v1.6.0
2024.10.16 17:04:39 INFO  time: Imported build in 0.41s
2024.10.16 17:04:39 INFO  running doctor check
2024.10.16 17:04:39 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.16 17:04:42 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.16 17:04:52 INFO  time: indexed workspace in 12s
oct 16, 2024 5:05:47 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
2024.10.16 17:06:19 INFO  Shutting down server
2024.10.16 17:06:19 INFO  shutting down Metals
2024.10.16 17:06:19 INFO  Shut down connection with build server.
2024.10.16 17:06:19 INFO  Shut down connection with build server.
2024.10.16 17:06:19 INFO  Exiting server
2024.10.16 17:06:37 INFO  Started: Metals version 1.3.5 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.94.2.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@23eb989a]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@57e91981]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@23eb989a]
2024.10.16 17:06:37 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.16 17:06:38 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.16 17:06:39 INFO  Attempting to connect to the build server...
2024.10.16 17:06:39 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 17:06:39 INFO  Attempting to connect to the build server...
2024.10.16 17:06:39 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 17:06:39 INFO  time: Connected to build server in 0.74s
2024.10.16 17:06:39 INFO  Connected to Build server: Bloop v1.6.0
2024.10.16 17:06:39 INFO  time: Imported build in 0.11s
2024.10.16 17:06:40 INFO  running doctor check
2024.10.16 17:06:40 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.16 17:06:46 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.16 17:06:48 INFO  time: indexed workspace in 8.13s
2024.10.16 17:09:29 INFO  running 'C:\Program Files\Eclipse Adoptium\jdk-11.0.24.8-hotspot\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals9373823817832719899\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.16 17:09:31 INFO  [info] welcome to sbt 1.10.2 (Eclipse Adoptium Java 11.0.24)
2024.10.16 17:09:33 INFO  [info] loading global plugins from C:\Users\jalva\.sbt\1.0\plugins
2024.10.16 17:09:34 INFO  [info] loading settings for project spark-datos-energia-build-build from metals.sbt ...
2024.10.16 17:09:34 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project\project
2024.10.16 17:09:34 INFO  [info] loading settings for project spark-datos-energia-build from metals.sbt ...
2024.10.16 17:09:34 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project
2024.10.16 17:09:36 INFO  [success] Generated .bloop\spark-datos-energia-build.json
2024.10.16 17:09:36 INFO  [info] compiling 1 Scala source to C:\Proyectos\spark-datos-energia\project\target\scala-2.12\sbt-1.0\classes ...
2024.10.16 17:09:36 INFO  [info] Non-compiled module 'compiler-bridge_2.12' for Scala 2.12.19. Compiling...
2024.10.16 17:09:45 INFO  [info]   Compilation completed in 8.41s.
2024.10.16 17:09:45 INFO  [info] done compiling
2024.10.16 17:09:46 INFO  [success] Total time: 12 s, completed 16 oct. 2024 17:09:46
2024.10.16 17:09:49 INFO  [info] loading settings for project root from build.sbt ...
2024.10.16 17:09:49 INFO  [info] set current project to spark-datos-energia (in build file:/C:/Proyectos/spark-datos-energia/)
2024.10.16 17:09:50 INFO  [success] Generated .bloop\root-test.json
2024.10.16 17:09:50 INFO  [success] Generated .bloop\root.json
2024.10.16 17:09:50 INFO  [success] Total time: 2 s, completed 16 oct. 2024 17:09:50
2024.10.16 17:09:50 INFO  time: ran 'sbt bloopInstall' in 21s
2024.10.16 17:09:50 INFO  Disconnecting from Bloop session...
2024.10.16 17:09:50 INFO  Shut down connection with build server.
2024.10.16 17:09:50 INFO  Shut down connection with build server.
2024.10.16 17:09:50 INFO  Attempting to connect to the build server...
2024.10.16 17:09:50 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 17:09:50 INFO  Attempting to connect to the build server...
2024.10.16 17:09:50 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 17:09:50 INFO  time: Connected to build server in 84ms
2024.10.16 17:09:50 INFO  Connected to Build server: Bloop v1.6.0
2024.10.16 17:09:50 INFO  running doctor check
2024.10.16 17:09:50 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.16 17:09:54 INFO  time: indexed workspace in 3.1s
2024.10.16 17:11:29 INFO  compiling root (3 scala sources)
2024.10.16 17:11:30 INFO  time: compiled root in 1.52s
2024.10.16 17:11:30 INFO  compiling root-test (1 scala source)
2024.10.16 17:11:30 INFO  time: compiled root-test in 0.24s
2024.10.16 17:13:13 INFO  Shutting down server
2024.10.16 17:13:13 INFO  shutting down Metals
2024.10.16 17:13:13 INFO  Shut down connection with build server.
2024.10.16 17:13:13 INFO  Shut down connection with build server.
2024.10.16 17:13:13 INFO  Exiting server
2024.10.16 17:16:12 INFO  Started: Metals version 1.3.5 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.94.2.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@23eb989a]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@57e91981]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@23eb989a]
2024.10.16 17:16:12 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.16 17:16:13 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.16 17:16:14 INFO  Attempting to connect to the build server...
2024.10.16 17:16:19 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.16 17:16:20 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 17:16:20 INFO  Attempting to connect to the build server...
2024.10.16 17:16:20 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.16 17:16:20 INFO  time: Connected to build server in 6.49s
2024.10.16 17:16:20 INFO  Connected to Build server: Bloop v1.6.0
2024.10.16 17:16:20 INFO  time: Imported build in 0.14s
2024.10.16 17:16:20 INFO  running doctor check
2024.10.16 17:16:20 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.16 17:16:23 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.16 17:16:25 INFO  time: indexed workspace in 4.6s
2024.10.16 17:16:45 INFO  compiling spark-datos-energia-build (1 scala source)
2024.10.16 17:16:48 INFO  time: code lens generation in 2.18s
2024.10.16 17:16:48 INFO  time: compiled spark-datos-energia-build in 2.99s
oct 16, 2024 5:23:44 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 351
2024.10.16 17:24:25 INFO  compiling root (1 scala source)
2024.10.16 17:24:28 INFO  time: compiled root in 2.62s
oct 16, 2024 5:28:43 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 494
oct 16, 2024 5:32:47 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_(root)_17-32-47-771.md
oct 16, 2024 5:32:48 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_(root)_17-32-48-019.md
oct 16, 2024 5:32:48 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-16\r_compiler-error_(root)_17-32-48-157.md
oct 16, 2024 5:32:55 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 727
2024.10.16 17:34:00 INFO  compiling root (1 scala source)
2024.10.16 17:34:01 INFO  time: compiled root in 1.12s
2024.10.16 17:36:36 INFO  compiling root (1 scala source)
2024.10.16 17:36:38 INFO  time: compiled root in 1.86s
2024.10.16 17:40:41 INFO  compiling root (1 scala source)
2024.10.16 17:40:41 INFO  time: compiled root in 0.89s
2024.10.16 17:42:24 INFO  compiling root (1 scala source)
2024.10.16 17:42:24 INFO  time: compiled root in 0.8s
oct 16, 2024 5:46:01 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 2264
2024.10.16 17:49:34 INFO  compiling root (1 scala source)
2024.10.16 17:49:34 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.16 17:49:34 INFO  time: compiled root in 0.78s
2024.10.16 17:54:08 INFO  compiling root (1 scala source)
2024.10.16 17:54:08 INFO  time: compiled root in 0.27s
oct 16, 2024 6:01:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3453
oct 16, 2024 6:01:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3455
2024.10.16 18:01:18 INFO  compiling root (1 scala source)
2024.10.16 18:01:18 INFO  time: compiled root in 0.24s
oct 16, 2024 6:01:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3490
oct 16, 2024 6:01:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3491
oct 16, 2024 6:01:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3496
2024.10.16 18:01:57 INFO  compiling root (1 scala source)
2024.10.16 18:01:57 INFO  time: compiled root in 0.23s
2024.10.16 18:02:08 INFO  compiling root (1 scala source)
2024.10.16 18:02:08 INFO  time: compiled root in 0.25s
oct 16, 2024 6:02:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3564
2024.10.16 18:03:06 INFO  compiling root (1 scala source)
2024.10.16 18:03:06 INFO  time: compiled root in 0.21s
2024.10.16 18:05:51 INFO  compiling root (3 scala sources)
2024.10.16 18:05:51 INFO  time: compiled root in 0.24s
2024.10.16 18:15:04 INFO  compiling root (3 scala sources)
2024.10.16 18:15:04 INFO  time: compiled root in 0.26s
2024.10.16 18:15:17 INFO  compiling root (3 scala sources)
2024.10.16 18:15:17 INFO  time: compiled root in 0.24s
2024.10.16 18:18:26 INFO  compiling root (3 scala sources)
2024.10.16 18:18:26 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.16 18:18:26 INFO  time: compiled root in 0.96s
oct 16, 2024 7:31:52 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4133
oct 16, 2024 7:38:43 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4200
2024.10.16 19:40:08 INFO  compiling root (1 scala source)
2024.10.16 19:40:08 INFO  time: compiled root in 0.23s
2024.10.16 19:41:30 INFO  compiling root (1 scala source)
2024.10.16 19:41:30 INFO  time: compiled root in 0.23s
2024.10.16 19:41:51 INFO  compiling root (1 scala source)
2024.10.16 19:41:51 INFO  time: compiled root in 0.22s
2024.10.16 19:41:53 INFO  compiling root (1 scala source)
2024.10.16 19:41:53 INFO  time: compiled root in 0.19s
oct 16, 2024 7:42:06 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4601
oct 16, 2024 7:42:06 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4602
oct 16, 2024 7:42:06 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4607
2024.10.16 19:42:09 INFO  compiling root (1 scala source)
2024.10.16 19:42:09 INFO  time: compiled root in 0.22s
2024.10.16 19:43:42 INFO  compiling root (1 scala source)
2024.10.16 19:43:42 INFO  time: compiled root in 0.19s
2024.10.16 19:44:01 INFO  compiling root (1 scala source)
2024.10.16 19:44:01 INFO  time: compiled root in 0.22s
2024.10.16 19:44:43 INFO  compiling root (1 scala source)
2024.10.16 19:44:43 INFO  time: compiled root in 0.19s
2024.10.16 19:45:12 INFO  compiling root (1 scala source)
2024.10.16 19:45:12 INFO  time: compiled root in 0.2s
2024.10.16 19:45:40 INFO  compiling root (1 scala source)
2024.10.16 19:45:40 INFO  time: compiled root in 0.19s
2024.10.16 19:45:51 INFO  compiling root (1 scala source)
2024.10.16 19:45:51 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.16 19:45:51 INFO  time: compiled root in 0.71s
2024.10.16 19:47:05 INFO  compiling root (1 scala source)
2024.10.16 19:47:05 INFO  time: compiled root in 0.22s
oct 16, 2024 7:48:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5352
2024.10.16 19:48:10 INFO  compiling root (1 scala source)
2024.10.16 19:48:10 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.16 19:48:10 INFO  time: compiled root in 0.9s
2024.10.16 19:48:28 INFO  compiling root (1 scala source)
2024.10.16 19:48:28 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.16 19:48:28 INFO  time: compiled root in 0.73s
oct 16, 2024 10:22:18 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5515
2024.10.16 22:24:11 INFO  compiling root (1 scala source)
2024.10.16 22:24:11 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.16 22:24:11 INFO  time: compiled root in 0.71s
oct 16, 2024 10:25:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6003
oct 16, 2024 10:26:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6324
2024.10.16 22:28:14 INFO  compiling root (1 scala source)
2024.10.16 22:28:14 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.16 22:28:14 INFO  time: compiled root in 0.77s
2024.10.17 01:58:52 INFO  compiling root (1 scala source)
2024.10.17 01:58:52 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.17 01:58:52 INFO  time: compiled root in 0.88s
2024.10.17 02:03:21 INFO  compiling root (1 scala source)
2024.10.17 02:03:21 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.17 02:03:21 INFO  time: compiled root in 0.7s
oct 17, 2024 2:04:31 A. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-17\r_compiler-error_(spark-datos-energia-build)_02-04-31-869.md
2024.10.17 02:05:21 INFO  running 'C:\Program Files\Eclipse Adoptium\jdk-11.0.24.8-hotspot\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals3695660052436701466\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.17 02:05:23 INFO  [info] welcome to sbt 1.10.2 (Eclipse Adoptium Java 11.0.24)
2024.10.17 02:05:24 INFO  [info] loading global plugins from C:\Users\jalva\.sbt\1.0\plugins
2024.10.17 02:05:25 INFO  [info] loading settings for project spark-datos-energia-build-build from metals.sbt ...
2024.10.17 02:05:25 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project\project
2024.10.17 02:05:25 INFO  [info] loading settings for project spark-datos-energia-build from metals.sbt ...
2024.10.17 02:05:25 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project
2024.10.17 02:05:28 INFO  [success] Generated .bloop\spark-datos-energia-build.json
2024.10.17 02:05:28 INFO  [success] Total time: 2 s, completed 17 oct. 2024 2:05:28
2024.10.17 02:05:30 INFO  [info] loading settings for project root from build.sbt ...
2024.10.17 02:05:30 INFO  [info] set current project to spark-datos-energia (in build file:/C:/Proyectos/spark-datos-energia/)
2024.10.17 02:05:37 INFO  [success] Generated .bloop\root.json
2024.10.17 02:05:37 INFO  [success] Generated .bloop\root-test.json
2024.10.17 02:05:37 INFO  [success] Total time: 7 s, completed 17 oct. 2024 2:05:37
2024.10.17 02:05:37 INFO  time: ran 'sbt bloopInstall' in 16s
2024.10.17 02:05:37 INFO  Disconnecting from Bloop session...
2024.10.17 02:05:37 INFO  Shut down connection with build server.
2024.10.17 02:05:37 INFO  Shut down connection with build server.
2024.10.17 02:05:37 INFO  Attempting to connect to the build server...
2024.10.17 02:05:37 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 02:05:37 INFO  Attempting to connect to the build server...
2024.10.17 02:05:37 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 02:05:37 INFO  time: Connected to build server in 77ms
2024.10.17 02:05:37 INFO  Connected to Build server: Bloop v1.6.0
2024.10.17 02:05:37 INFO  running doctor check
2024.10.17 02:05:37 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.17 02:05:48 INFO  time: indexed workspace in 10s
2024.10.17 02:06:26 INFO  Shutting down server
2024.10.17 02:06:26 INFO  shutting down Metals
2024.10.17 02:06:26 INFO  Shut down connection with build server.
2024.10.17 02:06:26 INFO  Shut down connection with build server.
2024.10.17 02:06:26 INFO  Exiting server
2024.10.17 13:26:03 INFO  Started: Metals version 1.3.5 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.94.2.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@66052b70]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@42c8ec09]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@66052b70]
2024.10.17 13:26:03 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.17 13:26:04 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.17 13:26:05 INFO  Attempting to connect to the build server...
2024.10.17 13:26:10 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 13:26:10 INFO  Attempting to connect to the build server...
2024.10.17 13:26:10 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 13:26:10 INFO  time: Connected to build server in 6.09s
2024.10.17 13:26:10 INFO  Connected to Build server: Bloop v1.6.0
2024.10.17 13:26:11 INFO  time: Imported build in 0.15s
2024.10.17 13:26:11 INFO  running doctor check
2024.10.17 13:26:11 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.17 13:26:20 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.17 13:26:32 INFO  time: indexed workspace in 21s
oct 17, 2024 7:42:19 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 192
oct 17, 2024 7:42:20 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 204
oct 17, 2024 7:43:44 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 269
oct 17, 2024 7:43:44 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 270
oct 17, 2024 7:44:40 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 345
2024.10.17 19:46:01 INFO  compiling root (1 scala source)
2024.10.17 19:46:03 INFO  time: compiled root in 2s
2024.10.17 19:46:44 INFO  compiling root (1 scala source)
2024.10.17 19:46:46 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.17 19:46:46 INFO  time: compiled root in 2.14s
2024.10.17 19:52:06 INFO  time: code lens generation in 2.48s
2024.10.17 19:52:06 INFO  time: code lens generation in 2.48s
2024.10.17 19:54:55 INFO  skipping build import with status 'Installed'
2024.10.17 19:54:55 INFO  Disconnecting from Bloop session...
2024.10.17 19:54:55 INFO  Shut down connection with build server.
2024.10.17 19:54:55 INFO  Shut down connection with build server.
2024.10.17 19:54:55 INFO  Attempting to connect to the build server...
2024.10.17 19:54:55 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 19:54:55 INFO  Attempting to connect to the build server...
2024.10.17 19:54:55 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 19:54:55 INFO  time: Connected to build server in 63ms
2024.10.17 19:54:55 INFO  Connected to Build server: Bloop v1.6.0
2024.10.17 19:54:55 INFO  time: Imported build in 0.11s
2024.10.17 19:54:55 INFO  running doctor check
2024.10.17 19:54:55 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.17 19:55:01 INFO  time: indexed workspace in 5.86s
2024.10.17 19:56:59 INFO  Shutting down server
2024.10.17 19:56:59 INFO  shutting down Metals
2024.10.17 19:56:59 INFO  Shut down connection with build server.
2024.10.17 19:56:59 INFO  Shut down connection with build server.
2024.10.17 19:56:59 INFO  Exiting server
2024.10.17 19:59:02 INFO  Started: Metals version 1.3.5 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.94.2.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@23eb989a]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@57e91981]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@23eb989a]
2024.10.17 19:59:02 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.17 19:59:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.17 19:59:02 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.17 19:59:03 INFO  Attempting to connect to the build server...
2024.10.17 19:59:03 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 19:59:03 INFO  Attempting to connect to the build server...
2024.10.17 19:59:03 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 19:59:03 INFO  time: Connected to build server in 0.85s
2024.10.17 19:59:03 INFO  Connected to Build server: Bloop v1.6.0
2024.10.17 19:59:04 INFO  time: Imported build in 0.14s
2024.10.17 19:59:05 INFO  running doctor check
2024.10.17 19:59:05 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.17 19:59:08 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.17 19:59:10 INFO  time: indexed workspace in 5.34s
oct 17, 2024 8:00:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 53
oct 17, 2024 8:00:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 56
oct 17, 2024 8:00:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 58
2024.10.17 20:01:26 INFO  compiling root (1 scala source)
2024.10.17 20:01:28 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.17 20:01:28 INFO  time: compiled root in 1.36s
2024.10.17 20:02:54 INFO  Shutting down server
2024.10.17 20:02:54 INFO  shutting down Metals
2024.10.17 20:02:54 INFO  Shut down connection with build server.
2024.10.17 20:02:54 INFO  Shut down connection with build server.
2024.10.17 20:02:54 INFO  Exiting server
2024.10.17 20:03:02 INFO  Started: Metals version 1.3.5 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.94.2.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@23eb989a]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@57e91981]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@23eb989a]
2024.10.17 20:03:02 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.17 20:03:03 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.17 20:03:03 INFO  Attempting to connect to the build server...
2024.10.17 20:03:04 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 20:03:04 INFO  Attempting to connect to the build server...
2024.10.17 20:03:04 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 20:03:04 INFO  time: Connected to build server in 0.75s
2024.10.17 20:03:04 INFO  Connected to Build server: Bloop v1.6.0
2024.10.17 20:03:04 INFO  time: Imported build in 0.12s
2024.10.17 20:03:04 INFO  running doctor check
2024.10.17 20:03:04 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.17 20:03:07 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.17 20:03:10 INFO  time: indexed workspace in 5.21s
2024.10.17 20:06:09 INFO  Shutting down server
2024.10.17 20:06:09 INFO  shutting down Metals
2024.10.17 20:06:09 INFO  Shut down connection with build server.
2024.10.17 20:06:09 INFO  Shut down connection with build server.
2024.10.17 20:06:09 INFO  Exiting server
2024.10.17 20:06:17 INFO  Started: Metals version 1.3.5 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.94.2.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@24a6a5a0]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@1134c750]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@24a6a5a0]
2024.10.17 20:06:17 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.17 20:06:18 INFO  no build target found for C:\Proyectos\spark-datos-energia\src\main\scala\example\Main.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.10.17 20:06:19 INFO  Attempting to connect to the build server...
2024.10.17 20:06:19 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 20:06:19 INFO  Attempting to connect to the build server...
2024.10.17 20:06:19 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 20:06:19 INFO  time: Connected to build server in 1.01s
2024.10.17 20:06:19 INFO  Connected to Build server: Bloop v1.6.0
2024.10.17 20:06:20 INFO  time: Imported build in 0.2s
2024.10.17 20:06:20 INFO  running doctor check
2024.10.17 20:06:20 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.17 20:06:23 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.17 20:06:26 INFO  time: indexed workspace in 5.89s
2024.10.17 20:09:04 INFO  time: code lens generation in 1.27s
2024.10.17 20:15:33 INFO  compiling root (1 scala source)
2024.10.17 20:15:34 WARN  1 deprecation (since 2.2.0); re-run with -deprecation for details
2024.10.17 20:15:34 INFO  time: compiled root in 1.1s
2024.10.17 20:17:43 INFO  compiling root (1 scala source)
2024.10.17 20:17:43 INFO  time: compiled root in 0.75s
2024.10.17 21:01:46 INFO  time: code lens generation in 1.25s
2024.10.17 21:01:50 INFO  running 'C:\Program Files\Eclipse Adoptium\jdk-11.0.24.8-hotspot\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\jalva\AppData\Local\Temp\metals13651701251634032407\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.10.17 21:01:52 INFO  [info] welcome to sbt 1.10.2 (Eclipse Adoptium Java 11.0.24)
2024.10.17 21:01:54 INFO  [info] loading global plugins from C:\Users\jalva\.sbt\1.0\plugins
2024.10.17 21:01:55 INFO  [info] loading settings for project spark-datos-energia-build-build from metals.sbt ...
2024.10.17 21:01:55 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project\project
2024.10.17 21:01:55 INFO  [info] loading settings for project spark-datos-energia-build from metals.sbt ...
2024.10.17 21:01:55 INFO  [info] loading project definition from C:\Proyectos\spark-datos-energia\project
2024.10.17 21:01:57 INFO  [success] Generated .bloop\spark-datos-energia-build.json
2024.10.17 21:01:57 INFO  [success] Total time: 2 s, completed 17 oct. 2024 21:01:58
2024.10.17 21:02:00 INFO  [info] loading settings for project root from build.sbt ...
2024.10.17 21:02:00 INFO  [info] set current project to spark-datos-energia (in build file:/C:/Proyectos/spark-datos-energia/)
2024.10.17 21:02:11 INFO  [success] Generated .bloop\root-test.json
2024.10.17 21:02:11 INFO  [success] Generated .bloop\root.json
2024.10.17 21:02:11 INFO  [success] Total time: 11 s, completed 17 oct. 2024 21:02:11
2024.10.17 21:02:11 INFO  time: ran 'sbt bloopInstall' in 20s
2024.10.17 21:02:11 INFO  Disconnecting from Bloop session...
2024.10.17 21:02:11 INFO  Shut down connection with build server.
2024.10.17 21:02:11 INFO  Shut down connection with build server.
2024.10.17 21:02:11 INFO  Attempting to connect to the build server...
2024.10.17 21:02:11 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 21:02:11 INFO  Attempting to connect to the build server...
2024.10.17 21:02:11 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.17 21:02:11 INFO  time: Connected to build server in 86ms
2024.10.17 21:02:11 INFO  Connected to Build server: Bloop v1.6.0
2024.10.17 21:02:11 INFO  running doctor check
2024.10.17 21:02:11 INFO  java targets: spark-datos-energia-build, root-test, root
2024.10.17 21:02:21 INFO  time: indexed workspace in 9.6s
2024.10.17 21:09:32 INFO  compiling root (1 scala source)
2024.10.17 21:09:32 INFO  time: compiled root in 0.9s
oct 17, 2024 9:16:10 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 917
oct 18, 2024 1:44:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1173
2024.10.18 13:45:36 INFO  compiling root (1 scala source)
2024.10.18 13:45:36 INFO  time: compiled root in 0.93s
2024.10.18 13:46:07 INFO  compiling root (1 scala source)
2024.10.18 13:46:07 INFO  time: compiled root in 0.3s
2024.10.18 13:47:30 INFO  compiling root (1 scala source)
2024.10.18 13:47:30 INFO  time: compiled root in 0.76s
oct 18, 2024 1:52:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 2398
oct 18, 2024 1:53:12 P. M. scala.meta.internal.pc.CompletionProvider expected$1
ADVERTENCIA: offset 487, count -1, length 2241
2024.10.18 14:01:46 INFO  compiling root (1 scala source)
2024.10.18 14:01:46 INFO  time: compiled root in 0.22s
2024.10.18 14:02:30 INFO  compiling root (1 scala source)
2024.10.18 14:02:30 INFO  time: compiled root in 0.22s
oct 18, 2024 2:03:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3917
2024.10.18 14:03:47 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 2:03:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.LocalTime.SECONDS_PER_DAY;\nimport static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH;\nimport static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR;\nimport static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_MONTH;\nimport static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_YEAR;\nimport static java.time.temporal.ChronoField.DAY_OF_MONTH;\nimport static java.time.temporal.ChronoField.DAY_OF_YEAR;\nimport static java.time.temporal.ChronoField.EPOCH_DAY;\nimport static java.time.temporal.ChronoField.ERA;\nimport static java.time.temporal.ChronoField.MONTH_OF_YEAR;\nimport static java.time.temporal.ChronoField.PROLEPTIC_MONTH;\nimport static java.time.temporal.ChronoField.YEAR;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.ChronoLocalDate;\nimport java.time.chrono.IsoEra;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneOffsetTransition;\nimport java.time.zone.ZoneRules;\nimport java.util.Objects;\nimport java.util.stream.LongStream;\nimport java.util.stream.Stream;\n\n/**\n * A date without a time-zone in the ISO-8601 calendar system,\n * such as {@code 2007-12-03}.\n * \u003cp\u003e\n * {@code LocalDate} is an immutable date-time object that represents a date,\n * often viewed as year-month-day. Other date fields, such as day-of-year,\n * day-of-week and week-of-year, can also be accessed.\n * For example, the value \"2nd October 2007\" can be stored in a {@code LocalDate}.\n * \u003cp\u003e\n * This class does not store or represent a time or time-zone.\n * Instead, it is a description of the date, as used for birthdays.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n * \u003cp\u003e\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today\u0027s rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code LocalDate} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class LocalDate\n        implements Temporal, TemporalAdjuster, ChronoLocalDate, Serializable {\n\n    /**\n     * The minimum supported {@code LocalDate}, \u0027-999999999-01-01\u0027.\n     * This could be used by an application as a \"far past\" date.\n     */\n    public static final LocalDate MIN \u003d LocalDate.of(Year.MIN_VALUE, 1, 1);\n    /**\n     * The maximum supported {@code LocalDate}, \u0027+999999999-12-31\u0027.\n     * This could be used by an application as a \"far future\" date.\n     */\n    public static final LocalDate MAX \u003d LocalDate.of(Year.MAX_VALUE, 12, 31);\n    /**\n     * The epoch year {@code LocalDate}, \u00271970-01-01\u0027.\n     */\n    public static final LocalDate EPOCH \u003d LocalDate.of(1970, 1, 1);\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 2942565459149668126L;\n    /**\n     * The number of days in a 400 year cycle.\n     */\n    private static final int DAYS_PER_CYCLE \u003d 146097;\n    /**\n     * The number of days from year zero to year 1970.\n     * There are five 400 year cycles from year zero to 2000.\n     * There are 7 leap years from 1970 to 2000.\n     */\n    static final long DAYS_0000_TO_1970 \u003d (DAYS_PER_CYCLE * 5L) - (30L * 365L + 7L);\n\n    /**\n     * The year.\n     */\n    private final int year;\n    /**\n     * The month-of-year.\n     */\n    private final short month;\n    /**\n     * The day-of-month.\n     */\n    private final short day;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date using the system clock and default time-zone, not null\n     */\n    public static LocalDate now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date using the system clock, not null\n     */\n    public static LocalDate now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date - today.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date, not null\n     */\n    public static LocalDate now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        return ofInstant(now, clock.getZone());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a year, month and day.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDate of(int year, Month month, int dayOfMonth) {\n        YEAR.checkValidValue(year);\n        Objects.requireNonNull(month, \"month\");\n        DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        return create(year, month.getValue(), dayOfMonth);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDate} from a year, month and day.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDate of(int year, int month, int dayOfMonth) {\n        YEAR.checkValidValue(year);\n        MONTH_OF_YEAR.checkValidValue(month);\n        DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        return create(year, month, dayOfMonth);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a year and day-of-year.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year and day-of-year.\n     * The day-of-year must be valid for the year, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param dayOfYear  the day-of-year to represent, from 1 to 366\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-year is invalid for the year\n     */\n    public static LocalDate ofYearDay(int year, int dayOfYear) {\n        YEAR.checkValidValue(year);\n        DAY_OF_YEAR.checkValidValue(dayOfYear);\n        boolean leap \u003d IsoChronology.INSTANCE.isLeapYear(year);\n        if (dayOfYear \u003d\u003d 366 \u0026\u0026 leap \u003d\u003d false) {\n            throw new DateTimeException(\"Invalid date \u0027DayOfYear 366\u0027 as \u0027\" + year + \"\u0027 is not a leap year\");\n        }\n        Month moy \u003d Month.of((dayOfYear - 1) / 31 + 1);\n        int monthEnd \u003d moy.firstDayOfYear(leap) + moy.length(leap) - 1;\n        if (dayOfYear \u003e monthEnd) {\n            moy \u003d moy.plus(1);\n        }\n        int dom \u003d dayOfYear - moy.firstDayOfYear(leap) + 1;\n        return new LocalDate(year, moy.getValue(), dom);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates a local date based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date.\n     *\n     * @param instant  the instant to create the date from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the local date, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     * @since 9\n     */\n    public static LocalDate ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        long localSecond \u003d instant.getEpochSecond() + offset.getTotalSeconds();\n        long localEpochDay \u003d Math.floorDiv(localSecond, SECONDS_PER_DAY);\n        return ofEpochDay(localEpochDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from the epoch day count.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified epoch-day.\n     * The {@link ChronoField#EPOCH_DAY EPOCH_DAY} is a simple incrementing count\n     * of days where day 0 is 1970-01-01. Negative numbers represent earlier days.\n     *\n     * @param epochDay  the Epoch Day to convert, based on the epoch 1970-01-01\n     * @return the local date, not null\n     * @throws DateTimeException if the epoch day exceeds the supported date range\n     */\n    public static LocalDate ofEpochDay(long epochDay) {\n        EPOCH_DAY.checkValidValue(epochDay);\n        long zeroDay \u003d epochDay + DAYS_0000_TO_1970;\n        // find the march-based year\n        zeroDay -\u003d 60;  // adjust to 0000-03-01 so leap day is at end of four year cycle\n        long adjust \u003d 0;\n        if (zeroDay \u003c 0) {\n            // adjust negative years to positive for calculation\n            long adjustCycles \u003d (zeroDay + 1) / DAYS_PER_CYCLE - 1;\n            adjust \u003d adjustCycles * 400;\n            zeroDay +\u003d -adjustCycles * DAYS_PER_CYCLE;\n        }\n        long yearEst \u003d (400 * zeroDay + 591) / DAYS_PER_CYCLE;\n        long doyEst \u003d zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);\n        if (doyEst \u003c 0) {\n            // fix estimate\n            yearEst--;\n            doyEst \u003d zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);\n        }\n        yearEst +\u003d adjust;  // reset any negative year\n        int marchDoy0 \u003d (int) doyEst;\n\n        // convert march-based values back to january-based\n        int marchMonth0 \u003d (marchDoy0 * 5 + 2) / 153;\n        int month \u003d (marchMonth0 + 2) % 12 + 1;\n        int dom \u003d marchDoy0 - (marchMonth0 * 306 + 5) / 10 + 1;\n        yearEst +\u003d marchMonth0 / 10;\n\n        // check year now we are certain it is correct\n        int year \u003d YEAR.checkValidIntValue(yearEst);\n        return new LocalDate(year, month, dom);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a temporal object.\n     * \u003cp\u003e\n     * This obtains a local date based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code LocalDate}.\n     * \u003cp\u003e\n     * The conversion uses the {@link TemporalQueries#localDate()} query, which relies\n     * on extracting the {@link ChronoField#EPOCH_DAY EPOCH_DAY} field.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code LocalDate::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the local date, not null\n     * @throws DateTimeException if unable to convert to a {@code LocalDate}\n     */\n    public static LocalDate from(TemporalAccessor temporal) {\n        Objects.requireNonNull(temporal, \"temporal\");\n        LocalDate date \u003d temporal.query(TemporalQueries.localDate());\n        if (date \u003d\u003d null) {\n            throw new DateTimeException(\"Unable to obtain LocalDate from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName());\n        }\n        return date;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a text string such as {@code 2007-12-03}.\n     * \u003cp\u003e\n     * The string must represent a valid date and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_DATE}.\n     *\n     * @param text  the text to parse such as \"2007-12-03\", not null\n     * @return the parsed local date, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDate parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_LOCAL_DATE);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDate} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed local date, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDate parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, LocalDate::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a local date from the year, month and day fields.\n     *\n     * @param year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 to 12, validated\n     * @param dayOfMonth  the day-of-month to represent, validated from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the day-of-month is invalid for the month-year\n     */\n    private static LocalDate create(int year, int month, int dayOfMonth) {\n        if (dayOfMonth \u003e 28) {\n            int dom \u003d 31;\n            switch (month) {\n                case 2:\n                    dom \u003d (IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n                    break;\n                case 4:\n                case 6:\n                case 9:\n                case 11:\n                    dom \u003d 30;\n                    break;\n            }\n            if (dayOfMonth \u003e dom) {\n                if (dayOfMonth \u003d\u003d 29) {\n                    throw new DateTimeException(\"Invalid date \u0027February 29\u0027 as \u0027\" + year + \"\u0027 is not a leap year\");\n                } else {\n                    throw new DateTimeException(\"Invalid date \u0027\" + Month.of(month).name() + \" \" + dayOfMonth + \"\u0027\");\n                }\n            }\n        }\n        return new LocalDate(year, month, dayOfMonth);\n    }\n\n    /**\n     * Resolves the date, resolving days past the end of month.\n     *\n     * @param year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, validated from 1 to 12\n     * @param day  the day-of-month to represent, validated from 1 to 31\n     * @return the resolved date, not null\n     */\n    private static LocalDate resolvePreviousValid(int year, int month, int day) {\n        switch (month) {\n            case 2:\n                day \u003d Math.min(day, IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n                break;\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                day \u003d Math.min(day, 30);\n                break;\n        }\n        return new LocalDate(year, month, day);\n    }\n\n    /**\n     * Constructor, previously validated.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, valid for year-month, from 1 to 31\n     */\n    private LocalDate(int year, int month, int dayOfMonth) {\n        this.year \u003d year;\n        this.month \u003d (short) month;\n        this.day \u003d (short) dayOfMonth;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalField field) {\n        return ChronoLocalDate.super.isSupported(field);\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        return ChronoLocalDate.super.isSupported(unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            if (f.isDateBased()) {\n                switch (f) {\n                    case DAY_OF_MONTH: return ValueRange.of(1, lengthOfMonth());\n                    case DAY_OF_YEAR: return ValueRange.of(1, lengthOfYear());\n                    case ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, getMonth() \u003d\u003d Month.FEBRUARY \u0026\u0026 isLeapYear() \u003d\u003d false ? 4 : 5);\n                    case YEAR_OF_ERA:\n                        return (getYear() \u003c\u003d 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n                }\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date, except {@code EPOCH_DAY} and {@code PROLEPTIC_MONTH}\n     * which are too large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc and performance\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            return get0(field);\n        }\n        return ChronoLocalDate.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            if (field \u003d\u003d EPOCH_DAY) {\n                return toEpochDay();\n            }\n            if (field \u003d\u003d PROLEPTIC_MONTH) {\n                return getProlepticMonth();\n            }\n            return get0(field);\n        }\n        return field.getFrom(this);\n    }\n\n    private int get0(TemporalField field) {\n        switch ((ChronoField) field) {\n            case DAY_OF_WEEK: return getDayOfWeek().getValue();\n            case ALIGNED_DAY_OF_WEEK_IN_MONTH: return ((day - 1) % 7) + 1;\n            case ALIGNED_DAY_OF_WEEK_IN_YEAR: return ((getDayOfYear() - 1) % 7) + 1;\n            case DAY_OF_MONTH: return day;\n            case DAY_OF_YEAR: return getDayOfYear();\n            case EPOCH_DAY: throw new UnsupportedTemporalTypeException(\"Invalid field \u0027EpochDay\u0027 for get() method, use getLong() instead\");\n            case ALIGNED_WEEK_OF_MONTH: return ((day - 1) / 7) + 1;\n            case ALIGNED_WEEK_OF_YEAR: return ((getDayOfYear() - 1) / 7) + 1;\n            case MONTH_OF_YEAR: return month;\n            case PROLEPTIC_MONTH: throw new UnsupportedTemporalTypeException(\"Invalid field \u0027ProlepticMonth\u0027 for get() method, use getLong() instead\");\n            case YEAR_OF_ERA: return (year \u003e\u003d 1 ? year : 1 - year);\n            case YEAR: return year;\n            case ERA: return (year \u003e\u003d 1 ? 1 : 0);\n        }\n        throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n    }\n\n    private long getProlepticMonth() {\n        return (year * 12L + month - 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology of this date, which is the ISO calendar system.\n     * \u003cp\u003e\n     * The {@code Chronology} represents the calendar system in use.\n     * The ISO-8601 calendar system is the modern civil calendar system used today\n     * in most of the world. It is equivalent to the proleptic Gregorian calendar\n     * system, in which today\u0027s rules for leap years are applied for all time.\n     *\n     * @return the ISO chronology, not null\n     */\n    @Override\n    public IsoChronology getChronology() {\n        return IsoChronology.INSTANCE;\n    }\n\n    /**\n     * Gets the era applicable at this date.\n     * \u003cp\u003e\n     * The official ISO-8601 standard does not define eras, however {@code IsoChronology} does.\n     * It defines two eras, \u0027CE\u0027 from year one onwards and \u0027BCE\u0027 from year zero backwards.\n     * Since dates before the Julian-Gregorian cutover are not in line with history,\n     * the cutover between \u0027BCE\u0027 and \u0027CE\u0027 is also not aligned with the commonly used\n     * eras, often referred to using \u0027BC\u0027 and \u0027AD\u0027.\n     * \u003cp\u003e\n     * Users of this class should typically ignore this method as it exists primarily\n     * to fulfill the {@link ChronoLocalDate} contract where it is necessary to support\n     * the Japanese calendar system.\n     *\n     * @return the IsoEra applicable at this date, not null\n     */\n    @Override // override for Javadoc\n    public IsoEra getEra() {\n        return (getYear() \u003e\u003d 1 ? IsoEra.CE : IsoEra.BCE);\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return year;\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return month;\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return Month.of(month);\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return day;\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return getMonth().firstDayOfYear(isLeapYear()) + day - 1;\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        int dow0 \u003d Math.floorMod(toEpochDay() + 3, 7);\n        return DayOfWeek.of(dow0 + 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     * \u003cp\u003e\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     * \u003cp\u003e\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     * \u003cp\u003e\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return true if the year is leap, false otherwise\n     */\n    @Override // override for Javadoc and performance\n    public boolean isLeapYear() {\n        return IsoChronology.INSTANCE.isLeapYear(year);\n    }\n\n    /**\n     * Returns the length of the month represented by this date.\n     * \u003cp\u003e\n     * This returns the length of the month in days.\n     * For example, a date in January would return 31.\n     *\n     * @return the length of the month in days\n     */\n    @Override\n    public int lengthOfMonth() {\n        switch (month) {\n            case 2:\n                return (isLeapYear() ? 29 : 28);\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Returns the length of the year represented by this date.\n     * \u003cp\u003e\n     * This returns the length of the year in days, either 365 or 366.\n     *\n     * @return 366 if the year is leap, 365 otherwise\n     */\n    @Override // override for Javadoc and performance\n    public int lengthOfYear() {\n        return (isLeapYear() ? 366 : 365);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the date adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * \u003cp\u003e\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d localDate.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return a {@code LocalDate} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return (LocalDate) adjuster;\n        }\n        return (LocalDate) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAY_OF_WEEK} -\n     *  Returns a {@code LocalDate} with the specified day-of-week.\n     *  The date is adjusted up to 6 days forward or backward within the boundary\n     *  of a Monday to Sunday week.\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH} -\n     *  Returns a {@code LocalDate} with the specified aligned-day-of-week.\n     *  The date is adjusted to the specified month-based aligned-day-of-week.\n     *  Aligned weeks are counted such that the first week of a given month starts\n     *  on the first day of that month.\n     *  This may cause the date to be moved up to 6 days into the following month.\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR} -\n     *  Returns a {@code LocalDate} with the specified aligned-day-of-week.\n     *  The date is adjusted to the specified year-based aligned-day-of-week.\n     *  Aligned weeks are counted such that the first week of a given year starts\n     *  on the first day of that year.\n     *  This may cause the date to be moved up to 6 days into the following year.\n     * \u003cli\u003e{@code DAY_OF_MONTH} -\n     *  Returns a {@code LocalDate} with the specified day-of-month.\n     *  The month and year will be unchanged. If the day-of-month is invalid for the\n     *  year and month, then a {@code DateTimeException} is thrown.\n     * \u003cli\u003e{@code DAY_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified day-of-year.\n     *  The year will be unchanged. If the day-of-year is invalid for the\n     *  year, then a {@code DateTimeException} is thrown.\n     * \u003cli\u003e{@code EPOCH_DAY} -\n     *  Returns a {@code LocalDate} with the specified epoch-day.\n     *  This completely replaces the date and is equivalent to {@link #ofEpochDay(long)}.\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH} -\n     *  Returns a {@code LocalDate} with the specified aligned-week-of-month.\n     *  Aligned weeks are counted such that the first week of a given month starts\n     *  on the first day of that month.\n     *  This adjustment moves the date in whole week chunks to match the specified week.\n     *  The result will have the same day-of-week as this date.\n     *  This may cause the date to be moved into the following month.\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified aligned-week-of-year.\n     *  Aligned weeks are counted such that the first week of a given year starts\n     *  on the first day of that year.\n     *  This adjustment moves the date in whole week chunks to match the specified week.\n     *  The result will have the same day-of-week as this date.\n     *  This may cause the date to be moved into the following year.\n     * \u003cli\u003e{@code MONTH_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified month-of-year.\n     *  The year will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code PROLEPTIC_MONTH} -\n     *  Returns a {@code LocalDate} with the specified proleptic-month.\n     *  The day-of-month will be unchanged, unless it would be invalid for the new month\n     *  and year. In that case, the day-of-month is adjusted to the maximum valid value\n     *  for the new month and year.\n     * \u003cli\u003e{@code YEAR_OF_ERA} -\n     *  Returns a {@code LocalDate} with the specified year-of-era.\n     *  The era and month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code YEAR} -\n     *  Returns a {@code LocalDate} with the specified year.\n     *  The month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code ERA} -\n     *  Returns a {@code LocalDate} with the specified era.\n     *  The year-of-era and month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return a {@code LocalDate} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            f.checkValidValue(newValue);\n            switch (f) {\n                case DAY_OF_WEEK: return plusDays(newValue - getDayOfWeek().getValue());\n                case ALIGNED_DAY_OF_WEEK_IN_MONTH: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n                case ALIGNED_DAY_OF_WEEK_IN_YEAR: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                case DAY_OF_MONTH: return withDayOfMonth((int) newValue);\n                case DAY_OF_YEAR: return withDayOfYear((int) newValue);\n                case EPOCH_DAY: return LocalDate.ofEpochDay(newValue);\n                case ALIGNED_WEEK_OF_MONTH: return plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_MONTH));\n                case ALIGNED_WEEK_OF_YEAR: return plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_YEAR));\n                case MONTH_OF_YEAR: return withMonth((int) newValue);\n                case PROLEPTIC_MONTH: return plusMonths(newValue - getProlepticMonth());\n                case YEAR_OF_ERA: return withYear((int) (year \u003e\u003d 1 ? newValue : 1 - newValue));\n                case YEAR: return withYear((int) newValue);\n                case ERA: return (getLong(ERA) \u003d\u003d newValue ? this : withYear(1 - year));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the year altered.\n     * \u003cp\u003e\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return a {@code LocalDate} based on this date with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public LocalDate withYear(int year) {\n        if (this.year \u003d\u003d year) {\n            return this;\n        }\n        YEAR.checkValidValue(year);\n        return resolvePreviousValid(year, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the month-of-year altered.\n     * \u003cp\u003e\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return a {@code LocalDate} based on this date with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public LocalDate withMonth(int month) {\n        if (this.month \u003d\u003d month) {\n            return this;\n        }\n        MONTH_OF_YEAR.checkValidValue(month);\n        return resolvePreviousValid(year, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting date is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return a {@code LocalDate} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public LocalDate withDayOfMonth(int dayOfMonth) {\n        if (this.day \u003d\u003d dayOfMonth) {\n            return this;\n        }\n        return of(year, month, dayOfMonth);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the day-of-year altered.\n     * \u003cp\u003e\n     * If the resulting date is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return a {@code LocalDate} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public LocalDate withDayOfYear(int dayOfYear) {\n        if (this.getDayOfYear() \u003d\u003d dayOfYear) {\n            return this;\n        }\n        return ofYearDay(year, dayOfYear);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return a {@code LocalDate} based on this date with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate plus(TemporalAmount amountToAdd) {\n        if (amountToAdd instanceof Period) {\n            Period periodToAdd \u003d (Period) amountToAdd;\n            return plusMonths(periodToAdd.toTotalMonths()).plusDays(periodToAdd.getDays());\n        }\n        Objects.requireNonNull(amountToAdd, \"amountToAdd\");\n        return (LocalDate) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, adding the amount can cause the resulting date to become invalid.\n     * For example, adding one month to 31st January would result in 31st February.\n     * In cases like this, the unit is responsible for resolving the date.\n     * Typically it will choose the previous valid date, which would be the last valid\n     * day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented here.\n     * The supported fields behave as follows:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAYS} -\n     *  Returns a {@code LocalDate} with the specified number of days added.\n     *  This is equivalent to {@link #plusDays(long)}.\n     * \u003cli\u003e{@code WEEKS} -\n     *  Returns a {@code LocalDate} with the specified number of weeks added.\n     *  This is equivalent to {@link #plusWeeks(long)} and uses a 7 day week.\n     * \u003cli\u003e{@code MONTHS} -\n     *  Returns a {@code LocalDate} with the specified number of months added.\n     *  This is equivalent to {@link #plusMonths(long)}.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code YEARS} -\n     *  Returns a {@code LocalDate} with the specified number of years added.\n     *  This is equivalent to {@link #plusYears(long)}.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code DECADES} -\n     *  Returns a {@code LocalDate} with the specified number of decades added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 10.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code CENTURIES} -\n     *  Returns a {@code LocalDate} with the specified number of centuries added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 100.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code MILLENNIA} -\n     *  Returns a {@code LocalDate} with the specified number of millennia added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 1,000.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code ERAS} -\n     *  Returns a {@code LocalDate} with the specified number of eras added.\n     *  Only two eras are supported so the amount must be one, zero or minus one.\n     *  If the amount is non-zero then the year is changed such that the year-of-era\n     *  is unchanged.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * All other {@code ChronoUnit} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return a {@code LocalDate} based on this date with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            ChronoUnit f \u003d (ChronoUnit) unit;\n            switch (f) {\n                case DAYS: return plusDays(amountToAdd);\n                case WEEKS: return plusWeeks(amountToAdd);\n                case MONTHS: return plusMonths(amountToAdd);\n                case YEARS: return plusYears(amountToAdd);\n                case DECADES: return plusYears(Math.multiplyExact(amountToAdd, 10));\n                case CENTURIES: return plusYears(Math.multiplyExact(amountToAdd, 100));\n                case MILLENNIA: return plusYears(Math.multiplyExact(amountToAdd, 1000));\n                case ERAS: return with(ERA, Math.addExact(getLong(ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param yearsToAdd  the years to add, may be negative\n     * @return a {@code LocalDate} based on this date with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusYears(long yearsToAdd) {\n        if (yearsToAdd \u003d\u003d 0) {\n            return this;\n        }\n        int newYear \u003d YEAR.checkValidIntValue(year + yearsToAdd);  // safe overflow\n        return resolvePreviousValid(newYear, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param monthsToAdd  the months to add, may be negative\n     * @return a {@code LocalDate} based on this date with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusMonths(long monthsToAdd) {\n        if (monthsToAdd \u003d\u003d 0) {\n            return this;\n        }\n        long monthCount \u003d year * 12L + (month - 1);\n        long calcMonths \u003d monthCount + monthsToAdd;  // safe overflow\n        int newYear \u003d YEAR.checkValidIntValue(Math.floorDiv(calcMonths, 12));\n        int newMonth \u003d Math.floorMod(calcMonths, 12) + 1;\n        return resolvePreviousValid(newYear, newMonth, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeksToAdd  the weeks to add, may be negative\n     * @return a {@code LocalDate} based on this date with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusWeeks(long weeksToAdd) {\n        return plusDays(Math.multiplyExact(weeksToAdd, 7));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param daysToAdd  the days to add, may be negative\n     * @return a {@code LocalDate} based on this date with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusDays(long daysToAdd) {\n        if (daysToAdd \u003d\u003d 0) {\n            return this;\n        }\n        long dom \u003d day + daysToAdd;\n        if (dom \u003e 0) {\n            if (dom \u003c\u003d 28) {\n                return new LocalDate(year, month, (int) dom);\n            } else if (dom \u003c\u003d 59) { // 59th Jan is 28th Feb, 59th Feb is 31st Mar\n                long monthLen \u003d lengthOfMonth();\n                if (dom \u003c\u003d monthLen) {\n                    return new LocalDate(year, month, (int) dom);\n                } else if (month \u003c 12) {\n                    return new LocalDate(year, month + 1, (int) (dom - monthLen));\n                } else {\n                    YEAR.checkValidValue(year + 1);\n                    return new LocalDate(year + 1, 1, (int) (dom - monthLen));\n                }\n            }\n        }\n\n        long mjDay \u003d Math.addExact(toEpochDay(), daysToAdd);\n        return LocalDate.ofEpochDay(mjDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return a {@code LocalDate} based on this date with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate minus(TemporalAmount amountToSubtract) {\n        if (amountToSubtract instanceof Period) {\n            Period periodToSubtract \u003d (Period) amountToSubtract;\n            return minusMonths(periodToSubtract.toTotalMonths()).minusDays(periodToSubtract.getDays());\n        }\n        Objects.requireNonNull(amountToSubtract, \"amountToSubtract\");\n        return (LocalDate) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return a {@code LocalDate} based on this date with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param yearsToSubtract  the years to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusYears(long yearsToSubtract) {\n        return (yearsToSubtract \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-yearsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param monthsToSubtract  the months to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusMonths(long monthsToSubtract) {\n        return (monthsToSubtract \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-monthsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeksToSubtract  the weeks to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusWeeks(long weeksToSubtract) {\n        return (weeksToSubtract \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeksToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param daysToSubtract  the days to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusDays(long daysToSubtract) {\n        return (daysToSubtract \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-daysToSubtract));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date using the specified query.\n     * \u003cp\u003e\n     * This queries this date using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) this;\n        }\n        return ChronoLocalDate.super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the date changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * passing {@link ChronoField#EPOCH_DAY} as the field.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisLocalDate.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisLocalDate);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc\n    public Temporal adjustInto(Temporal temporal) {\n        return ChronoLocalDate.super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the amount of time until another date in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code LocalDate}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code LocalDate} using {@link #from(TemporalAccessor)}.\n     * For example, the amount in days between two dates can be calculated\n     * using {@code startDate.until(endDate, DAYS)}.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two dates.\n     * For example, the amount in months between 2012-06-15 and 2012-08-14\n     * will only be one month as it is one day short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code DAYS}, {@code WEEKS}, {@code MONTHS}, {@code YEARS},\n     * {@code DECADES}, {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS}\n     * are supported. Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to a {@code LocalDate}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date and the end date\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to a {@code LocalDate}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        LocalDate end \u003d LocalDate.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch ((ChronoUnit) unit) {\n                case DAYS: return daysUntil(end);\n                case WEEKS: return daysUntil(end) / 7;\n                case MONTHS: return monthsUntil(end);\n                case YEARS: return monthsUntil(end) / 12;\n                case DECADES: return monthsUntil(end) / 120;\n                case CENTURIES: return monthsUntil(end) / 1200;\n                case MILLENNIA: return monthsUntil(end) / 12000;\n                case ERAS: return end.getLong(ERA) - getLong(ERA);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    long daysUntil(LocalDate end) {\n        return end.toEpochDay() - toEpochDay();  // no overflow\n    }\n\n    private long monthsUntil(LocalDate end) {\n        long packed1 \u003d getProlepticMonth() * 32L + getDayOfMonth();  // no overflow\n        long packed2 \u003d end.getProlepticMonth() * 32L + end.getDayOfMonth();  // no overflow\n        return (packed2 - packed1) / 32;\n    }\n\n    /**\n     * Calculates the period between this date and another date as a {@code Period}.\n     * \u003cp\u003e\n     * This calculates the period between two dates in terms of years, months and days.\n     * The start and end points are {@code this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The negative sign will be the same in each of year, month and day.\n     * \u003cp\u003e\n     * The calculation is performed using the ISO calendar system.\n     * If necessary, the input date will be converted to ISO.\n     * \u003cp\u003e\n     * The start date is included, but the end date is not.\n     * The period is calculated by removing complete months, then calculating\n     * the remaining number of days, adjusting to ensure that both have the same sign.\n     * The number of months is then normalized into years and months based on a 12 month year.\n     * A month is considered to be complete if the end day-of-month is greater\n     * than or equal to the start day-of-month.\n     * For example, from {@code 2010-01-15} to {@code 2011-03-18} is \"1 year, 2 months and 3 days\".\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link Period#between(LocalDate, LocalDate)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   period \u003d start.until(end);\n     *   period \u003d Period.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     *\n     * @param endDateExclusive  the end date, exclusive, which may be in any chronology, not null\n     * @return the period between this date and the end date, not null\n     */\n    @Override\n    public Period until(ChronoLocalDate endDateExclusive) {\n        LocalDate end \u003d LocalDate.from(endDateExclusive);\n        long totalMonths \u003d end.getProlepticMonth() - this.getProlepticMonth();  // safe\n        int days \u003d end.day - this.day;\n        if (totalMonths \u003e 0 \u0026\u0026 days \u003c 0) {\n            totalMonths--;\n            LocalDate calcDate \u003d this.plusMonths(totalMonths);\n            days \u003d (int) (end.toEpochDay() - calcDate.toEpochDay());  // safe\n        } else if (totalMonths \u003c 0 \u0026\u0026 days \u003e 0) {\n            totalMonths++;\n            days -\u003d end.lengthOfMonth();\n        }\n        long years \u003d totalMonths / 12;  // safe\n        int months \u003d (int) (totalMonths % 12);  // safe\n        return Period.of(Math.toIntExact(years), months, days);\n    }\n\n    /**\n     * Returns a sequential ordered stream of dates. The returned stream starts from this date\n     * (inclusive) and goes to {@code endExclusive} (exclusive) by an incremental step of 1 day.\n     * \u003cp\u003e\n     * This method is equivalent to {@code datesUntil(endExclusive, Period.ofDays(1))}.\n     *\n     * @param endExclusive  the end date, exclusive, not null\n     * @return a sequential {@code Stream} for the range of {@code LocalDate} values\n     * @throws IllegalArgumentException if end date is before this date\n     * @since 9\n     */\n    public Stream\u003cLocalDate\u003e datesUntil(LocalDate endExclusive) {\n        long end \u003d endExclusive.toEpochDay();\n        long start \u003d toEpochDay();\n        if (end \u003c start) {\n            throw new IllegalArgumentException(endExclusive + \" \u003c \" + this);\n        }\n        return LongStream.range(start, end).mapToObj(LocalDate::ofEpochDay);\n    }\n\n    /**\n     * Returns a sequential ordered stream of dates by given incremental step. The returned stream\n     * starts from this date (inclusive) and goes to {@code endExclusive} (exclusive).\n     * \u003cp\u003e\n     * The n-th date which appears in the stream is equal to {@code this.plus(step.multipliedBy(n))}\n     * (but the result of step multiplication never overflows). For example, if this date is\n     * {@code 2015-01-31}, the end date is {@code 2015-05-01} and the step is 1 month, then the\n     * stream contains {@code 2015-01-31}, {@code 2015-02-28}, {@code 2015-03-31}, and\n     * {@code 2015-04-30}.\n     *\n     * @param endExclusive  the end date, exclusive, not null\n     * @param step  the non-zero, non-negative {@code Period} which represents the step.\n     * @return a sequential {@code Stream} for the range of {@code LocalDate} values\n     * @throws IllegalArgumentException if step is zero, or {@code step.getDays()} and\n     *             {@code step.toTotalMonths()} have opposite sign, or end date is before this date\n     *             and step is positive, or end date is after this date and step is negative\n     * @since 9\n     */\n    public Stream\u003cLocalDate\u003e datesUntil(LocalDate endExclusive, Period step) {\n        if (step.isZero()) {\n            throw new IllegalArgumentException(\"step is zero\");\n        }\n        long end \u003d endExclusive.toEpochDay();\n        long start \u003d toEpochDay();\n        long until \u003d end - start;\n        long months \u003d step.toTotalMonths();\n        long days \u003d step.getDays();\n        if ((months \u003c 0 \u0026\u0026 days \u003e 0) || (months \u003e 0 \u0026\u0026 days \u003c 0)) {\n            throw new IllegalArgumentException(\"period months and days are of opposite sign\");\n        }\n        if (until \u003d\u003d 0) {\n            return Stream.empty();\n        }\n        int sign \u003d months \u003e 0 || days \u003e 0 ? 1 : -1;\n        if (sign \u003c 0 ^ until \u003c 0) {\n            throw new IllegalArgumentException(endExclusive + (sign \u003c 0 ? \" \u003e \" : \" \u003c \") + this);\n        }\n        if (months \u003d\u003d 0) {\n            long steps \u003d (until - sign) / days; // non-negative\n            return LongStream.rangeClosed(0, steps).mapToObj(\n                    n -\u003e LocalDate.ofEpochDay(start + n * days));\n        }\n        // 48699/1600 \u003d 365.2425/12, no overflow, non-negative result\n        long steps \u003d until * 1600 / (months * 48699 + days * 1600) + 1;\n        long addMonths \u003d months * steps;\n        long addDays \u003d days * steps;\n        long maxAddMonths \u003d months \u003e 0 ? MAX.getProlepticMonth() - getProlepticMonth()\n                : getProlepticMonth() - MIN.getProlepticMonth();\n        // adjust steps estimation\n        if (addMonths * sign \u003e maxAddMonths\n                || (plusMonths(addMonths).toEpochDay() + addDays) * sign \u003e\u003d end * sign) {\n            steps--;\n            addMonths -\u003d months;\n            addDays -\u003d days;\n            if (addMonths * sign \u003e maxAddMonths\n                    || (plusMonths(addMonths).toEpochDay() + addDays) * sign \u003e\u003d end * sign) {\n                steps--;\n            }\n        }\n        return LongStream.rangeClosed(0, steps).mapToObj(\n                n -\u003e this.plusMonths(months * n).plusDays(days * n));\n    }\n\n    /**\n     * Formats this date using the specified formatter.\n     * \u003cp\u003e\n     * This date will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    @Override  // override for Javadoc and performance\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param time  the time to combine with, not null\n     * @return the local date-time formed from this date and the specified time, not null\n     */\n    @Override\n    public LocalDateTime atTime(LocalTime time) {\n        return LocalDateTime.of(this, time);\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour and minute.\n     * The seconds and nanosecond fields will be set to zero.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute) {\n        return atTime(LocalTime.of(hour, minute));\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour, minute and second.\n     * The nanosecond field will be set to zero.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute, int second) {\n        return atTime(LocalTime.of(hour, minute, second));\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour, minute, second and nanosecond.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute, int second, int nanoOfSecond) {\n        return atTime(LocalTime.of(hour, minute, second, nanoOfSecond));\n    }\n\n    /**\n     * Combines this date with an offset time to create an {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param time  the time to combine with, not null\n     * @return the offset date-time formed from this date and the specified time, not null\n     */\n    public OffsetDateTime atTime(OffsetTime time) {\n        return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.getOffset());\n    }\n\n    /**\n     * Combines this date with the time of midnight to create a {@code LocalDateTime}\n     * at the start of this date.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the time of\n     * midnight, 00:00, at the start of this date.\n     *\n     * @return the local date-time of midnight at the start of this date, not null\n     */\n    public LocalDateTime atStartOfDay() {\n        return LocalDateTime.of(this, LocalTime.MIDNIGHT);\n    }\n\n    /**\n     * Returns a zoned date-time from this date at the earliest valid time according\n     * to the rules in the time-zone.\n     * \u003cp\u003e\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may not be midnight.\n     * \u003cp\u003e\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, there are two valid offsets, and the earlier one is used,\n     * corresponding to the first occurrence of midnight on the date.\n     * In the case of a gap, the zoned date-time will represent the instant just after the gap.\n     * \u003cp\u003e\n     * If the zone ID is a {@link ZoneOffset}, then the result always has a time of midnight.\n     * \u003cp\u003e\n     * To convert to a specific time in a given time-zone call {@link #atTime(LocalTime)}\n     * followed by {@link LocalDateTime#atZone(ZoneId)}.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atStartOfDay(ZoneId zone) {\n        Objects.requireNonNull(zone, \"zone\");\n        // need to handle case where there is a gap from 11:30 to 00:30\n        // standard ZDT factory would result in 01:00 rather than 00:30\n        LocalDateTime ldt \u003d atTime(LocalTime.MIDNIGHT);\n        if (zone instanceof ZoneOffset \u003d\u003d false) {\n            ZoneRules rules \u003d zone.getRules();\n            ZoneOffsetTransition trans \u003d rules.getTransition(ldt);\n            if (trans !\u003d null \u0026\u0026 trans.isGap()) {\n                ldt \u003d trans.getDateTimeAfter();\n            }\n        }\n        return ZonedDateTime.of(ldt, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public long toEpochDay() {\n        long y \u003d year;\n        long m \u003d month;\n        long total \u003d 0;\n        total +\u003d 365 * y;\n        if (y \u003e\u003d 0) {\n            total +\u003d (y + 3) / 4 - (y + 99) / 100 + (y + 399) / 400;\n        } else {\n            total -\u003d y / -4 - y / -100 + y / -400;\n        }\n        total +\u003d ((367 * m - 362) / 12);\n        total +\u003d day - 1;\n        if (m \u003e 2) {\n            total--;\n            if (isLeapYear() \u003d\u003d false) {\n                total--;\n            }\n        }\n        return total - DAYS_0000_TO_1970;\n    }\n\n    /**\n     * Converts this {@code LocalDate} to the number of seconds since the epoch\n     * of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This combines this local date with the specified time and\n     * offset to calculate the epoch-second value, which is the\n     * number of elapsed seconds from 1970-01-01T00:00:00Z.\n     * Instants on the time-line after the epoch are positive, earlier\n     * are negative.\n     *\n     * @param time the local time, not null\n     * @param offset the zone offset, not null\n     * @return the number of seconds since the epoch of 1970-01-01T00:00:00Z, may be negative\n     * @since 9\n     */\n    public long toEpochSecond(LocalTime time, ZoneOffset offset) {\n        Objects.requireNonNull(time, \"time\");\n        Objects.requireNonNull(offset, \"offset\");\n        long secs \u003d toEpochDay() * SECONDS_PER_DAY + time.toSecondOfDay();\n        secs -\u003d offset.getTotalSeconds();\n        return secs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date to another date.\n     * \u003cp\u003e\n     * The comparison is primarily based on the date, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * If all the dates being compared are instances of {@code LocalDate},\n     * then the comparison will be entirely based on the date.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link java.time.chrono.ChronoLocalDate#compareTo}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override  // override for Javadoc and performance\n    public int compareTo(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other);\n        }\n        return ChronoLocalDate.super.compareTo(other);\n    }\n\n    int compareTo0(LocalDate otherDate) {\n        int cmp \u003d (year - otherDate.year);\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d (month - otherDate.month);\n            if (cmp \u003d\u003d 0) {\n                cmp \u003d (day - otherDate.day);\n            }\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date is after the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents a point on the\n     * local time-line after the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isAfter(b) \u003d\u003d false\n     *   a.isAfter(a) \u003d\u003d false\n     *   b.isAfter(a) \u003d\u003d true\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is after the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isAfter(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003e 0;\n        }\n        return ChronoLocalDate.super.isAfter(other);\n    }\n\n    /**\n     * Checks if this date is before the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents a point on the\n     * local time-line before the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isBefore(b) \u003d\u003d true\n     *   a.isBefore(a) \u003d\u003d false\n     *   b.isBefore(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is before the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isBefore(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003c 0;\n        }\n        return ChronoLocalDate.super.isBefore(other);\n    }\n\n    /**\n     * Checks if this date is equal to the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents the same point on the\n     * local time-line as the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isEqual(b) \u003d\u003d false\n     *   a.isEqual(a) \u003d\u003d true\n     *   b.isEqual(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)}\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is equal to the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isEqual(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003d\u003d 0;\n        }\n        return ChronoLocalDate.super.isEqual(other);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date is equal to another date.\n     * \u003cp\u003e\n     * Compares this {@code LocalDate} with another ensuring that the date is the same.\n     * \u003cp\u003e\n     * Only objects of type {@code LocalDate} are compared, other types return false.\n     * To compare the dates of two {@code TemporalAccessor} instances, including dates\n     * in two different chronologies, use {@link ChronoField#EPOCH_DAY} as a comparator.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof LocalDate) {\n            return compareTo0((LocalDate) obj) \u003d\u003d 0;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        int yearValue \u003d year;\n        int monthValue \u003d month;\n        int dayValue \u003d day;\n        return (yearValue \u0026 0xFFFFF800) ^ ((yearValue \u003c\u003c 11) + (monthValue \u003c\u003c 6) + (dayValue));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date as a {@code String}, such as {@code 2007-12-03}.\n     * \u003cp\u003e\n     * The output will be in the ISO-8601 format {@code uuuu-MM-dd}.\n     *\n     * @return a string representation of this date, not null\n     */\n    @Override\n    public String toString() {\n        int yearValue \u003d year;\n        int monthValue \u003d month;\n        int dayValue \u003d day;\n        int absYear \u003d Math.abs(yearValue);\n        StringBuilder buf \u003d new StringBuilder(10);\n        if (absYear \u003c 1000) {\n            if (yearValue \u003c 0) {\n                buf.append(yearValue - 10000).deleteCharAt(1);\n            } else {\n                buf.append(yearValue + 10000).deleteCharAt(0);\n            }\n        } else {\n            if (yearValue \u003e 9999) {\n                buf.append(\u0027+\u0027);\n            }\n            buf.append(yearValue);\n        }\n        return buf.append(monthValue \u003c 10 ? \"-0\" : \"-\")\n            .append(monthValue)\n            .append(dayValue \u003c 10 ? \"-0\" : \"-\")\n            .append(dayValue)\n            .toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(3);  // identifies a LocalDate\n     *  out.writeInt(year);\n     *  out.writeByte(month);\n     *  out.writeByte(day);\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.LOCAL_DATE_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(DataOutput out) throws IOException {\n        out.writeInt(year);\n        out.writeByte(month);\n        out.writeByte(day);\n    }\n\n    static LocalDate readExternal(DataInput in) throws IOException {\n        int year \u003d in.readInt();\n        int month \u003d in.readByte();\n        int dayOfMonth \u003d in.readByte();\n        return LocalDate.of(year, month, dayOfMonth);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 18, 2024 2:03:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.18 14:03:47 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 2:03:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2008-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time.format;\n\nimport static java.time.temporal.ChronoField.DAY_OF_MONTH;\nimport static java.time.temporal.ChronoField.DAY_OF_WEEK;\nimport static java.time.temporal.ChronoField.DAY_OF_YEAR;\nimport static java.time.temporal.ChronoField.HOUR_OF_DAY;\nimport static java.time.temporal.ChronoField.MINUTE_OF_HOUR;\nimport static java.time.temporal.ChronoField.MONTH_OF_YEAR;\nimport static java.time.temporal.ChronoField.NANO_OF_SECOND;\nimport static java.time.temporal.ChronoField.SECOND_OF_MINUTE;\nimport static java.time.temporal.ChronoField.YEAR;\n\nimport java.io.IOException;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.time.DateTimeException;\nimport java.time.Period;\nimport java.time.ZoneId;\nimport java.time.ZoneOffset;\nimport java.time.chrono.ChronoLocalDateTime;\nimport java.time.chrono.Chronology;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatterBuilder.CompositePrinterParser;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.IsoFields;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQuery;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport sun.util.locale.provider.TimeZoneNameUtility;\n\n/**\n * Formatter for printing and parsing date-time objects.\n * \u003cp\u003e\n * This class provides the main application entry point for printing and parsing\n * and provides common implementations of {@code DateTimeFormatter}:\n * \u003cul\u003e\n * \u003cli\u003eUsing predefined constants, such as {@link #ISO_LOCAL_DATE}\u003c/li\u003e\n * \u003cli\u003eUsing pattern letters, such as {@code uuuu-MMM-dd}\u003c/li\u003e\n * \u003cli\u003eUsing localized styles, such as {@code long} or {@code medium}\u003c/li\u003e\n * \u003c/ul\u003e\n * \u003cp\u003e\n * More complex formatters are provided by\n * {@link DateTimeFormatterBuilder DateTimeFormatterBuilder}.\n *\n * \u003cp\u003e\n * The main date-time classes provide two methods - one for formatting,\n * {@code format(DateTimeFormatter formatter)}, and one for parsing,\n * {@code parse(CharSequence text, DateTimeFormatter formatter)}.\n * \u003cp\u003eFor example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *  LocalDate date \u003d LocalDate.now();\n *  String text \u003d date.format(formatter);\n *  LocalDate parsedDate \u003d LocalDate.parse(text, formatter);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * In addition to the format, formatters can be created with desired Locale,\n * Chronology, ZoneId, and DecimalStyle.\n * \u003cp\u003e\n * The {@link #withLocale withLocale} method returns a new formatter that\n * overrides the locale. The locale affects some aspects of formatting and\n * parsing. For example, the {@link #ofLocalizedDate ofLocalizedDate} provides a\n * formatter that uses the locale specific date format.\n * \u003cp\u003e\n * The {@link #withChronology withChronology} method returns a new formatter\n * that overrides the chronology. If overridden, the date-time value is\n * converted to the chronology before formatting. During parsing the date-time\n * value is converted to the chronology before it is returned.\n * \u003cp\u003e\n * The {@link #withZone withZone} method returns a new formatter that overrides\n * the zone. If overridden, the date-time value is converted to a ZonedDateTime\n * with the requested ZoneId before formatting. During parsing the ZoneId is\n * applied before the value is returned.\n * \u003cp\u003e\n * The {@link #withDecimalStyle withDecimalStyle} method returns a new formatter that\n * overrides the {@link DecimalStyle}. The DecimalStyle symbols are used for\n * formatting and parsing.\n * \u003cp\u003e\n * Some applications may need to use the older {@link Format java.text.Format}\n * class for formatting. The {@link #toFormat()} method returns an\n * implementation of {@code java.text.Format}.\n *\n * \u003ch3 id\u003d\"predefined\"\u003ePredefined Formatters\u003c/h3\u003e\n * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n * \u003ccaption\u003ePredefined Formatters\u003c/caption\u003e\n * \u003cthead\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"col\"\u003eFormatter\u003c/th\u003e\n * \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n * \u003cth scope\u003d\"col\"\u003eExample\u003c/th\u003e\n * \u003c/tr\u003e\n * \u003c/thead\u003e\n * \u003ctbody\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e{@link #ofLocalizedDate ofLocalizedDate(dateStyle)} \u003c/th\u003e\n * \u003ctd\u003e Formatter with date style from the locale \u003c/td\u003e\n * \u003ctd\u003e \u00272011-12-03\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ofLocalizedTime ofLocalizedTime(timeStyle)} \u003c/th\u003e\n * \u003ctd\u003e Formatter with time style from the locale \u003c/td\u003e\n * \u003ctd\u003e \u002710:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ofLocalizedDateTime ofLocalizedDateTime(dateTimeStyle)} \u003c/th\u003e\n * \u003ctd\u003e Formatter with a style for date and time from the locale\u003c/td\u003e\n * \u003ctd\u003e \u00273 Jun 2008 11:05:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ofLocalizedDateTime ofLocalizedDateTime(dateStyle,timeStyle)}\n * \u003c/th\u003e\n * \u003ctd\u003e Formatter with date and time styles from the locale \u003c/td\u003e\n * \u003ctd\u003e \u00273 Jun 2008 11:05\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #BASIC_ISO_DATE}\u003c/th\u003e\n * \u003ctd\u003eBasic ISO date \u003c/td\u003e \u003ctd\u003e\u002720111203\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_LOCAL_DATE}\u003c/th\u003e\n * \u003ctd\u003e ISO Local Date \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_OFFSET_DATE}\u003c/th\u003e\n * \u003ctd\u003e ISO Date with offset \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03+01:00\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_DATE}\u003c/th\u003e\n * \u003ctd\u003e ISO Date with or without offset \u003c/td\u003e\n * \u003ctd\u003e \u00272011-12-03+01:00\u0027; \u00272011-12-03\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_LOCAL_TIME}\u003c/th\u003e\n * \u003ctd\u003e Time without offset \u003c/td\u003e\n * \u003ctd\u003e\u002710:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_OFFSET_TIME}\u003c/th\u003e\n * \u003ctd\u003e Time with offset \u003c/td\u003e\n * \u003ctd\u003e\u002710:15:30+01:00\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_TIME}\u003c/th\u003e\n * \u003ctd\u003e Time with or without offset \u003c/td\u003e\n * \u003ctd\u003e\u002710:15:30+01:00\u0027; \u002710:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_LOCAL_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e ISO Local Date and Time \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_OFFSET_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e Date Time with Offset\n * \u003c/td\u003e\u003ctd\u003e\u00272011-12-03T10:15:30+01:00\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_ZONED_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e Zoned Date Time \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e Date and time with ZoneId \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_ORDINAL_DATE}\u003c/th\u003e\n * \u003ctd\u003e Year and day of year \u003c/td\u003e\n * \u003ctd\u003e\u00272012-337\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_WEEK_DATE}\u003c/th\u003e\n * \u003ctd\u003e Year and Week \u003c/td\u003e\n * \u003ctd\u003e\u00272012-W48-6\u0027\u003c/td\u003e\u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_INSTANT}\u003c/th\u003e\n * \u003ctd\u003e Date and Time of an Instant \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30Z\u0027 \u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #RFC_1123_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e RFC 1123 / RFC 822 \u003c/td\u003e\n * \u003ctd\u003e\u0027Tue, 3 Jun 2008 11:05:30 GMT\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003c/tbody\u003e\n * \u003c/table\u003e\n *\n * \u003ch3 id\u003d\"patterns\"\u003ePatterns for Formatting and Parsing\u003c/h3\u003e\n * Patterns are based on a simple sequence of letters and symbols.\n * A pattern is used to create a Formatter using the\n * {@link #ofPattern(String)} and {@link #ofPattern(String, Locale)} methods.\n * For example,\n * {@code \"d MMM uuuu\"} will format 2011-12-03 as \u00273\u0026nbsp;Dec\u0026nbsp;2011\u0027.\n * A formatter created from a pattern can be used as many times as necessary,\n * it is immutable and is thread-safe.\n * \u003cp\u003e\n * For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *  LocalDate date \u003d LocalDate.now();\n *  DateTimeFormatter formatter \u003d DateTimeFormatter.ofPattern(\"yyyy MM dd\");\n *  String text \u003d date.format(formatter);\n *  LocalDate parsedDate \u003d LocalDate.parse(text, formatter);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * All letters \u0027A\u0027 to \u0027Z\u0027 and \u0027a\u0027 to \u0027z\u0027 are reserved as pattern letters. The\n * following pattern letters are defined:\n * \u003ctable class\u003d\"striped\"\u003e\n * \u003ccaption\u003ePattern Letters and Symbols\u003c/caption\u003e\n * \u003cthead\u003e\n *  \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSymbol\u003c/th\u003e   \u003cth scope\u003d\"col\"\u003eMeaning\u003c/th\u003e         \u003cth scope\u003d\"col\"\u003ePresentation\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eExamples\u003c/th\u003e\n * \u003c/thead\u003e\n * \u003ctbody\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eG\u003c/th\u003e       \u003ctd\u003eera\u003c/td\u003e                         \u003ctd\u003etext\u003c/td\u003e              \u003ctd\u003eAD; Anno Domini; A\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eu\u003c/th\u003e       \u003ctd\u003eyear\u003c/td\u003e                        \u003ctd\u003eyear\u003c/td\u003e              \u003ctd\u003e2004; 04\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ey\u003c/th\u003e       \u003ctd\u003eyear-of-era\u003c/td\u003e                 \u003ctd\u003eyear\u003c/td\u003e              \u003ctd\u003e2004; 04\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eD\u003c/th\u003e       \u003ctd\u003eday-of-year\u003c/td\u003e                 \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e189\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eM/L\u003c/th\u003e     \u003ctd\u003emonth-of-year\u003c/td\u003e               \u003ctd\u003enumber/text\u003c/td\u003e       \u003ctd\u003e7; 07; Jul; July; J\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ed\u003c/th\u003e       \u003ctd\u003eday-of-month\u003c/td\u003e                \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e10\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eg\u003c/th\u003e       \u003ctd\u003emodified-julian-day\u003c/td\u003e         \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e2451334\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eQ/q\u003c/th\u003e     \u003ctd\u003equarter-of-year\u003c/td\u003e             \u003ctd\u003enumber/text\u003c/td\u003e       \u003ctd\u003e3; 03; Q3; 3rd quarter\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eY\u003c/th\u003e       \u003ctd\u003eweek-based-year\u003c/td\u003e             \u003ctd\u003eyear\u003c/td\u003e              \u003ctd\u003e1996; 96\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ew\u003c/th\u003e       \u003ctd\u003eweek-of-week-based-year\u003c/td\u003e     \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e27\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eW\u003c/th\u003e       \u003ctd\u003eweek-of-month\u003c/td\u003e               \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e4\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eE\u003c/th\u003e       \u003ctd\u003eday-of-week\u003c/td\u003e                 \u003ctd\u003etext\u003c/td\u003e              \u003ctd\u003eTue; Tuesday; T\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ee/c\u003c/th\u003e     \u003ctd\u003elocalized day-of-week\u003c/td\u003e       \u003ctd\u003enumber/text\u003c/td\u003e       \u003ctd\u003e2; 02; Tue; Tuesday; T\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eF\u003c/th\u003e       \u003ctd\u003eday-of-week-in-month\u003c/td\u003e        \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e3\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ea\u003c/th\u003e       \u003ctd\u003eam-pm-of-day\u003c/td\u003e                \u003ctd\u003etext\u003c/td\u003e              \u003ctd\u003ePM\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eh\u003c/th\u003e       \u003ctd\u003eclock-hour-of-am-pm (1-12)\u003c/td\u003e  \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e12\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eK\u003c/th\u003e       \u003ctd\u003ehour-of-am-pm (0-11)\u003c/td\u003e        \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e0\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ek\u003c/th\u003e       \u003ctd\u003eclock-hour-of-day (1-24)\u003c/td\u003e    \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e24\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eH\u003c/th\u003e       \u003ctd\u003ehour-of-day (0-23)\u003c/td\u003e          \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e0\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003em\u003c/th\u003e       \u003ctd\u003eminute-of-hour\u003c/td\u003e              \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e30\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003es\u003c/th\u003e       \u003ctd\u003esecond-of-minute\u003c/td\u003e            \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e55\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eS\u003c/th\u003e       \u003ctd\u003efraction-of-second\u003c/td\u003e          \u003ctd\u003efraction\u003c/td\u003e          \u003ctd\u003e978\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eA\u003c/th\u003e       \u003ctd\u003emilli-of-day\u003c/td\u003e                \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e1234\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003en\u003c/th\u003e       \u003ctd\u003enano-of-second\u003c/td\u003e              \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e987654321\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eN\u003c/th\u003e       \u003ctd\u003enano-of-day\u003c/td\u003e                 \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e1234000000\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eV\u003c/th\u003e       \u003ctd\u003etime-zone ID\u003c/td\u003e                \u003ctd\u003ezone-id\u003c/td\u003e           \u003ctd\u003eAmerica/Los_Angeles; Z; -08:30\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ev\u003c/th\u003e       \u003ctd\u003egeneric time-zone name\u003c/td\u003e      \u003ctd\u003ezone-name\u003c/td\u003e         \u003ctd\u003ePacific Time; PT\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ez\u003c/th\u003e       \u003ctd\u003etime-zone name\u003c/td\u003e              \u003ctd\u003ezone-name\u003c/td\u003e         \u003ctd\u003ePacific Standard Time; PST\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eO\u003c/th\u003e       \u003ctd\u003elocalized zone-offset\u003c/td\u003e       \u003ctd\u003eoffset-O\u003c/td\u003e          \u003ctd\u003eGMT+8; GMT+08:00; UTC-08:00\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eX\u003c/th\u003e       \u003ctd\u003ezone-offset \u0027Z\u0027 for zero\u003c/td\u003e    \u003ctd\u003eoffset-X\u003c/td\u003e          \u003ctd\u003eZ; -08; -0830; -08:30; -083015; -08:30:15\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ex\u003c/th\u003e       \u003ctd\u003ezone-offset\u003c/td\u003e                 \u003ctd\u003eoffset-x\u003c/td\u003e          \u003ctd\u003e+0000; -08; -0830; -08:30; -083015; -08:30:15\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eZ\u003c/th\u003e       \u003ctd\u003ezone-offset\u003c/td\u003e                 \u003ctd\u003eoffset-Z\u003c/td\u003e          \u003ctd\u003e+0000; -0800; -08:00\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ep\u003c/th\u003e       \u003ctd\u003epad next\u003c/td\u003e                    \u003ctd\u003epad modifier\u003c/td\u003e      \u003ctd\u003e1\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e\u0027\u003c/th\u003e       \u003ctd\u003eescape for text\u003c/td\u003e             \u003ctd\u003edelimiter\u003c/td\u003e         \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e\u0027\u0027\u003c/th\u003e      \u003ctd\u003esingle quote\u003c/td\u003e                \u003ctd\u003eliteral\u003c/td\u003e           \u003ctd\u003e\u0027\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e[\u003c/th\u003e       \u003ctd\u003eoptional section start\u003c/td\u003e      \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e]\u003c/th\u003e       \u003ctd\u003eoptional section end\u003c/td\u003e        \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e#\u003c/th\u003e       \u003ctd\u003ereserved for future use\u003c/td\u003e     \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{\u003c/th\u003e       \u003ctd\u003ereserved for future use\u003c/td\u003e     \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e}\u003c/th\u003e       \u003ctd\u003ereserved for future use\u003c/td\u003e     \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n * \u003c/tbody\u003e\n * \u003c/table\u003e\n * \u003cp\u003e\n * The count of pattern letters determines the format.\n * \u003cp\u003e\n * \u003cb\u003eText\u003c/b\u003e: The text style is determined based on the number of pattern\n * letters used. Less than 4 pattern letters will use the\n * {@link TextStyle#SHORT short form}. Exactly 4 pattern letters will use the\n * {@link TextStyle#FULL full form}. Exactly 5 pattern letters will use the\n * {@link TextStyle#NARROW narrow form}.\n * Pattern letters \u0027L\u0027, \u0027c\u0027, and \u0027q\u0027 specify the stand-alone form of the text styles.\n * \u003cp\u003e\n * \u003cb\u003eNumber\u003c/b\u003e: If the count of letters is one, then the value is output using\n * the minimum number of digits and without padding. Otherwise, the count of digits\n * is used as the width of the output field, with the value zero-padded as necessary.\n * The following pattern letters have constraints on the count of letters.\n * Only one letter of \u0027c\u0027 and \u0027F\u0027 can be specified.\n * Up to two letters of \u0027d\u0027, \u0027H\u0027, \u0027h\u0027, \u0027K\u0027, \u0027k\u0027, \u0027m\u0027, and \u0027s\u0027 can be specified.\n * Up to three letters of \u0027D\u0027 can be specified.\n * \u003cp\u003e\n * \u003cb\u003eNumber/Text\u003c/b\u003e: If the count of pattern letters is 3 or greater, use the\n * Text rules above. Otherwise use the Number rules above.\n * \u003cp\u003e\n * \u003cb\u003eFraction\u003c/b\u003e: Outputs the nano-of-second field as a fraction-of-second.\n * The nano-of-second value has nine digits, thus the count of pattern letters\n * is from 1 to 9. If it is less than 9, then the nano-of-second value is\n * truncated, with only the most significant digits being output.\n * \u003cp\u003e\n * \u003cb\u003eYear\u003c/b\u003e: The count of letters determines the minimum field width below\n * which padding is used. If the count of letters is two, then a\n * {@link DateTimeFormatterBuilder#appendValueReduced reduced} two digit form is\n * used. For printing, this outputs the rightmost two digits. For parsing, this\n * will parse using the base value of 2000, resulting in a year within the range\n * 2000 to 2099 inclusive. If the count of letters is less than four (but not\n * two), then the sign is only output for negative years as per\n * {@link SignStyle#NORMAL}. Otherwise, the sign is output if the pad width is\n * exceeded, as per {@link SignStyle#EXCEEDS_PAD}.\n * \u003cp\u003e\n * \u003cb\u003eZoneId\u003c/b\u003e: This outputs the time-zone ID, such as \u0027Europe/Paris\u0027. If the\n * count of letters is two, then the time-zone ID is output. Any other count of\n * letters throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eZone names\u003c/b\u003e: This outputs the display name of the time-zone ID. If the\n * pattern letter is \u0027z\u0027 the output is the daylight savings aware zone name.\n * If there is insufficient information to determine whether DST applies,\n * the name ignoring daylight savings time will be used.\n * If the count of letters is one, two or three, then the short name is output.\n * If the count of letters is four, then the full name is output.\n * Five or more letters throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * If the pattern letter is \u0027v\u0027 the output provides the zone name ignoring\n * daylight savings time. If the count of letters is one, then the short name is output.\n * If the count of letters is four, then the full name is output.\n * Two, three and five or more letters throw {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eOffset X and x\u003c/b\u003e: This formats the offset based on the number of pattern\n * letters. One letter outputs just the hour, such as \u0027+01\u0027, unless the minute\n * is non-zero in which case the minute is also output, such as \u0027+0130\u0027. Two\n * letters outputs the hour and minute, without a colon, such as \u0027+0130\u0027. Three\n * letters outputs the hour and minute, with a colon, such as \u0027+01:30\u0027. Four\n * letters outputs the hour and minute and optional second, without a colon,\n * such as \u0027+013015\u0027. Five letters outputs the hour and minute and optional\n * second, with a colon, such as \u0027+01:30:15\u0027. Six or more letters throws\n * {@code IllegalArgumentException}. Pattern letter \u0027X\u0027 (upper case) will output\n * \u0027Z\u0027 when the offset to be output would be zero, whereas pattern letter \u0027x\u0027\n * (lower case) will output \u0027+00\u0027, \u0027+0000\u0027, or \u0027+00:00\u0027.\n * \u003cp\u003e\n * \u003cb\u003eOffset O\u003c/b\u003e: This formats the localized offset based on the number of\n * pattern letters. One letter outputs the {@linkplain TextStyle#SHORT short}\n * form of the localized offset, which is localized offset text, such as \u0027GMT\u0027,\n * with hour without leading zero, optional 2-digit minute and second if\n * non-zero, and colon, for example \u0027GMT+8\u0027. Four letters outputs the\n * {@linkplain TextStyle#FULL full} form, which is localized offset text,\n * such as \u0027GMT, with 2-digit hour and minute field, optional second field\n * if non-zero, and colon, for example \u0027GMT+08:00\u0027. Any other count of letters\n * throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eOffset Z\u003c/b\u003e: This formats the offset based on the number of pattern\n * letters. One, two or three letters outputs the hour and minute, without a\n * colon, such as \u0027+0130\u0027. The output will be \u0027+0000\u0027 when the offset is zero.\n * Four letters outputs the {@linkplain TextStyle#FULL full} form of localized\n * offset, equivalent to four letters of Offset-O. The output will be the\n * corresponding localized offset text if the offset is zero. Five\n * letters outputs the hour, minute, with optional second if non-zero, with\n * colon. It outputs \u0027Z\u0027 if the offset is zero.\n * Six or more letters throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eOptional section\u003c/b\u003e: The optional section markers work exactly like\n * calling {@link DateTimeFormatterBuilder#optionalStart()} and\n * {@link DateTimeFormatterBuilder#optionalEnd()}.\n * \u003cp\u003e\n * \u003cb\u003ePad modifier\u003c/b\u003e: Modifies the pattern that immediately follows to be\n * padded with spaces. The pad width is determined by the number of pattern\n * letters. This is the same as calling\n * {@link DateTimeFormatterBuilder#padNext(int)}.\n * \u003cp\u003e\n * For example, \u0027ppH\u0027 outputs the hour-of-day padded on the left with spaces to\n * a width of 2.\n * \u003cp\u003e\n * Any unrecognized letter is an error. Any non-letter character, other than\n * \u0027[\u0027, \u0027]\u0027, \u0027{\u0027, \u0027}\u0027, \u0027#\u0027 and the single quote will be output directly.\n * Despite this, it is recommended to use single quotes around all characters\n * that you want to output directly to ensure that future changes do not break\n * your application.\n *\n * \u003ch3 id\u003d\"resolving\"\u003eResolving\u003c/h3\u003e\n * Parsing is implemented as a two-phase operation.\n * First, the text is parsed using the layout defined by the formatter, producing\n * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.\n * Second, the parsed data is \u003cem\u003eresolved\u003c/em\u003e, by validating, combining and\n * simplifying the various fields into more useful ones.\n * \u003cp\u003e\n * Five parsing methods are supplied by this class.\n * Four of these perform both the parse and resolve phases.\n * The fifth method, {@link #parseUnresolved(CharSequence, ParsePosition)},\n * only performs the first phase, leaving the result unresolved.\n * As such, it is essentially a low-level operation.\n * \u003cp\u003e\n * The resolve phase is controlled by two parameters, set on this class.\n * \u003cp\u003e\n * The {@link ResolverStyle} is an enum that offers three different approaches,\n * strict, smart and lenient. The smart option is the default.\n * It can be set using {@link #withResolverStyle(ResolverStyle)}.\n * \u003cp\u003e\n * The {@link #withResolverFields(TemporalField...)} parameter allows the\n * set of fields that will be resolved to be filtered before resolving starts.\n * For example, if the formatter has parsed a year, month, day-of-month\n * and day-of-year, then there are two approaches to resolve a date:\n * (year + month + day-of-month) and (year + day-of-year).\n * The resolver fields allows one of the two approaches to be selected.\n * If no resolver fields are set then both approaches must result in the same date.\n * \u003cp\u003e\n * Resolving separate fields to form a complete date and time is a complex\n * process with behaviour distributed across a number of classes.\n * It follows these steps:\n * \u003col\u003e\n * \u003cli\u003eThe chronology is determined.\n * The chronology of the result is either the chronology that was parsed,\n * or if no chronology was parsed, it is the chronology set on this class,\n * or if that is null, it is {@code IsoChronology}.\n * \u003cli\u003eThe {@code ChronoField} date fields are resolved.\n * This is achieved using {@link Chronology#resolveDate(Map, ResolverStyle)}.\n * Documentation about field resolution is located in the implementation\n * of {@code Chronology}.\n * \u003cli\u003eThe {@code ChronoField} time fields are resolved.\n * This is documented on {@link ChronoField} and is the same for all chronologies.\n * \u003cli\u003eAny fields that are not {@code ChronoField} are processed.\n * This is achieved using {@link TemporalField#resolve(Map, TemporalAccessor, ResolverStyle)}.\n * Documentation about field resolution is located in the implementation\n * of {@code TemporalField}.\n * \u003cli\u003eThe {@code ChronoField} date and time fields are re-resolved.\n * This allows fields in step four to produce {@code ChronoField} values\n * and have them be processed into dates and times.\n * \u003cli\u003eA {@code LocalTime} is formed if there is at least an hour-of-day available.\n * This involves providing default values for minute, second and fraction of second.\n * \u003cli\u003eAny remaining unresolved fields are cross-checked against any\n * date and/or time that was resolved. Thus, an earlier stage would resolve\n * (year + month + day-of-month) to a date, and this stage would check that\n * day-of-week was valid for the date.\n * \u003cli\u003eIf an {@linkplain #parsedExcessDays() excess number of days}\n * was parsed then it is added to the date if a date is available.\n * \u003cli\u003e If a second-based field is present, but {@code LocalTime} was not parsed,\n * then the resolver ensures that milli, micro and nano second values are\n * available to meet the contract of {@link ChronoField}.\n * These will be set to zero if missing.\n * \u003cli\u003eIf both date and time were parsed and either an offset or zone is present,\n * the field {@link ChronoField#INSTANT_SECONDS} is created.\n * If an offset was parsed then the offset will be combined with the\n * {@code LocalDateTime} to form the instant, with any zone ignored.\n * If a {@code ZoneId} was parsed without an offset then the zone will be\n * combined with the {@code LocalDateTime} to form the instant using the rules\n * of {@link ChronoLocalDateTime#atZone(ZoneId)}.\n * \u003c/ol\u003e\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class DateTimeFormatter {\n\n    /**\n     * The printer and/or parser to use, not null.\n     */\n    private final CompositePrinterParser printerParser;\n    /**\n     * The locale to use for formatting, not null.\n     */\n    private final Locale locale;\n    /**\n     * The symbols to use for formatting, not null.\n     */\n    private final DecimalStyle decimalStyle;\n    /**\n     * The resolver style to use, not null.\n     */\n    private final ResolverStyle resolverStyle;\n    /**\n     * The fields to use in resolving, null for all fields.\n     */\n    private final Set\u003cTemporalField\u003e resolverFields;\n    /**\n     * The chronology to use for formatting, null for no override.\n     */\n    private final Chronology chrono;\n    /**\n     * The zone to use for formatting, null for no override.\n     */\n    private final ZoneId zone;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a formatter using the specified pattern.\n     * \u003cp\u003e\n     * This method will create a formatter based on a simple\n     * \u003ca href\u003d\"#patterns\"\u003epattern of letters and symbols\u003c/a\u003e\n     * as described in the class documentation.\n     * For example, {@code d MMM uuuu} will format 2011-12-03 as \u00273 Dec 2011\u0027.\n     * \u003cp\u003e\n     * The formatter will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * This can be changed using {@link DateTimeFormatter#withLocale(Locale)} on the returned formatter.\n     * Alternatively use the {@link #ofPattern(String, Locale)} variant of this method.\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses {@link ResolverStyle#SMART SMART} resolver style.\n     *\n     * @param pattern  the pattern to use, not null\n     * @return the formatter based on the pattern, not null\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormatterBuilder#appendPattern(String)\n     */\n    public static DateTimeFormatter ofPattern(String pattern) {\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n    }\n\n    /**\n     * Creates a formatter using the specified pattern and locale.\n     * \u003cp\u003e\n     * This method will create a formatter based on a simple\n     * \u003ca href\u003d\"#patterns\"\u003epattern of letters and symbols\u003c/a\u003e\n     * as described in the class documentation.\n     * For example, {@code d MMM uuuu} will format 2011-12-03 as \u00273 Dec 2011\u0027.\n     * \u003cp\u003e\n     * The formatter will use the specified locale.\n     * This can be changed using {@link DateTimeFormatter#withLocale(Locale)} on the returned formatter.\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses {@link ResolverStyle#SMART SMART} resolver style.\n     *\n     * @param pattern  the pattern to use, not null\n     * @param locale  the locale to use, not null\n     * @return the formatter based on the pattern, not null\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormatterBuilder#appendPattern(String)\n     */\n    public static DateTimeFormatter ofPattern(String pattern, Locale locale) {\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter(locale);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a locale specific date format for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a date.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     *\n     * @param dateStyle  the formatter style to obtain, not null\n     * @return the date formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedDate(FormatStyle dateStyle) {\n        Objects.requireNonNull(dateStyle, \"dateStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(dateStyle, null)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    /**\n     * Returns a locale specific time format for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a time.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     * The {@code FULL} and {@code LONG} styles typically require a time-zone.\n     * When formatting using these styles, a {@code ZoneId} must be available,\n     * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.\n     *\n     * @param timeStyle  the formatter style to obtain, not null\n     * @return the time formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedTime(FormatStyle timeStyle) {\n        Objects.requireNonNull(timeStyle, \"timeStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(null, timeStyle)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    /**\n     * Returns a locale specific date-time formatter for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a date-time.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     * The {@code FULL} and {@code LONG} styles typically require a time-zone.\n     * When formatting using these styles, a {@code ZoneId} must be available,\n     * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.\n     *\n     * @param dateTimeStyle  the formatter style to obtain, not null\n     * @return the date-time formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateTimeStyle) {\n        Objects.requireNonNull(dateTimeStyle, \"dateTimeStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(dateTimeStyle, dateTimeStyle)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    /**\n     * Returns a locale specific date and time format for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a date-time.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault() default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     * The {@code FULL} and {@code LONG} styles typically require a time-zone.\n     * When formatting using these styles, a {@code ZoneId} must be available,\n     * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.\n     *\n     * @param dateStyle  the date formatter style to obtain, not null\n     * @param timeStyle  the time formatter style to obtain, not null\n     * @return the date, time or date-time formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateStyle, FormatStyle timeStyle) {\n        Objects.requireNonNull(dateStyle, \"dateStyle\");\n        Objects.requireNonNull(timeStyle, \"timeStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(dateStyle, timeStyle)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date without an\n     * offset, such as \u00272011-12-03\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended local date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits or more for the {@link ChronoField#YEAR year}.\n     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.\n     * Years outside that range will have a prefixed positive or negative symbol.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MONTH_OF_YEAR month-of-year}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eTwo digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_LOCAL_DATE;\n    static {\n        ISO_LOCAL_DATE \u003d new DateTimeFormatterBuilder()\n                .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(MONTH_OF_YEAR, 2)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(DAY_OF_MONTH, 2)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date with an\n     * offset, such as \u00272011-12-03+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE}\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_OFFSET_DATE;\n    static {\n        ISO_OFFSET_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE)\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date with the\n     * offset if available, such as \u00272011-12-03\u0027 or \u00272011-12-03+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE}\n     * \u003cli\u003eIf the offset is not available then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_DATE;\n    static {\n        ISO_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO time formatter that formats or parses a time without an\n     * offset, such as \u002710:15\u0027 or \u002710:15:30\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended local time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eTwo digits for the {@link ChronoField#HOUR_OF_DAY hour-of-day}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MINUTE_OF_HOUR minute-of-hour}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the second-of-minute is not available then the format is complete.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#SECOND_OF_MINUTE second-of-minute}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the nano-of-second is zero or not available then the format is complete.\n     * \u003cli\u003eA decimal point\n     * \u003cli\u003eOne to nine digits for the {@link ChronoField#NANO_OF_SECOND nano-of-second}.\n     *  As many digits will be output as required.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_LOCAL_TIME;\n    static {\n        ISO_LOCAL_TIME \u003d new DateTimeFormatterBuilder()\n                .appendValue(HOUR_OF_DAY, 2)\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(MINUTE_OF_HOUR, 2)\n                .optionalStart()\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(SECOND_OF_MINUTE, 2)\n                .optionalStart()\n                .appendFraction(NANO_OF_SECOND, 0, 9, true)\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO time formatter that formats or parses a time with an\n     * offset, such as \u002710:15+01:00\u0027 or \u002710:15:30+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_TIME}\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_OFFSET_TIME;\n    static {\n        ISO_OFFSET_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_TIME)\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO time formatter that formats or parses a time, with the\n     * offset if available, such as \u002710:15\u0027, \u002710:15:30\u0027 or \u002710:15:30+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_TIME}\n     * \u003cli\u003eIf the offset is not available then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_TIME;\n    static {\n        ISO_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_TIME)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date-time formatter that formats or parses a date-time without\n     * an offset, such as \u00272011-12-03T10:15:30\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset date-time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE}\n     * \u003cli\u003eThe letter \u0027T\u0027. Parsing is case insensitive.\n     * \u003cli\u003eThe {@link #ISO_LOCAL_TIME}\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_LOCAL_DATE_TIME;\n    static {\n        ISO_LOCAL_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE)\n                .appendLiteral(\u0027T\u0027)\n                .append(ISO_LOCAL_TIME)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date-time formatter that formats or parses a date-time with an\n     * offset, such as \u00272011-12-03T10:15:30+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset date-time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE_TIME}\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  The offset parsing is lenient, which allows the minutes and seconds to be optional.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_OFFSET_DATE_TIME;\n    static {\n        ISO_OFFSET_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE_TIME)\n                .parseLenient()\n                .appendOffsetId()\n                .parseStrict()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO-like date-time formatter that formats or parses a date-time with\n     * offset and zone, such as \u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * a format that extends the ISO-8601 extended offset date-time format\n     * to add the time-zone.\n     * The section in square brackets is not part of the ISO-8601 standard.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_OFFSET_DATE_TIME}\n     * \u003cli\u003eIf the zone ID is not available or is a {@code ZoneOffset} then the format is complete.\n     * \u003cli\u003eAn open square bracket \u0027[\u0027.\n     * \u003cli\u003eThe {@link ZoneId#getId() zone ID}. This is not part of the ISO-8601 standard.\n     *  Parsing is case sensitive.\n     * \u003cli\u003eA close square bracket \u0027]\u0027.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_ZONED_DATE_TIME;\n    static {\n        ISO_ZONED_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .append(ISO_OFFSET_DATE_TIME)\n                .optionalStart()\n                .appendLiteral(\u0027[\u0027)\n                .parseCaseSensitive()\n                .appendZoneRegionId()\n                .appendLiteral(\u0027]\u0027)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO-like date-time formatter that formats or parses a date-time with\n     * the offset and zone if available, such as \u00272011-12-03T10:15:30\u0027,\n     * \u00272011-12-03T10:15:30+01:00\u0027 or \u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended local or offset date-time format, as well as the\n     * extended non-ISO form specifying the time-zone.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE_TIME}\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     * \u003cli\u003eIf the zone ID is not available or is a {@code ZoneOffset} then the format is complete.\n     * \u003cli\u003eAn open square bracket \u0027[\u0027.\n     * \u003cli\u003eThe {@link ZoneId#getId() zone ID}. This is not part of the ISO-8601 standard.\n     *  Parsing is case sensitive.\n     * \u003cli\u003eA close square bracket \u0027]\u0027.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_DATE_TIME;\n    static {\n        ISO_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .append(ISO_LOCAL_DATE_TIME)\n                .optionalStart()\n                .appendOffsetId()\n                .optionalStart()\n                .appendLiteral(\u0027[\u0027)\n                .parseCaseSensitive()\n                .appendZoneRegionId()\n                .appendLiteral(\u0027]\u0027)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses the ordinal date\n     * without an offset, such as \u00272012-337\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended ordinal date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits or more for the {@link ChronoField#YEAR year}.\n     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.\n     * Years outside that range will have a prefixed positive or negative symbol.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eThree digits for the {@link ChronoField#DAY_OF_YEAR day-of-year}.\n     *  This is pre-padded by zero to ensure three digits.\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_ORDINAL_DATE;\n    static {\n        ISO_ORDINAL_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(DAY_OF_YEAR, 3)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses the week-based date\n     * without an offset, such as \u00272012-W48-6\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended week-based date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits or more for the {@link IsoFields#WEEK_BASED_YEAR week-based-year}.\n     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.\n     * Years outside that range will have a prefixed positive or negative symbol.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eThe letter \u0027W\u0027. Parsing is case insensitive.\n     * \u003cli\u003eTwo digits for the {@link IsoFields#WEEK_OF_WEEK_BASED_YEAR week-of-week-based-year}.\n     *  This is pre-padded by zero to ensure three digits.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eOne digit for the {@link ChronoField#DAY_OF_WEEK day-of-week}.\n     *  The value run from Monday (1) to Sunday (7).\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_WEEK_DATE;\n    static {\n        ISO_WEEK_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendValue(IsoFields.WEEK_BASED_YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n                .appendLiteral(\"-W\")\n                .appendValue(IsoFields.WEEK_OF_WEEK_BASED_YEAR, 2)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(DAY_OF_WEEK, 1)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO instant formatter that formats or parses an instant in UTC,\n     * such as \u00272011-12-03T10:15:30Z\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 instant format.\n     * When formatting, the second-of-minute is always output.\n     * The nano-of-second outputs zero, three, six or nine digits as necessary.\n     * When parsing, time to at least the seconds field is required.\n     * Fractional seconds from zero to nine are parsed.\n     * The localized decimal style is not used.\n     * \u003cp\u003e\n     * This is a special case formatter intended to allow a human readable form\n     * of an {@link java.time.Instant}. The {@code Instant} class is designed to\n     * only represent a point in time and internally stores a value in nanoseconds\n     * from a fixed epoch of 1970-01-01Z. As such, an {@code Instant} cannot be\n     * formatted as a date or time without providing some form of time-zone.\n     * This formatter allows the {@code Instant} to be formatted, by providing\n     * a suitable conversion using {@code ZoneOffset.UTC}.\n     * \u003cp\u003e\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_OFFSET_DATE_TIME} where the instant is converted from\n     *  {@link ChronoField#INSTANT_SECONDS} and {@link ChronoField#NANO_OF_SECOND}\n     *  using the {@code UTC} offset. Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_INSTANT;\n    static {\n        ISO_INSTANT \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendInstant()\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date without an\n     * offset, such as \u002720111203\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 basic local date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits for the {@link ChronoField#YEAR year}.\n     *  Only years in the range 0000 to 9999 are supported.\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MONTH_OF_YEAR month-of-year}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eTwo digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID} without colons. If the offset has\n     *  seconds then they will be handled even though this is not part of the ISO-8601 standard.\n     *  The offset parsing is lenient, which allows the minutes and seconds to be optional.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter BASIC_ISO_DATE;\n    static {\n        BASIC_ISO_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendValue(YEAR, 4)\n                .appendValue(MONTH_OF_YEAR, 2)\n                .appendValue(DAY_OF_MONTH, 2)\n                .optionalStart()\n                .parseLenient()\n                .appendOffset(\"+HHMMss\", \"Z\")\n                .parseStrict()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The RFC-1123 date-time formatter, such as \u0027Tue, 3 Jun 2008 11:05:30 GMT\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * most of the RFC-1123 format.\n     * RFC-1123 updates RFC-822 changing the year from two digits to four.\n     * This implementation requires a four digit year.\n     * This implementation also does not handle North American or military zone\n     * names, only \u0027GMT\u0027 and offset amounts.\n     * \u003cp\u003e\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eIf the day-of-week is not available to format or parse then jump to day-of-month.\n     * \u003cli\u003eThree letter {@link ChronoField#DAY_OF_WEEK day-of-week} in English.\n     * \u003cli\u003eA comma\n     * \u003cli\u003eA space\n     * \u003cli\u003eOne or two digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.\n     * \u003cli\u003eA space\n     * \u003cli\u003eThree letter {@link ChronoField#MONTH_OF_YEAR month-of-year} in English.\n     * \u003cli\u003eA space\n     * \u003cli\u003eFour digits for the {@link ChronoField#YEAR year}.\n     *  Only years in the range 0000 to 9999 are supported.\n     * \u003cli\u003eA space\n     * \u003cli\u003eTwo digits for the {@link ChronoField#HOUR_OF_DAY hour-of-day}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MINUTE_OF_HOUR minute-of-hour}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the second-of-minute is not available then jump to the next space.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#SECOND_OF_MINUTE second-of-minute}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA space\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID} without colons or seconds.\n     *  An offset of zero uses \"GMT\". North American zone names and military zone names are not handled.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Parsing is case insensitive.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     */\n    public static final DateTimeFormatter RFC_1123_DATE_TIME;\n    static {\n        // manually code maps to ensure correct data always used\n        // (locale data can be changed by application code)\n        Map\u003cLong, String\u003e dow \u003d new HashMap\u003c\u003e();\n        dow.put(1L, \"Mon\");\n        dow.put(2L, \"Tue\");\n        dow.put(3L, \"Wed\");\n        dow.put(4L, \"Thu\");\n        dow.put(5L, \"Fri\");\n        dow.put(6L, \"Sat\");\n        dow.put(7L, \"Sun\");\n        Map\u003cLong, String\u003e moy \u003d new HashMap\u003c\u003e();\n        moy.put(1L, \"Jan\");\n        moy.put(2L, \"Feb\");\n        moy.put(3L, \"Mar\");\n        moy.put(4L, \"Apr\");\n        moy.put(5L, \"May\");\n        moy.put(6L, \"Jun\");\n        moy.put(7L, \"Jul\");\n        moy.put(8L, \"Aug\");\n        moy.put(9L, \"Sep\");\n        moy.put(10L, \"Oct\");\n        moy.put(11L, \"Nov\");\n        moy.put(12L, \"Dec\");\n        RFC_1123_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .parseLenient()\n                .optionalStart()\n                .appendText(DAY_OF_WEEK, dow)\n                .appendLiteral(\", \")\n                .optionalEnd()\n                .appendValue(DAY_OF_MONTH, 1, 2, SignStyle.NOT_NEGATIVE)\n                .appendLiteral(\u0027 \u0027)\n                .appendText(MONTH_OF_YEAR, moy)\n                .appendLiteral(\u0027 \u0027)\n                .appendValue(YEAR, 4)  // 2 digit year not handled\n                .appendLiteral(\u0027 \u0027)\n                .appendValue(HOUR_OF_DAY, 2)\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(MINUTE_OF_HOUR, 2)\n                .optionalStart()\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(SECOND_OF_MINUTE, 2)\n                .optionalEnd()\n                .appendLiteral(\u0027 \u0027)\n                .appendOffset(\"+HHMM\", \"GMT\")  // should handle UT/Z/EST/EDT/CST/CDT/MST/MDT/PST/MDT\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * A query that provides access to the excess days that were parsed.\n     * \u003cp\u003e\n     * This returns a singleton {@linkplain TemporalQuery query} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null period, with a zero period returned instead of null.\n     * \u003cp\u003e\n     * There are two situations where this query may return a non-zero period.\n     * \u003cul\u003e\n     * \u003cli\u003eIf the {@code ResolverStyle} is {@code LENIENT} and a time is parsed\n     *  without a date, then the complete result of the parse consists of a\n     *  {@code LocalTime} and an excess {@code Period} in days.\n     *\n     * \u003cli\u003eIf the {@code ResolverStyle} is {@code SMART} and a time is parsed\n     *  without a date where the time is 24:00:00, then the complete result of\n     *  the parse consists of a {@code LocalTime} of 00:00:00 and an excess\n     *  {@code Period} of one day.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * In both cases, if a complete {@code ChronoLocalDateTime} or {@code Instant}\n     * is parsed, then the excess days are added to the date part.\n     * As a result, this query will return a zero period.\n     * \u003cp\u003e\n     * The {@code SMART} behaviour handles the common \"end of day\" 24:00 value.\n     * Processing in {@code LENIENT} mode also produces the same result:\n     * \u003cpre\u003e\n     *  Text to parse        Parsed object                         Excess days\n     *  \"2012-12-03T00:00\"   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO\n     *  \"2012-12-03T24:00\"   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO\n     *  \"00:00\"              LocalTime.of(0, 0)                    ZERO\n     *  \"24:00\"              LocalTime.of(0, 0)                    Period.ofDays(1)\n     * \u003c/pre\u003e\n     * The query can be used as follows:\n     * \u003cpre\u003e\n     *  TemporalAccessor parsed \u003d formatter.parse(str);\n     *  LocalTime time \u003d parsed.query(LocalTime::from);\n     *  Period extraDays \u003d parsed.query(DateTimeFormatter.parsedExcessDays());\n     * \u003c/pre\u003e\n     * @return a query that provides access to the excess days that were parsed\n     */\n    public static final TemporalQuery\u003cPeriod\u003e parsedExcessDays() {\n        return PARSED_EXCESS_DAYS;\n    }\n    private static final TemporalQuery\u003cPeriod\u003e PARSED_EXCESS_DAYS \u003d t -\u003e {\n        if (t instanceof Parsed) {\n            return ((Parsed) t).excessDays;\n        } else {\n            return Period.ZERO;\n        }\n    };\n\n    /**\n     * A query that provides access to whether a leap-second was parsed.\n     * \u003cp\u003e\n     * This returns a singleton {@linkplain TemporalQuery query} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null boolean, true if parsing saw a leap-second, false if not.\n     * \u003cp\u003e\n     * Instant parsing handles the special \"leap second\" time of \u002723:59:60\u0027.\n     * Leap seconds occur at \u002723:59:60\u0027 in the UTC time-zone, but at other\n     * local times in different time-zones. To avoid this potential ambiguity,\n     * the handling of leap-seconds is limited to\n     * {@link DateTimeFormatterBuilder#appendInstant()}, as that method\n     * always parses the instant with the UTC zone offset.\n     * \u003cp\u003e\n     * If the time \u002723:59:60\u0027 is received, then a simple conversion is applied,\n     * replacing the second-of-minute of 60 with 59. This query can be used\n     * on the parse result to determine if the leap-second adjustment was made.\n     * The query will return {@code true} if it did adjust to remove the\n     * leap-second, and {@code false} if not. Note that applying a leap-second\n     * smoothing mechanism, such as UTC-SLS, is the responsibility of the\n     * application, as follows:\n     * \u003cpre\u003e\n     *  TemporalAccessor parsed \u003d formatter.parse(str);\n     *  Instant instant \u003d parsed.query(Instant::from);\n     *  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {\n     *    // validate leap-second is correct and apply correct smoothing\n     *  }\n     * \u003c/pre\u003e\n     * @return a query that provides access to whether a leap-second was parsed\n     */\n    public static final TemporalQuery\u003cBoolean\u003e parsedLeapSecond() {\n        return PARSED_LEAP_SECOND;\n    }\n    private static final TemporalQuery\u003cBoolean\u003e PARSED_LEAP_SECOND \u003d t -\u003e {\n        if (t instanceof Parsed) {\n            return ((Parsed) t).leapSecond;\n        } else {\n            return Boolean.FALSE;\n        }\n    };\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param printerParser  the printer/parser to use, not null\n     * @param locale  the locale to use, not null\n     * @param decimalStyle  the DecimalStyle to use, not null\n     * @param resolverStyle  the resolver style to use, not null\n     * @param resolverFields  the fields to use during resolving, null for all fields\n     * @param chrono  the chronology to use, null for no override\n     * @param zone  the zone to use, null for no override\n     */\n    DateTimeFormatter(CompositePrinterParser printerParser,\n            Locale locale, DecimalStyle decimalStyle,\n            ResolverStyle resolverStyle, Set\u003cTemporalField\u003e resolverFields,\n            Chronology chrono, ZoneId zone) {\n        this.printerParser \u003d Objects.requireNonNull(printerParser, \"printerParser\");\n        this.resolverFields \u003d resolverFields;\n        this.locale \u003d Objects.requireNonNull(locale, \"locale\");\n        this.decimalStyle \u003d Objects.requireNonNull(decimalStyle, \"decimalStyle\");\n        this.resolverStyle \u003d Objects.requireNonNull(resolverStyle, \"resolverStyle\");\n        this.chrono \u003d chrono;\n        this.zone \u003d zone;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the locale to be used during formatting.\n     * \u003cp\u003e\n     * This is used to lookup any part of the formatter needing specific\n     * localization, such as the text or localized pattern.\n     *\n     * @return the locale of this formatter, not null\n     */\n    public Locale getLocale() {\n        return locale;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new locale.\n     * \u003cp\u003e\n     * This is used to lookup any part of the formatter needing specific\n     * localization, such as the text or localized pattern.\n     * \u003cp\u003e\n     * The locale is stored as passed in, without further processing.\n     * If the locale has \u003ca href\u003d\"../../util/Locale.html#def_locale_extension\"\u003e\n     * Unicode extensions\u003c/a\u003e, they may be used later in text\n     * processing. To set the chronology, time-zone and decimal style from\n     * unicode extensions, see {@link #localizedBy localizedBy()}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param locale  the new locale, not null\n     * @return a formatter based on this formatter with the requested locale, not null\n     * @see #localizedBy(Locale)\n     */\n    public DateTimeFormatter withLocale(Locale locale) {\n        if (this.locale.equals(locale)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    /**\n     * Returns a copy of this formatter with localized values of the locale,\n     * calendar, region, decimal style and/or timezone, that supercede values in\n     * this formatter.\n     * \u003cp\u003e\n     * This is used to lookup any part of the formatter needing specific\n     * localization, such as the text or localized pattern. If the locale contains the\n     * \"ca\" (calendar), \"nu\" (numbering system), \"rg\" (region override), and/or\n     * \"tz\" (timezone)\n     * \u003ca href\u003d\"../../util/Locale.html#def_locale_extension\"\u003eUnicode extensions\u003c/a\u003e,\n     * the chronology, numbering system and/or the zone are overridden. If both \"ca\"\n     * and \"rg\" are specified, the chronology from the \"ca\" extension supersedes the\n     * implicit one from the \"rg\" extension. Same is true for the \"nu\" extension.\n     * \u003cp\u003e\n     * Unlike the {@link #withLocale withLocale} method, the call to this method may\n     * produce a different formatter depending on the order of method chaining with\n     * other withXXXX() methods.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param locale  the locale, not null\n     * @return a formatter based on this formatter with localized values of\n     *      the calendar, decimal style and/or timezone, that supercede values in this\n     *      formatter.\n     * @see #withLocale(Locale)\n     * @since 10\n     */\n    public DateTimeFormatter localizedBy(Locale locale) {\n        if (this.locale.equals(locale)) {\n            return this;\n        }\n\n        // Check for decimalStyle/chronology/timezone in locale object\n        Chronology c \u003d locale.getUnicodeLocaleType(\"ca\") !\u003d null ?\n                       Chronology.ofLocale(locale) : chrono;\n        DecimalStyle ds \u003d locale.getUnicodeLocaleType(\"nu\") !\u003d null ?\n                       DecimalStyle.of(locale) : decimalStyle;\n        String tzType \u003d locale.getUnicodeLocaleType(\"tz\");\n        ZoneId z  \u003d tzType !\u003d null ?\n                    TimeZoneNameUtility.convertLDMLShortID(tzType)\n                        .map(ZoneId::of)\n                        .orElse(zone) :\n                    zone;\n        return new DateTimeFormatter(printerParser, locale, ds, resolverStyle, resolverFields, c, z);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the DecimalStyle to be used during formatting.\n     *\n     * @return the locale of this formatter, not null\n     */\n    public DecimalStyle getDecimalStyle() {\n        return decimalStyle;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new DecimalStyle.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param decimalStyle  the new DecimalStyle, not null\n     * @return a formatter based on this formatter with the requested DecimalStyle, not null\n     */\n    public DateTimeFormatter withDecimalStyle(DecimalStyle decimalStyle) {\n        if (this.decimalStyle.equals(decimalStyle)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the overriding chronology to be used during formatting.\n     * \u003cp\u003e\n     * This returns the override chronology, used to convert dates.\n     * By default, a formatter has no override chronology, returning null.\n     * See {@link #withChronology(Chronology)} for more details on overriding.\n     *\n     * @return the override chronology of this formatter, null if no override\n     */\n    public Chronology getChronology() {\n        return chrono;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new override chronology.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but\n     * with the override chronology set.\n     * By default, a formatter has no override chronology, returning null.\n     * \u003cp\u003e\n     * If an override is added, then any date that is formatted or parsed will be affected.\n     * \u003cp\u003e\n     * When formatting, if the temporal object contains a date, then it will\n     * be converted to a date in the override chronology.\n     * Whether the temporal contains a date is determined by querying the\n     * {@link ChronoField#EPOCH_DAY EPOCH_DAY} field.\n     * Any time or zone will be retained unaltered unless overridden.\n     * \u003cp\u003e\n     * If the temporal object does not contain a date, but does contain one\n     * or more {@code ChronoField} date fields, then a {@code DateTimeException}\n     * is thrown. In all other cases, the override chronology is added to the temporal,\n     * replacing any previous chronology, but without changing the date/time.\n     * \u003cp\u003e\n     * When parsing, there are two distinct cases to consider.\n     * If a chronology has been parsed directly from the text, perhaps because\n     * {@link DateTimeFormatterBuilder#appendChronologyId()} was used, then\n     * this override chronology has no effect.\n     * If no zone has been parsed, then this override chronology will be used\n     * to interpret the {@code ChronoField} values into a date according to the\n     * date resolving rules of the chronology.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param chrono  the new chronology, null if no override\n     * @return a formatter based on this formatter with the requested override chronology, not null\n     */\n    public DateTimeFormatter withChronology(Chronology chrono) {\n        if (Objects.equals(this.chrono, chrono)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the overriding zone to be used during formatting.\n     * \u003cp\u003e\n     * This returns the override zone, used to convert instants.\n     * By default, a formatter has no override zone, returning null.\n     * See {@link #withZone(ZoneId)} for more details on overriding.\n     *\n     * @return the override zone of this formatter, null if no override\n     */\n    public ZoneId getZone() {\n        return zone;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new override zone.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but\n     * with the override zone set.\n     * By default, a formatter has no override zone, returning null.\n     * \u003cp\u003e\n     * If an override is added, then any instant that is formatted or parsed will be affected.\n     * \u003cp\u003e\n     * When formatting, if the temporal object contains an instant, then it will\n     * be converted to a zoned date-time using the override zone.\n     * Whether the temporal is an instant is determined by querying the\n     * {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS} field.\n     * If the input has a chronology then it will be retained unless overridden.\n     * If the input does not have a chronology, such as {@code Instant}, then\n     * the ISO chronology will be used.\n     * \u003cp\u003e\n     * If the temporal object does not contain an instant, but does contain\n     * an offset then an additional check is made. If the normalized override\n     * zone is an offset that differs from the offset of the temporal, then\n     * a {@code DateTimeException} is thrown. In all other cases, the override\n     * zone is added to the temporal, replacing any previous zone, but without\n     * changing the date/time.\n     * \u003cp\u003e\n     * When parsing, there are two distinct cases to consider.\n     * If a zone has been parsed directly from the text, perhaps because\n     * {@link DateTimeFormatterBuilder#appendZoneId()} was used, then\n     * this override zone has no effect.\n     * If no zone has been parsed, then this override zone will be included in\n     * the result of the parse where it can be used to build instants and date-times.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the new override zone, null if no override\n     * @return a formatter based on this formatter with the requested override zone, not null\n     */\n    public DateTimeFormatter withZone(ZoneId zone) {\n        if (Objects.equals(this.zone, zone)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the resolver style to use during parsing.\n     * \u003cp\u003e\n     * This returns the resolver style, used during the second phase of parsing\n     * when fields are resolved into dates and times.\n     * By default, a formatter has the {@link ResolverStyle#SMART SMART} resolver style.\n     * See {@link #withResolverStyle(ResolverStyle)} for more details.\n     *\n     * @return the resolver style of this formatter, not null\n     */\n    public ResolverStyle getResolverStyle() {\n        return resolverStyle;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new resolver style.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but\n     * with the resolver style set. By default, a formatter has the\n     * {@link ResolverStyle#SMART SMART} resolver style.\n     * \u003cp\u003e\n     * Changing the resolver style only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver style is used to control how phase 2, resolving, happens.\n     * See {@code ResolverStyle} for more information on the options available.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param resolverStyle  the new resolver style, not null\n     * @return a formatter based on this formatter with the requested resolver style, not null\n     */\n    public DateTimeFormatter withResolverStyle(ResolverStyle resolverStyle) {\n        Objects.requireNonNull(resolverStyle, \"resolverStyle\");\n        if (Objects.equals(this.resolverStyle, resolverStyle)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the resolver fields to use during parsing.\n     * \u003cp\u003e\n     * This returns the resolver fields, used during the second phase of parsing\n     * when fields are resolved into dates and times.\n     * By default, a formatter has no resolver fields, and thus returns null.\n     * See {@link #withResolverFields(Set)} for more details.\n     *\n     * @return the immutable set of resolver fields of this formatter, null if no fields\n     */\n    public Set\u003cTemporalField\u003e getResolverFields() {\n        return resolverFields;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new set of resolver fields.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but with\n     * the resolver fields set. By default, a formatter has no resolver fields.\n     * \u003cp\u003e\n     * Changing the resolver fields only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver fields are used to filter the field-value pairs between phase 1 and 2.\n     * \u003cp\u003e\n     * This can be used to select between two or more ways that a date or time might\n     * be resolved. For example, if the formatter consists of year, month, day-of-month\n     * and day-of-year, then there are two ways to resolve a date.\n     * Calling this method with the arguments {@link ChronoField#YEAR YEAR} and\n     * {@link ChronoField#DAY_OF_YEAR DAY_OF_YEAR} will ensure that the date is\n     * resolved using the year and day-of-year, effectively meaning that the month\n     * and day-of-month are ignored during the resolving phase.\n     * \u003cp\u003e\n     * In a similar manner, this method can be used to ignore secondary fields that\n     * would otherwise be cross-checked. For example, if the formatter consists of year,\n     * month, day-of-month and day-of-week, then there is only one way to resolve a\n     * date, but the parsed value for day-of-week will be cross-checked against the\n     * resolved date. Calling this method with the arguments {@link ChronoField#YEAR YEAR},\n     * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and\n     * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} will ensure that the date is\n     * resolved correctly, but without any cross-check for the day-of-week.\n     * \u003cp\u003e\n     * In implementation terms, this method behaves as follows. The result of the\n     * parsing phase can be considered to be a map of field to value. The behavior\n     * of this method is to cause that map to be filtered between phase 1 and 2,\n     * removing all fields other than those specified as arguments to this method.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param resolverFields  the new set of resolver fields, null if no fields\n     * @return a formatter based on this formatter with the requested resolver style, not null\n     */\n    public DateTimeFormatter withResolverFields(TemporalField... resolverFields) {\n        Set\u003cTemporalField\u003e fields \u003d null;\n        if (resolverFields !\u003d null) {\n            // Set.of cannot be used because it is hostile to nulls and duplicate elements\n            fields \u003d Collections.unmodifiableSet(new HashSet\u003c\u003e(Arrays.asList(resolverFields)));\n        }\n        if (Objects.equals(this.resolverFields, fields)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, fields, chrono, zone);\n    }\n\n    /**\n     * Returns a copy of this formatter with a new set of resolver fields.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but with\n     * the resolver fields set. By default, a formatter has no resolver fields.\n     * \u003cp\u003e\n     * Changing the resolver fields only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver fields are used to filter the field-value pairs between phase 1 and 2.\n     * \u003cp\u003e\n     * This can be used to select between two or more ways that a date or time might\n     * be resolved. For example, if the formatter consists of year, month, day-of-month\n     * and day-of-year, then there are two ways to resolve a date.\n     * Calling this method with the arguments {@link ChronoField#YEAR YEAR} and\n     * {@link ChronoField#DAY_OF_YEAR DAY_OF_YEAR} will ensure that the date is\n     * resolved using the year and day-of-year, effectively meaning that the month\n     * and day-of-month are ignored during the resolving phase.\n     * \u003cp\u003e\n     * In a similar manner, this method can be used to ignore secondary fields that\n     * would otherwise be cross-checked. For example, if the formatter consists of year,\n     * month, day-of-month and day-of-week, then there is only one way to resolve a\n     * date, but the parsed value for day-of-week will be cross-checked against the\n     * resolved date. Calling this method with the arguments {@link ChronoField#YEAR YEAR},\n     * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and\n     * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} will ensure that the date is\n     * resolved correctly, but without any cross-check for the day-of-week.\n     * \u003cp\u003e\n     * In implementation terms, this method behaves as follows. The result of the\n     * parsing phase can be considered to be a map of field to value. The behavior\n     * of this method is to cause that map to be filtered between phase 1 and 2,\n     * removing all fields other than those specified as arguments to this method.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param resolverFields  the new set of resolver fields, null if no fields\n     * @return a formatter based on this formatter with the requested resolver style, not null\n     */\n    public DateTimeFormatter withResolverFields(Set\u003cTemporalField\u003e resolverFields) {\n        if (Objects.equals(this.resolverFields, resolverFields)) {\n            return this;\n        }\n        if (resolverFields !\u003d null) {\n            resolverFields \u003d Collections.unmodifiableSet(new HashSet\u003c\u003e(resolverFields));\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats a date-time object using this formatter.\n     * \u003cp\u003e\n     * This formats the date-time to a String using the rules of the formatter.\n     *\n     * @param temporal  the temporal object to format, not null\n     * @return the formatted string, not null\n     * @throws DateTimeException if an error occurs during formatting\n     */\n    public String format(TemporalAccessor temporal) {\n        StringBuilder buf \u003d new StringBuilder(32);\n        formatTo(temporal, buf);\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats a date-time object to an {@code Appendable} using this formatter.\n     * \u003cp\u003e\n     * This outputs the formatted date-time to the specified destination.\n     * {@link Appendable} is a general purpose interface that is implemented by all\n     * key character output classes including {@code StringBuffer}, {@code StringBuilder},\n     * {@code PrintStream} and {@code Writer}.\n     * \u003cp\u003e\n     * Although {@code Appendable} methods throw an {@code IOException}, this method does not.\n     * Instead, any {@code IOException} is wrapped in a runtime exception.\n     *\n     * @param temporal  the temporal object to format, not null\n     * @param appendable  the appendable to format to, not null\n     * @throws DateTimeException if an error occurs during formatting\n     */\n    public void formatTo(TemporalAccessor temporal, Appendable appendable) {\n        Objects.requireNonNull(temporal, \"temporal\");\n        Objects.requireNonNull(appendable, \"appendable\");\n        try {\n            DateTimePrintContext context \u003d new DateTimePrintContext(temporal, this);\n            if (appendable instanceof StringBuilder) {\n                printerParser.format(context, (StringBuilder) appendable);\n            } else {\n                // buffer output to avoid writing to appendable in case of error\n                StringBuilder buf \u003d new StringBuilder(32);\n                printerParser.format(context, buf);\n                appendable.append(buf);\n            }\n        } catch (IOException ex) {\n            throw new DateTimeException(ex.getMessage(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Fully parses the text producing a temporal object.\n     * \u003cp\u003e\n     * This parses the entire text producing a temporal object.\n     * It is typically more useful to use {@link #parse(CharSequence, TemporalQuery)}.\n     * The result of this method is {@code TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     * \u003cp\u003e\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    public TemporalAccessor parse(CharSequence text) {\n        Objects.requireNonNull(text, \"text\");\n        try {\n            return parseResolved0(text, null);\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    /**\n     * Parses the text using this formatter, providing control over the text position.\n     * \u003cp\u003e\n     * This parses the text without requiring the parse to start from the beginning\n     * of the string or finish at the end.\n     * The result of this method is {@code TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     * \u003cp\u003e\n     * The text will be parsed from the specified start {@code ParsePosition}.\n     * The entire length of the text does not have to be parsed, the {@code ParsePosition}\n     * will be updated with the index at the end of parsing.\n     * \u003cp\u003e\n     * The operation of this method is slightly different to similar methods using\n     * {@code ParsePosition} on {@code java.text.Format}. That class will return\n     * errors using the error index on the {@code ParsePosition}. By contrast, this\n     * method will throw a {@link DateTimeParseException} if an error occurs, with\n     * the exception containing the error index.\n     * This change in behavior is necessary due to the increased complexity of\n     * parsing and resolving dates/times in this API.\n     * \u003cp\u003e\n     * If the formatter parses the same field more than once with different values,\n     * the result will be an error.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, not null\n     * @return the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    public TemporalAccessor parse(CharSequence text, ParsePosition position) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(position, \"position\");\n        try {\n            return parseResolved0(text, position);\n        } catch (DateTimeParseException | IndexOutOfBoundsException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Fully parses the text producing an object of the specified type.\n     * \u003cp\u003e\n     * Most applications should use this method for parsing.\n     * It parses the entire text to produce the required date-time.\n     * The query is typically a method reference to a {@code from(TemporalAccessor)} method.\n     * For example:\n     * \u003cpre\u003e\n     *  LocalDateTime dt \u003d parser.parse(str, LocalDateTime::from);\n     * \u003c/pre\u003e\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param \u003cT\u003e the type of the parsed date-time\n     * @param text  the text to parse, not null\n     * @param query  the query defining the type to parse to, not null\n     * @return the parsed date-time, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    public \u003cT\u003e T parse(CharSequence text, TemporalQuery\u003cT\u003e query) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(query, \"query\");\n        try {\n            return parseResolved0(text, null).query(query);\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    /**\n     * Fully parses the text producing an object of one of the specified types.\n     * \u003cp\u003e\n     * This parse method is convenient for use when the parser can handle optional elements.\n     * For example, a pattern of \u0027uuuu-MM-dd HH.mm[ VV]\u0027 can be fully parsed to a {@code ZonedDateTime},\n     * or partially parsed to a {@code LocalDateTime}.\n     * The queries must be specified in order, starting from the best matching full-parse option\n     * and ending with the worst matching minimal parse option.\n     * The query is typically a method reference to a {@code from(TemporalAccessor)} method.\n     * \u003cp\u003e\n     * The result is associated with the first type that successfully parses.\n     * Normally, applications will use {@code instanceof} to check the result.\n     * For example:\n     * \u003cpre\u003e\n     *  TemporalAccessor dt \u003d parser.parseBest(str, ZonedDateTime::from, LocalDateTime::from);\n     *  if (dt instanceof ZonedDateTime) {\n     *   ...\n     *  } else {\n     *   ...\n     *  }\n     * \u003c/pre\u003e\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param text  the text to parse, not null\n     * @param queries  the queries defining the types to attempt to parse to,\n     *  must implement {@code TemporalAccessor}, not null\n     * @return the parsed date-time, not null\n     * @throws IllegalArgumentException if less than 2 types are specified\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    public TemporalAccessor parseBest(CharSequence text, TemporalQuery\u003c?\u003e... queries) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(queries, \"queries\");\n        if (queries.length \u003c 2) {\n            throw new IllegalArgumentException(\"At least two queries must be specified\");\n        }\n        try {\n            TemporalAccessor resolved \u003d parseResolved0(text, null);\n            for (TemporalQuery\u003c?\u003e query : queries) {\n                try {\n                    return (TemporalAccessor) resolved.query(query);\n                } catch (RuntimeException ex) {\n                    // continue\n                }\n            }\n            throw new DateTimeException(\"Unable to convert parsed text using any of the specified queries\");\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    private DateTimeParseException createError(CharSequence text, RuntimeException ex) {\n        String abbr;\n        if (text.length() \u003e 64) {\n            abbr \u003d text.subSequence(0, 64).toString() + \"...\";\n        } else {\n            abbr \u003d text.toString();\n        }\n        return new DateTimeParseException(\"Text \u0027\" + abbr + \"\u0027 could not be parsed: \" + ex.getMessage(), text, 0, ex);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses and resolves the specified text.\n     * \u003cp\u003e\n     * This parses to a {@code TemporalAccessor} ensuring that the text is fully parsed.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, null if parsing whole string\n     * @return the resolved result of the parse, not null\n     * @throws DateTimeParseException if the parse fails\n     * @throws DateTimeException if an error occurs while resolving the date or time\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    private TemporalAccessor parseResolved0(final CharSequence text, final ParsePosition position) {\n        ParsePosition pos \u003d (position !\u003d null ? position : new ParsePosition(0));\n        DateTimeParseContext context \u003d parseUnresolved0(text, pos);\n        if (context \u003d\u003d null || pos.getErrorIndex() \u003e\u003d 0 || (position \u003d\u003d null \u0026\u0026 pos.getIndex() \u003c text.length())) {\n            String abbr;\n            if (text.length() \u003e 64) {\n                abbr \u003d text.subSequence(0, 64).toString() + \"...\";\n            } else {\n                abbr \u003d text.toString();\n            }\n            if (pos.getErrorIndex() \u003e\u003d 0) {\n                throw new DateTimeParseException(\"Text \u0027\" + abbr + \"\u0027 could not be parsed at index \" +\n                        pos.getErrorIndex(), text, pos.getErrorIndex());\n            } else {\n                throw new DateTimeParseException(\"Text \u0027\" + abbr + \"\u0027 could not be parsed, unparsed text found at index \" +\n                        pos.getIndex(), text, pos.getIndex());\n            }\n        }\n        return context.toResolved(resolverStyle, resolverFields);\n    }\n\n    /**\n     * Parses the text using this formatter, without resolving the result, intended\n     * for advanced use cases.\n     * \u003cp\u003e\n     * Parsing is implemented as a two-phase operation.\n     * First, the text is parsed using the layout defined by the formatter, producing\n     * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.\n     * Second, the parsed data is \u003cem\u003eresolved\u003c/em\u003e, by validating, combining and\n     * simplifying the various fields into more useful ones.\n     * This method performs the parsing stage but not the resolving stage.\n     * \u003cp\u003e\n     * The result of this method is {@code TemporalAccessor} which represents the\n     * data as seen in the input. Values are not validated, thus parsing a date string\n     * of \u00272012-00-65\u0027 would result in a temporal with three fields - year of \u00272012\u0027,\n     * month of \u00270\u0027 and day-of-month of \u002765\u0027.\n     * \u003cp\u003e\n     * The text will be parsed from the specified start {@code ParsePosition}.\n     * The entire length of the text does not have to be parsed, the {@code ParsePosition}\n     * will be updated with the index at the end of parsing.\n     * \u003cp\u003e\n     * Errors are returned using the error index field of the {@code ParsePosition}\n     * instead of {@code DateTimeParseException}.\n     * The returned error index will be set to an index indicative of the error.\n     * Callers must check for errors before using the result.\n     * \u003cp\u003e\n     * If the formatter parses the same field more than once with different values,\n     * the result will be an error.\n     * \u003cp\u003e\n     * This method is intended for advanced use cases that need access to the\n     * internal state during parsing. Typical application code should use\n     * {@link #parse(CharSequence, TemporalQuery)} or the parse method on the target type.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, not null\n     * @return the parsed text, null if the parse results in an error\n     * @throws DateTimeException if some problem occurs during parsing\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    public TemporalAccessor parseUnresolved(CharSequence text, ParsePosition position) {\n        DateTimeParseContext context \u003d parseUnresolved0(text, position);\n        if (context \u003d\u003d null) {\n            return null;\n        }\n        return context.toUnresolved();\n    }\n\n    private DateTimeParseContext parseUnresolved0(CharSequence text, ParsePosition position) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(position, \"position\");\n        DateTimeParseContext context \u003d new DateTimeParseContext(this);\n        int pos \u003d position.getIndex();\n        pos \u003d printerParser.parse(context, text, pos);\n        if (pos \u003c 0) {\n            position.setErrorIndex(~pos);  // index not updated from input\n            return null;\n        }\n        position.setIndex(pos);  // errorIndex not updated from input\n        return context;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the formatter as a composite printer parser.\n     *\n     * @param optional  whether the printer/parser should be optional\n     * @return the printer/parser, not null\n     */\n    CompositePrinterParser toPrinterParser(boolean optional) {\n        return printerParser.withOptional(optional);\n    }\n\n    /**\n     * Returns this formatter as a {@code java.text.Format} instance.\n     * \u003cp\u003e\n     * The returned {@link Format} instance will format any {@link TemporalAccessor}\n     * and parses to a resolved {@link TemporalAccessor}.\n     * \u003cp\u003e\n     * Exceptions will follow the definitions of {@code Format}, see those methods\n     * for details about {@code IllegalArgumentException} during formatting and\n     * {@code ParseException} or null during parsing.\n     * The format does not support attributing of the returned format string.\n     *\n     * @return this formatter as a classic format instance, not null\n     */\n    public Format toFormat() {\n        return new ClassicFormat(this, null);\n    }\n\n    /**\n     * Returns this formatter as a {@code java.text.Format} instance that will\n     * parse using the specified query.\n     * \u003cp\u003e\n     * The returned {@link Format} instance will format any {@link TemporalAccessor}\n     * and parses to the type specified.\n     * The type must be one that is supported by {@link #parse}.\n     * \u003cp\u003e\n     * Exceptions will follow the definitions of {@code Format}, see those methods\n     * for details about {@code IllegalArgumentException} during formatting and\n     * {@code ParseException} or null during parsing.\n     * The format does not support attributing of the returned format string.\n     *\n     * @param parseQuery  the query defining the type to parse to, not null\n     * @return this formatter as a classic format instance, not null\n     */\n    public Format toFormat(TemporalQuery\u003c?\u003e parseQuery) {\n        Objects.requireNonNull(parseQuery, \"parseQuery\");\n        return new ClassicFormat(this, parseQuery);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a description of the underlying formatters.\n     *\n     * @return a description of this formatter, not null\n     */\n    @Override\n    public String toString() {\n        String pattern \u003d printerParser.toString();\n        pattern \u003d pattern.startsWith(\"[\") ? pattern : pattern.substring(1, pattern.length() - 1);\n        return pattern;\n        // TODO: Fix tests to not depend on toString()\n//        return \"DateTimeFormatter[\" + locale +\n//                (chrono !\u003d null ? \",\" + chrono : \"\") +\n//                (zone !\u003d null ? \",\" + zone : \"\") +\n//                pattern + \"]\";\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements the classic Java Format API.\n     * @serial exclude\n     */\n    @SuppressWarnings(\"serial\")  // not actually serializable\n    static class ClassicFormat extends Format {\n        /** The formatter. */\n        private final DateTimeFormatter formatter;\n        /** The type to be parsed. */\n        private final TemporalQuery\u003c?\u003e parseType;\n        /** Constructor. */\n        public ClassicFormat(DateTimeFormatter formatter, TemporalQuery\u003c?\u003e parseType) {\n            this.formatter \u003d formatter;\n            this.parseType \u003d parseType;\n        }\n\n        @Override\n        public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n            Objects.requireNonNull(obj, \"obj\");\n            Objects.requireNonNull(toAppendTo, \"toAppendTo\");\n            Objects.requireNonNull(pos, \"pos\");\n            if (obj instanceof TemporalAccessor \u003d\u003d false) {\n                throw new IllegalArgumentException(\"Format target must implement TemporalAccessor\");\n            }\n            pos.setBeginIndex(0);\n            pos.setEndIndex(0);\n            try {\n                formatter.formatTo((TemporalAccessor) obj, toAppendTo);\n            } catch (RuntimeException ex) {\n                throw new IllegalArgumentException(ex.getMessage(), ex);\n            }\n            return toAppendTo;\n        }\n        @Override\n        public Object parseObject(String text) throws ParseException {\n            Objects.requireNonNull(text, \"text\");\n            try {\n                if (parseType \u003d\u003d null) {\n                    return formatter.parseResolved0(text, null);\n                }\n                return formatter.parse(text, parseType);\n            } catch (DateTimeParseException ex) {\n                throw new ParseException(ex.getMessage(), ex.getErrorIndex());\n            } catch (RuntimeException ex) {\n                throw (ParseException) new ParseException(ex.getMessage(), 0).initCause(ex);\n            }\n        }\n        @Override\n        public Object parseObject(String text, ParsePosition pos) {\n            Objects.requireNonNull(text, \"text\");\n            DateTimeParseContext context;\n            try {\n                context \u003d formatter.parseUnresolved0(text, pos);\n            } catch (IndexOutOfBoundsException ex) {\n                if (pos.getErrorIndex() \u003c 0) {\n                    pos.setErrorIndex(0);\n                }\n                return null;\n            }\n            if (context \u003d\u003d null) {\n                if (pos.getErrorIndex() \u003c 0) {\n                    pos.setErrorIndex(0);\n                }\n                return null;\n            }\n            try {\n                TemporalAccessor resolved \u003d context.toResolved(formatter.resolverStyle, formatter.resolverFields);\n                if (parseType \u003d\u003d null) {\n                    return resolved;\n                }\n                return resolved.query(parseType);\n            } catch (RuntimeException ex) {\n                pos.setErrorIndex(0);\n                return null;\n            }\n        }\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 18, 2024 2:03:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 18, 2024 2:05:45 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4158
oct 18, 2024 2:07:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4499
oct 18, 2024 2:07:18 P. M. scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Proyectos\spark-datos-energia\.metals\.reports\metals-full\2024-10-18\r_compiler-error_(root)_14-07-18-976.md
2024.10.18 14:07:18 WARN  Could not find semantic tokens for: file:///C:/Proyectos/spark-datos-energia/src/main/scala/example/ApiDataIngestion.scala
2024.10.18 14:07:30 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 2:07:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.LocalTime.SECONDS_PER_DAY;\nimport static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH;\nimport static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR;\nimport static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_MONTH;\nimport static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_YEAR;\nimport static java.time.temporal.ChronoField.DAY_OF_MONTH;\nimport static java.time.temporal.ChronoField.DAY_OF_YEAR;\nimport static java.time.temporal.ChronoField.EPOCH_DAY;\nimport static java.time.temporal.ChronoField.ERA;\nimport static java.time.temporal.ChronoField.MONTH_OF_YEAR;\nimport static java.time.temporal.ChronoField.PROLEPTIC_MONTH;\nimport static java.time.temporal.ChronoField.YEAR;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.ChronoLocalDate;\nimport java.time.chrono.IsoEra;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneOffsetTransition;\nimport java.time.zone.ZoneRules;\nimport java.util.Objects;\nimport java.util.stream.LongStream;\nimport java.util.stream.Stream;\n\n/**\n * A date without a time-zone in the ISO-8601 calendar system,\n * such as {@code 2007-12-03}.\n * \u003cp\u003e\n * {@code LocalDate} is an immutable date-time object that represents a date,\n * often viewed as year-month-day. Other date fields, such as day-of-year,\n * day-of-week and week-of-year, can also be accessed.\n * For example, the value \"2nd October 2007\" can be stored in a {@code LocalDate}.\n * \u003cp\u003e\n * This class does not store or represent a time or time-zone.\n * Instead, it is a description of the date, as used for birthdays.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n * \u003cp\u003e\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today\u0027s rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code LocalDate} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class LocalDate\n        implements Temporal, TemporalAdjuster, ChronoLocalDate, Serializable {\n\n    /**\n     * The minimum supported {@code LocalDate}, \u0027-999999999-01-01\u0027.\n     * This could be used by an application as a \"far past\" date.\n     */\n    public static final LocalDate MIN \u003d LocalDate.of(Year.MIN_VALUE, 1, 1);\n    /**\n     * The maximum supported {@code LocalDate}, \u0027+999999999-12-31\u0027.\n     * This could be used by an application as a \"far future\" date.\n     */\n    public static final LocalDate MAX \u003d LocalDate.of(Year.MAX_VALUE, 12, 31);\n    /**\n     * The epoch year {@code LocalDate}, \u00271970-01-01\u0027.\n     */\n    public static final LocalDate EPOCH \u003d LocalDate.of(1970, 1, 1);\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 2942565459149668126L;\n    /**\n     * The number of days in a 400 year cycle.\n     */\n    private static final int DAYS_PER_CYCLE \u003d 146097;\n    /**\n     * The number of days from year zero to year 1970.\n     * There are five 400 year cycles from year zero to 2000.\n     * There are 7 leap years from 1970 to 2000.\n     */\n    static final long DAYS_0000_TO_1970 \u003d (DAYS_PER_CYCLE * 5L) - (30L * 365L + 7L);\n\n    /**\n     * The year.\n     */\n    private final int year;\n    /**\n     * The month-of-year.\n     */\n    private final short month;\n    /**\n     * The day-of-month.\n     */\n    private final short day;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date using the system clock and default time-zone, not null\n     */\n    public static LocalDate now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date using the system clock, not null\n     */\n    public static LocalDate now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date - today.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date, not null\n     */\n    public static LocalDate now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        return ofInstant(now, clock.getZone());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a year, month and day.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDate of(int year, Month month, int dayOfMonth) {\n        YEAR.checkValidValue(year);\n        Objects.requireNonNull(month, \"month\");\n        DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        return create(year, month.getValue(), dayOfMonth);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDate} from a year, month and day.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDate of(int year, int month, int dayOfMonth) {\n        YEAR.checkValidValue(year);\n        MONTH_OF_YEAR.checkValidValue(month);\n        DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        return create(year, month, dayOfMonth);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a year and day-of-year.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year and day-of-year.\n     * The day-of-year must be valid for the year, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param dayOfYear  the day-of-year to represent, from 1 to 366\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-year is invalid for the year\n     */\n    public static LocalDate ofYearDay(int year, int dayOfYear) {\n        YEAR.checkValidValue(year);\n        DAY_OF_YEAR.checkValidValue(dayOfYear);\n        boolean leap \u003d IsoChronology.INSTANCE.isLeapYear(year);\n        if (dayOfYear \u003d\u003d 366 \u0026\u0026 leap \u003d\u003d false) {\n            throw new DateTimeException(\"Invalid date \u0027DayOfYear 366\u0027 as \u0027\" + year + \"\u0027 is not a leap year\");\n        }\n        Month moy \u003d Month.of((dayOfYear - 1) / 31 + 1);\n        int monthEnd \u003d moy.firstDayOfYear(leap) + moy.length(leap) - 1;\n        if (dayOfYear \u003e monthEnd) {\n            moy \u003d moy.plus(1);\n        }\n        int dom \u003d dayOfYear - moy.firstDayOfYear(leap) + 1;\n        return new LocalDate(year, moy.getValue(), dom);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates a local date based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date.\n     *\n     * @param instant  the instant to create the date from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the local date, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     * @since 9\n     */\n    public static LocalDate ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        long localSecond \u003d instant.getEpochSecond() + offset.getTotalSeconds();\n        long localEpochDay \u003d Math.floorDiv(localSecond, SECONDS_PER_DAY);\n        return ofEpochDay(localEpochDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from the epoch day count.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified epoch-day.\n     * The {@link ChronoField#EPOCH_DAY EPOCH_DAY} is a simple incrementing count\n     * of days where day 0 is 1970-01-01. Negative numbers represent earlier days.\n     *\n     * @param epochDay  the Epoch Day to convert, based on the epoch 1970-01-01\n     * @return the local date, not null\n     * @throws DateTimeException if the epoch day exceeds the supported date range\n     */\n    public static LocalDate ofEpochDay(long epochDay) {\n        EPOCH_DAY.checkValidValue(epochDay);\n        long zeroDay \u003d epochDay + DAYS_0000_TO_1970;\n        // find the march-based year\n        zeroDay -\u003d 60;  // adjust to 0000-03-01 so leap day is at end of four year cycle\n        long adjust \u003d 0;\n        if (zeroDay \u003c 0) {\n            // adjust negative years to positive for calculation\n            long adjustCycles \u003d (zeroDay + 1) / DAYS_PER_CYCLE - 1;\n            adjust \u003d adjustCycles * 400;\n            zeroDay +\u003d -adjustCycles * DAYS_PER_CYCLE;\n        }\n        long yearEst \u003d (400 * zeroDay + 591) / DAYS_PER_CYCLE;\n        long doyEst \u003d zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);\n        if (doyEst \u003c 0) {\n            // fix estimate\n            yearEst--;\n            doyEst \u003d zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);\n        }\n        yearEst +\u003d adjust;  // reset any negative year\n        int marchDoy0 \u003d (int) doyEst;\n\n        // convert march-based values back to january-based\n        int marchMonth0 \u003d (marchDoy0 * 5 + 2) / 153;\n        int month \u003d (marchMonth0 + 2) % 12 + 1;\n        int dom \u003d marchDoy0 - (marchMonth0 * 306 + 5) / 10 + 1;\n        yearEst +\u003d marchMonth0 / 10;\n\n        // check year now we are certain it is correct\n        int year \u003d YEAR.checkValidIntValue(yearEst);\n        return new LocalDate(year, month, dom);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a temporal object.\n     * \u003cp\u003e\n     * This obtains a local date based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code LocalDate}.\n     * \u003cp\u003e\n     * The conversion uses the {@link TemporalQueries#localDate()} query, which relies\n     * on extracting the {@link ChronoField#EPOCH_DAY EPOCH_DAY} field.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code LocalDate::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the local date, not null\n     * @throws DateTimeException if unable to convert to a {@code LocalDate}\n     */\n    public static LocalDate from(TemporalAccessor temporal) {\n        Objects.requireNonNull(temporal, \"temporal\");\n        LocalDate date \u003d temporal.query(TemporalQueries.localDate());\n        if (date \u003d\u003d null) {\n            throw new DateTimeException(\"Unable to obtain LocalDate from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName());\n        }\n        return date;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a text string such as {@code 2007-12-03}.\n     * \u003cp\u003e\n     * The string must represent a valid date and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_DATE}.\n     *\n     * @param text  the text to parse such as \"2007-12-03\", not null\n     * @return the parsed local date, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDate parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_LOCAL_DATE);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDate} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed local date, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDate parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, LocalDate::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a local date from the year, month and day fields.\n     *\n     * @param year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 to 12, validated\n     * @param dayOfMonth  the day-of-month to represent, validated from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the day-of-month is invalid for the month-year\n     */\n    private static LocalDate create(int year, int month, int dayOfMonth) {\n        if (dayOfMonth \u003e 28) {\n            int dom \u003d 31;\n            switch (month) {\n                case 2:\n                    dom \u003d (IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n                    break;\n                case 4:\n                case 6:\n                case 9:\n                case 11:\n                    dom \u003d 30;\n                    break;\n            }\n            if (dayOfMonth \u003e dom) {\n                if (dayOfMonth \u003d\u003d 29) {\n                    throw new DateTimeException(\"Invalid date \u0027February 29\u0027 as \u0027\" + year + \"\u0027 is not a leap year\");\n                } else {\n                    throw new DateTimeException(\"Invalid date \u0027\" + Month.of(month).name() + \" \" + dayOfMonth + \"\u0027\");\n                }\n            }\n        }\n        return new LocalDate(year, month, dayOfMonth);\n    }\n\n    /**\n     * Resolves the date, resolving days past the end of month.\n     *\n     * @param year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, validated from 1 to 12\n     * @param day  the day-of-month to represent, validated from 1 to 31\n     * @return the resolved date, not null\n     */\n    private static LocalDate resolvePreviousValid(int year, int month, int day) {\n        switch (month) {\n            case 2:\n                day \u003d Math.min(day, IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n                break;\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                day \u003d Math.min(day, 30);\n                break;\n        }\n        return new LocalDate(year, month, day);\n    }\n\n    /**\n     * Constructor, previously validated.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, valid for year-month, from 1 to 31\n     */\n    private LocalDate(int year, int month, int dayOfMonth) {\n        this.year \u003d year;\n        this.month \u003d (short) month;\n        this.day \u003d (short) dayOfMonth;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalField field) {\n        return ChronoLocalDate.super.isSupported(field);\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        return ChronoLocalDate.super.isSupported(unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            if (f.isDateBased()) {\n                switch (f) {\n                    case DAY_OF_MONTH: return ValueRange.of(1, lengthOfMonth());\n                    case DAY_OF_YEAR: return ValueRange.of(1, lengthOfYear());\n                    case ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, getMonth() \u003d\u003d Month.FEBRUARY \u0026\u0026 isLeapYear() \u003d\u003d false ? 4 : 5);\n                    case YEAR_OF_ERA:\n                        return (getYear() \u003c\u003d 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n                }\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date, except {@code EPOCH_DAY} and {@code PROLEPTIC_MONTH}\n     * which are too large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc and performance\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            return get0(field);\n        }\n        return ChronoLocalDate.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            if (field \u003d\u003d EPOCH_DAY) {\n                return toEpochDay();\n            }\n            if (field \u003d\u003d PROLEPTIC_MONTH) {\n                return getProlepticMonth();\n            }\n            return get0(field);\n        }\n        return field.getFrom(this);\n    }\n\n    private int get0(TemporalField field) {\n        switch ((ChronoField) field) {\n            case DAY_OF_WEEK: return getDayOfWeek().getValue();\n            case ALIGNED_DAY_OF_WEEK_IN_MONTH: return ((day - 1) % 7) + 1;\n            case ALIGNED_DAY_OF_WEEK_IN_YEAR: return ((getDayOfYear() - 1) % 7) + 1;\n            case DAY_OF_MONTH: return day;\n            case DAY_OF_YEAR: return getDayOfYear();\n            case EPOCH_DAY: throw new UnsupportedTemporalTypeException(\"Invalid field \u0027EpochDay\u0027 for get() method, use getLong() instead\");\n            case ALIGNED_WEEK_OF_MONTH: return ((day - 1) / 7) + 1;\n            case ALIGNED_WEEK_OF_YEAR: return ((getDayOfYear() - 1) / 7) + 1;\n            case MONTH_OF_YEAR: return month;\n            case PROLEPTIC_MONTH: throw new UnsupportedTemporalTypeException(\"Invalid field \u0027ProlepticMonth\u0027 for get() method, use getLong() instead\");\n            case YEAR_OF_ERA: return (year \u003e\u003d 1 ? year : 1 - year);\n            case YEAR: return year;\n            case ERA: return (year \u003e\u003d 1 ? 1 : 0);\n        }\n        throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n    }\n\n    private long getProlepticMonth() {\n        return (year * 12L + month - 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology of this date, which is the ISO calendar system.\n     * \u003cp\u003e\n     * The {@code Chronology} represents the calendar system in use.\n     * The ISO-8601 calendar system is the modern civil calendar system used today\n     * in most of the world. It is equivalent to the proleptic Gregorian calendar\n     * system, in which today\u0027s rules for leap years are applied for all time.\n     *\n     * @return the ISO chronology, not null\n     */\n    @Override\n    public IsoChronology getChronology() {\n        return IsoChronology.INSTANCE;\n    }\n\n    /**\n     * Gets the era applicable at this date.\n     * \u003cp\u003e\n     * The official ISO-8601 standard does not define eras, however {@code IsoChronology} does.\n     * It defines two eras, \u0027CE\u0027 from year one onwards and \u0027BCE\u0027 from year zero backwards.\n     * Since dates before the Julian-Gregorian cutover are not in line with history,\n     * the cutover between \u0027BCE\u0027 and \u0027CE\u0027 is also not aligned with the commonly used\n     * eras, often referred to using \u0027BC\u0027 and \u0027AD\u0027.\n     * \u003cp\u003e\n     * Users of this class should typically ignore this method as it exists primarily\n     * to fulfill the {@link ChronoLocalDate} contract where it is necessary to support\n     * the Japanese calendar system.\n     *\n     * @return the IsoEra applicable at this date, not null\n     */\n    @Override // override for Javadoc\n    public IsoEra getEra() {\n        return (getYear() \u003e\u003d 1 ? IsoEra.CE : IsoEra.BCE);\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return year;\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return month;\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return Month.of(month);\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return day;\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return getMonth().firstDayOfYear(isLeapYear()) + day - 1;\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        int dow0 \u003d Math.floorMod(toEpochDay() + 3, 7);\n        return DayOfWeek.of(dow0 + 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     * \u003cp\u003e\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     * \u003cp\u003e\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     * \u003cp\u003e\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return true if the year is leap, false otherwise\n     */\n    @Override // override for Javadoc and performance\n    public boolean isLeapYear() {\n        return IsoChronology.INSTANCE.isLeapYear(year);\n    }\n\n    /**\n     * Returns the length of the month represented by this date.\n     * \u003cp\u003e\n     * This returns the length of the month in days.\n     * For example, a date in January would return 31.\n     *\n     * @return the length of the month in days\n     */\n    @Override\n    public int lengthOfMonth() {\n        switch (month) {\n            case 2:\n                return (isLeapYear() ? 29 : 28);\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Returns the length of the year represented by this date.\n     * \u003cp\u003e\n     * This returns the length of the year in days, either 365 or 366.\n     *\n     * @return 366 if the year is leap, 365 otherwise\n     */\n    @Override // override for Javadoc and performance\n    public int lengthOfYear() {\n        return (isLeapYear() ? 366 : 365);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the date adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * \u003cp\u003e\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d localDate.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return a {@code LocalDate} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return (LocalDate) adjuster;\n        }\n        return (LocalDate) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAY_OF_WEEK} -\n     *  Returns a {@code LocalDate} with the specified day-of-week.\n     *  The date is adjusted up to 6 days forward or backward within the boundary\n     *  of a Monday to Sunday week.\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH} -\n     *  Returns a {@code LocalDate} with the specified aligned-day-of-week.\n     *  The date is adjusted to the specified month-based aligned-day-of-week.\n     *  Aligned weeks are counted such that the first week of a given month starts\n     *  on the first day of that month.\n     *  This may cause the date to be moved up to 6 days into the following month.\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR} -\n     *  Returns a {@code LocalDate} with the specified aligned-day-of-week.\n     *  The date is adjusted to the specified year-based aligned-day-of-week.\n     *  Aligned weeks are counted such that the first week of a given year starts\n     *  on the first day of that year.\n     *  This may cause the date to be moved up to 6 days into the following year.\n     * \u003cli\u003e{@code DAY_OF_MONTH} -\n     *  Returns a {@code LocalDate} with the specified day-of-month.\n     *  The month and year will be unchanged. If the day-of-month is invalid for the\n     *  year and month, then a {@code DateTimeException} is thrown.\n     * \u003cli\u003e{@code DAY_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified day-of-year.\n     *  The year will be unchanged. If the day-of-year is invalid for the\n     *  year, then a {@code DateTimeException} is thrown.\n     * \u003cli\u003e{@code EPOCH_DAY} -\n     *  Returns a {@code LocalDate} with the specified epoch-day.\n     *  This completely replaces the date and is equivalent to {@link #ofEpochDay(long)}.\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH} -\n     *  Returns a {@code LocalDate} with the specified aligned-week-of-month.\n     *  Aligned weeks are counted such that the first week of a given month starts\n     *  on the first day of that month.\n     *  This adjustment moves the date in whole week chunks to match the specified week.\n     *  The result will have the same day-of-week as this date.\n     *  This may cause the date to be moved into the following month.\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified aligned-week-of-year.\n     *  Aligned weeks are counted such that the first week of a given year starts\n     *  on the first day of that year.\n     *  This adjustment moves the date in whole week chunks to match the specified week.\n     *  The result will have the same day-of-week as this date.\n     *  This may cause the date to be moved into the following year.\n     * \u003cli\u003e{@code MONTH_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified month-of-year.\n     *  The year will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code PROLEPTIC_MONTH} -\n     *  Returns a {@code LocalDate} with the specified proleptic-month.\n     *  The day-of-month will be unchanged, unless it would be invalid for the new month\n     *  and year. In that case, the day-of-month is adjusted to the maximum valid value\n     *  for the new month and year.\n     * \u003cli\u003e{@code YEAR_OF_ERA} -\n     *  Returns a {@code LocalDate} with the specified year-of-era.\n     *  The era and month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code YEAR} -\n     *  Returns a {@code LocalDate} with the specified year.\n     *  The month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code ERA} -\n     *  Returns a {@code LocalDate} with the specified era.\n     *  The year-of-era and month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return a {@code LocalDate} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            f.checkValidValue(newValue);\n            switch (f) {\n                case DAY_OF_WEEK: return plusDays(newValue - getDayOfWeek().getValue());\n                case ALIGNED_DAY_OF_WEEK_IN_MONTH: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n                case ALIGNED_DAY_OF_WEEK_IN_YEAR: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                case DAY_OF_MONTH: return withDayOfMonth((int) newValue);\n                case DAY_OF_YEAR: return withDayOfYear((int) newValue);\n                case EPOCH_DAY: return LocalDate.ofEpochDay(newValue);\n                case ALIGNED_WEEK_OF_MONTH: return plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_MONTH));\n                case ALIGNED_WEEK_OF_YEAR: return plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_YEAR));\n                case MONTH_OF_YEAR: return withMonth((int) newValue);\n                case PROLEPTIC_MONTH: return plusMonths(newValue - getProlepticMonth());\n                case YEAR_OF_ERA: return withYear((int) (year \u003e\u003d 1 ? newValue : 1 - newValue));\n                case YEAR: return withYear((int) newValue);\n                case ERA: return (getLong(ERA) \u003d\u003d newValue ? this : withYear(1 - year));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the year altered.\n     * \u003cp\u003e\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return a {@code LocalDate} based on this date with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public LocalDate withYear(int year) {\n        if (this.year \u003d\u003d year) {\n            return this;\n        }\n        YEAR.checkValidValue(year);\n        return resolvePreviousValid(year, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the month-of-year altered.\n     * \u003cp\u003e\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return a {@code LocalDate} based on this date with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public LocalDate withMonth(int month) {\n        if (this.month \u003d\u003d month) {\n            return this;\n        }\n        MONTH_OF_YEAR.checkValidValue(month);\n        return resolvePreviousValid(year, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting date is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return a {@code LocalDate} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public LocalDate withDayOfMonth(int dayOfMonth) {\n        if (this.day \u003d\u003d dayOfMonth) {\n            return this;\n        }\n        return of(year, month, dayOfMonth);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the day-of-year altered.\n     * \u003cp\u003e\n     * If the resulting date is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return a {@code LocalDate} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public LocalDate withDayOfYear(int dayOfYear) {\n        if (this.getDayOfYear() \u003d\u003d dayOfYear) {\n            return this;\n        }\n        return ofYearDay(year, dayOfYear);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return a {@code LocalDate} based on this date with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate plus(TemporalAmount amountToAdd) {\n        if (amountToAdd instanceof Period) {\n            Period periodToAdd \u003d (Period) amountToAdd;\n            return plusMonths(periodToAdd.toTotalMonths()).plusDays(periodToAdd.getDays());\n        }\n        Objects.requireNonNull(amountToAdd, \"amountToAdd\");\n        return (LocalDate) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, adding the amount can cause the resulting date to become invalid.\n     * For example, adding one month to 31st January would result in 31st February.\n     * In cases like this, the unit is responsible for resolving the date.\n     * Typically it will choose the previous valid date, which would be the last valid\n     * day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented here.\n     * The supported fields behave as follows:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAYS} -\n     *  Returns a {@code LocalDate} with the specified number of days added.\n     *  This is equivalent to {@link #plusDays(long)}.\n     * \u003cli\u003e{@code WEEKS} -\n     *  Returns a {@code LocalDate} with the specified number of weeks added.\n     *  This is equivalent to {@link #plusWeeks(long)} and uses a 7 day week.\n     * \u003cli\u003e{@code MONTHS} -\n     *  Returns a {@code LocalDate} with the specified number of months added.\n     *  This is equivalent to {@link #plusMonths(long)}.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code YEARS} -\n     *  Returns a {@code LocalDate} with the specified number of years added.\n     *  This is equivalent to {@link #plusYears(long)}.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code DECADES} -\n     *  Returns a {@code LocalDate} with the specified number of decades added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 10.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code CENTURIES} -\n     *  Returns a {@code LocalDate} with the specified number of centuries added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 100.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code MILLENNIA} -\n     *  Returns a {@code LocalDate} with the specified number of millennia added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 1,000.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code ERAS} -\n     *  Returns a {@code LocalDate} with the specified number of eras added.\n     *  Only two eras are supported so the amount must be one, zero or minus one.\n     *  If the amount is non-zero then the year is changed such that the year-of-era\n     *  is unchanged.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * All other {@code ChronoUnit} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return a {@code LocalDate} based on this date with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            ChronoUnit f \u003d (ChronoUnit) unit;\n            switch (f) {\n                case DAYS: return plusDays(amountToAdd);\n                case WEEKS: return plusWeeks(amountToAdd);\n                case MONTHS: return plusMonths(amountToAdd);\n                case YEARS: return plusYears(amountToAdd);\n                case DECADES: return plusYears(Math.multiplyExact(amountToAdd, 10));\n                case CENTURIES: return plusYears(Math.multiplyExact(amountToAdd, 100));\n                case MILLENNIA: return plusYears(Math.multiplyExact(amountToAdd, 1000));\n                case ERAS: return with(ERA, Math.addExact(getLong(ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param yearsToAdd  the years to add, may be negative\n     * @return a {@code LocalDate} based on this date with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusYears(long yearsToAdd) {\n        if (yearsToAdd \u003d\u003d 0) {\n            return this;\n        }\n        int newYear \u003d YEAR.checkValidIntValue(year + yearsToAdd);  // safe overflow\n        return resolvePreviousValid(newYear, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param monthsToAdd  the months to add, may be negative\n     * @return a {@code LocalDate} based on this date with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusMonths(long monthsToAdd) {\n        if (monthsToAdd \u003d\u003d 0) {\n            return this;\n        }\n        long monthCount \u003d year * 12L + (month - 1);\n        long calcMonths \u003d monthCount + monthsToAdd;  // safe overflow\n        int newYear \u003d YEAR.checkValidIntValue(Math.floorDiv(calcMonths, 12));\n        int newMonth \u003d Math.floorMod(calcMonths, 12) + 1;\n        return resolvePreviousValid(newYear, newMonth, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeksToAdd  the weeks to add, may be negative\n     * @return a {@code LocalDate} based on this date with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusWeeks(long weeksToAdd) {\n        return plusDays(Math.multiplyExact(weeksToAdd, 7));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param daysToAdd  the days to add, may be negative\n     * @return a {@code LocalDate} based on this date with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusDays(long daysToAdd) {\n        if (daysToAdd \u003d\u003d 0) {\n            return this;\n        }\n        long dom \u003d day + daysToAdd;\n        if (dom \u003e 0) {\n            if (dom \u003c\u003d 28) {\n                return new LocalDate(year, month, (int) dom);\n            } else if (dom \u003c\u003d 59) { // 59th Jan is 28th Feb, 59th Feb is 31st Mar\n                long monthLen \u003d lengthOfMonth();\n                if (dom \u003c\u003d monthLen) {\n                    return new LocalDate(year, month, (int) dom);\n                } else if (month \u003c 12) {\n                    return new LocalDate(year, month + 1, (int) (dom - monthLen));\n                } else {\n                    YEAR.checkValidValue(year + 1);\n                    return new LocalDate(year + 1, 1, (int) (dom - monthLen));\n                }\n            }\n        }\n\n        long mjDay \u003d Math.addExact(toEpochDay(), daysToAdd);\n        return LocalDate.ofEpochDay(mjDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return a {@code LocalDate} based on this date with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate minus(TemporalAmount amountToSubtract) {\n        if (amountToSubtract instanceof Period) {\n            Period periodToSubtract \u003d (Period) amountToSubtract;\n            return minusMonths(periodToSubtract.toTotalMonths()).minusDays(periodToSubtract.getDays());\n        }\n        Objects.requireNonNull(amountToSubtract, \"amountToSubtract\");\n        return (LocalDate) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return a {@code LocalDate} based on this date with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param yearsToSubtract  the years to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusYears(long yearsToSubtract) {\n        return (yearsToSubtract \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-yearsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param monthsToSubtract  the months to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusMonths(long monthsToSubtract) {\n        return (monthsToSubtract \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-monthsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeksToSubtract  the weeks to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusWeeks(long weeksToSubtract) {\n        return (weeksToSubtract \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeksToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param daysToSubtract  the days to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusDays(long daysToSubtract) {\n        return (daysToSubtract \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-daysToSubtract));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date using the specified query.\n     * \u003cp\u003e\n     * This queries this date using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) this;\n        }\n        return ChronoLocalDate.super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the date changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * passing {@link ChronoField#EPOCH_DAY} as the field.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisLocalDate.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisLocalDate);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc\n    public Temporal adjustInto(Temporal temporal) {\n        return ChronoLocalDate.super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the amount of time until another date in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code LocalDate}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code LocalDate} using {@link #from(TemporalAccessor)}.\n     * For example, the amount in days between two dates can be calculated\n     * using {@code startDate.until(endDate, DAYS)}.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two dates.\n     * For example, the amount in months between 2012-06-15 and 2012-08-14\n     * will only be one month as it is one day short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code DAYS}, {@code WEEKS}, {@code MONTHS}, {@code YEARS},\n     * {@code DECADES}, {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS}\n     * are supported. Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to a {@code LocalDate}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date and the end date\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to a {@code LocalDate}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        LocalDate end \u003d LocalDate.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch ((ChronoUnit) unit) {\n                case DAYS: return daysUntil(end);\n                case WEEKS: return daysUntil(end) / 7;\n                case MONTHS: return monthsUntil(end);\n                case YEARS: return monthsUntil(end) / 12;\n                case DECADES: return monthsUntil(end) / 120;\n                case CENTURIES: return monthsUntil(end) / 1200;\n                case MILLENNIA: return monthsUntil(end) / 12000;\n                case ERAS: return end.getLong(ERA) - getLong(ERA);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    long daysUntil(LocalDate end) {\n        return end.toEpochDay() - toEpochDay();  // no overflow\n    }\n\n    private long monthsUntil(LocalDate end) {\n        long packed1 \u003d getProlepticMonth() * 32L + getDayOfMonth();  // no overflow\n        long packed2 \u003d end.getProlepticMonth() * 32L + end.getDayOfMonth();  // no overflow\n        return (packed2 - packed1) / 32;\n    }\n\n    /**\n     * Calculates the period between this date and another date as a {@code Period}.\n     * \u003cp\u003e\n     * This calculates the period between two dates in terms of years, months and days.\n     * The start and end points are {@code this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The negative sign will be the same in each of year, month and day.\n     * \u003cp\u003e\n     * The calculation is performed using the ISO calendar system.\n     * If necessary, the input date will be converted to ISO.\n     * \u003cp\u003e\n     * The start date is included, but the end date is not.\n     * The period is calculated by removing complete months, then calculating\n     * the remaining number of days, adjusting to ensure that both have the same sign.\n     * The number of months is then normalized into years and months based on a 12 month year.\n     * A month is considered to be complete if the end day-of-month is greater\n     * than or equal to the start day-of-month.\n     * For example, from {@code 2010-01-15} to {@code 2011-03-18} is \"1 year, 2 months and 3 days\".\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link Period#between(LocalDate, LocalDate)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   period \u003d start.until(end);\n     *   period \u003d Period.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     *\n     * @param endDateExclusive  the end date, exclusive, which may be in any chronology, not null\n     * @return the period between this date and the end date, not null\n     */\n    @Override\n    public Period until(ChronoLocalDate endDateExclusive) {\n        LocalDate end \u003d LocalDate.from(endDateExclusive);\n        long totalMonths \u003d end.getProlepticMonth() - this.getProlepticMonth();  // safe\n        int days \u003d end.day - this.day;\n        if (totalMonths \u003e 0 \u0026\u0026 days \u003c 0) {\n            totalMonths--;\n            LocalDate calcDate \u003d this.plusMonths(totalMonths);\n            days \u003d (int) (end.toEpochDay() - calcDate.toEpochDay());  // safe\n        } else if (totalMonths \u003c 0 \u0026\u0026 days \u003e 0) {\n            totalMonths++;\n            days -\u003d end.lengthOfMonth();\n        }\n        long years \u003d totalMonths / 12;  // safe\n        int months \u003d (int) (totalMonths % 12);  // safe\n        return Period.of(Math.toIntExact(years), months, days);\n    }\n\n    /**\n     * Returns a sequential ordered stream of dates. The returned stream starts from this date\n     * (inclusive) and goes to {@code endExclusive} (exclusive) by an incremental step of 1 day.\n     * \u003cp\u003e\n     * This method is equivalent to {@code datesUntil(endExclusive, Period.ofDays(1))}.\n     *\n     * @param endExclusive  the end date, exclusive, not null\n     * @return a sequential {@code Stream} for the range of {@code LocalDate} values\n     * @throws IllegalArgumentException if end date is before this date\n     * @since 9\n     */\n    public Stream\u003cLocalDate\u003e datesUntil(LocalDate endExclusive) {\n        long end \u003d endExclusive.toEpochDay();\n        long start \u003d toEpochDay();\n        if (end \u003c start) {\n            throw new IllegalArgumentException(endExclusive + \" \u003c \" + this);\n        }\n        return LongStream.range(start, end).mapToObj(LocalDate::ofEpochDay);\n    }\n\n    /**\n     * Returns a sequential ordered stream of dates by given incremental step. The returned stream\n     * starts from this date (inclusive) and goes to {@code endExclusive} (exclusive).\n     * \u003cp\u003e\n     * The n-th date which appears in the stream is equal to {@code this.plus(step.multipliedBy(n))}\n     * (but the result of step multiplication never overflows). For example, if this date is\n     * {@code 2015-01-31}, the end date is {@code 2015-05-01} and the step is 1 month, then the\n     * stream contains {@code 2015-01-31}, {@code 2015-02-28}, {@code 2015-03-31}, and\n     * {@code 2015-04-30}.\n     *\n     * @param endExclusive  the end date, exclusive, not null\n     * @param step  the non-zero, non-negative {@code Period} which represents the step.\n     * @return a sequential {@code Stream} for the range of {@code LocalDate} values\n     * @throws IllegalArgumentException if step is zero, or {@code step.getDays()} and\n     *             {@code step.toTotalMonths()} have opposite sign, or end date is before this date\n     *             and step is positive, or end date is after this date and step is negative\n     * @since 9\n     */\n    public Stream\u003cLocalDate\u003e datesUntil(LocalDate endExclusive, Period step) {\n        if (step.isZero()) {\n            throw new IllegalArgumentException(\"step is zero\");\n        }\n        long end \u003d endExclusive.toEpochDay();\n        long start \u003d toEpochDay();\n        long until \u003d end - start;\n        long months \u003d step.toTotalMonths();\n        long days \u003d step.getDays();\n        if ((months \u003c 0 \u0026\u0026 days \u003e 0) || (months \u003e 0 \u0026\u0026 days \u003c 0)) {\n            throw new IllegalArgumentException(\"period months and days are of opposite sign\");\n        }\n        if (until \u003d\u003d 0) {\n            return Stream.empty();\n        }\n        int sign \u003d months \u003e 0 || days \u003e 0 ? 1 : -1;\n        if (sign \u003c 0 ^ until \u003c 0) {\n            throw new IllegalArgumentException(endExclusive + (sign \u003c 0 ? \" \u003e \" : \" \u003c \") + this);\n        }\n        if (months \u003d\u003d 0) {\n            long steps \u003d (until - sign) / days; // non-negative\n            return LongStream.rangeClosed(0, steps).mapToObj(\n                    n -\u003e LocalDate.ofEpochDay(start + n * days));\n        }\n        // 48699/1600 \u003d 365.2425/12, no overflow, non-negative result\n        long steps \u003d until * 1600 / (months * 48699 + days * 1600) + 1;\n        long addMonths \u003d months * steps;\n        long addDays \u003d days * steps;\n        long maxAddMonths \u003d months \u003e 0 ? MAX.getProlepticMonth() - getProlepticMonth()\n                : getProlepticMonth() - MIN.getProlepticMonth();\n        // adjust steps estimation\n        if (addMonths * sign \u003e maxAddMonths\n                || (plusMonths(addMonths).toEpochDay() + addDays) * sign \u003e\u003d end * sign) {\n            steps--;\n            addMonths -\u003d months;\n            addDays -\u003d days;\n            if (addMonths * sign \u003e maxAddMonths\n                    || (plusMonths(addMonths).toEpochDay() + addDays) * sign \u003e\u003d end * sign) {\n                steps--;\n            }\n        }\n        return LongStream.rangeClosed(0, steps).mapToObj(\n                n -\u003e this.plusMonths(months * n).plusDays(days * n));\n    }\n\n    /**\n     * Formats this date using the specified formatter.\n     * \u003cp\u003e\n     * This date will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    @Override  // override for Javadoc and performance\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param time  the time to combine with, not null\n     * @return the local date-time formed from this date and the specified time, not null\n     */\n    @Override\n    public LocalDateTime atTime(LocalTime time) {\n        return LocalDateTime.of(this, time);\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour and minute.\n     * The seconds and nanosecond fields will be set to zero.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute) {\n        return atTime(LocalTime.of(hour, minute));\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour, minute and second.\n     * The nanosecond field will be set to zero.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute, int second) {\n        return atTime(LocalTime.of(hour, minute, second));\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour, minute, second and nanosecond.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute, int second, int nanoOfSecond) {\n        return atTime(LocalTime.of(hour, minute, second, nanoOfSecond));\n    }\n\n    /**\n     * Combines this date with an offset time to create an {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param time  the time to combine with, not null\n     * @return the offset date-time formed from this date and the specified time, not null\n     */\n    public OffsetDateTime atTime(OffsetTime time) {\n        return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.getOffset());\n    }\n\n    /**\n     * Combines this date with the time of midnight to create a {@code LocalDateTime}\n     * at the start of this date.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the time of\n     * midnight, 00:00, at the start of this date.\n     *\n     * @return the local date-time of midnight at the start of this date, not null\n     */\n    public LocalDateTime atStartOfDay() {\n        return LocalDateTime.of(this, LocalTime.MIDNIGHT);\n    }\n\n    /**\n     * Returns a zoned date-time from this date at the earliest valid time according\n     * to the rules in the time-zone.\n     * \u003cp\u003e\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may not be midnight.\n     * \u003cp\u003e\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, there are two valid offsets, and the earlier one is used,\n     * corresponding to the first occurrence of midnight on the date.\n     * In the case of a gap, the zoned date-time will represent the instant just after the gap.\n     * \u003cp\u003e\n     * If the zone ID is a {@link ZoneOffset}, then the result always has a time of midnight.\n     * \u003cp\u003e\n     * To convert to a specific time in a given time-zone call {@link #atTime(LocalTime)}\n     * followed by {@link LocalDateTime#atZone(ZoneId)}.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atStartOfDay(ZoneId zone) {\n        Objects.requireNonNull(zone, \"zone\");\n        // need to handle case where there is a gap from 11:30 to 00:30\n        // standard ZDT factory would result in 01:00 rather than 00:30\n        LocalDateTime ldt \u003d atTime(LocalTime.MIDNIGHT);\n        if (zone instanceof ZoneOffset \u003d\u003d false) {\n            ZoneRules rules \u003d zone.getRules();\n            ZoneOffsetTransition trans \u003d rules.getTransition(ldt);\n            if (trans !\u003d null \u0026\u0026 trans.isGap()) {\n                ldt \u003d trans.getDateTimeAfter();\n            }\n        }\n        return ZonedDateTime.of(ldt, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public long toEpochDay() {\n        long y \u003d year;\n        long m \u003d month;\n        long total \u003d 0;\n        total +\u003d 365 * y;\n        if (y \u003e\u003d 0) {\n            total +\u003d (y + 3) / 4 - (y + 99) / 100 + (y + 399) / 400;\n        } else {\n            total -\u003d y / -4 - y / -100 + y / -400;\n        }\n        total +\u003d ((367 * m - 362) / 12);\n        total +\u003d day - 1;\n        if (m \u003e 2) {\n            total--;\n            if (isLeapYear() \u003d\u003d false) {\n                total--;\n            }\n        }\n        return total - DAYS_0000_TO_1970;\n    }\n\n    /**\n     * Converts this {@code LocalDate} to the number of seconds since the epoch\n     * of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This combines this local date with the specified time and\n     * offset to calculate the epoch-second value, which is the\n     * number of elapsed seconds from 1970-01-01T00:00:00Z.\n     * Instants on the time-line after the epoch are positive, earlier\n     * are negative.\n     *\n     * @param time the local time, not null\n     * @param offset the zone offset, not null\n     * @return the number of seconds since the epoch of 1970-01-01T00:00:00Z, may be negative\n     * @since 9\n     */\n    public long toEpochSecond(LocalTime time, ZoneOffset offset) {\n        Objects.requireNonNull(time, \"time\");\n        Objects.requireNonNull(offset, \"offset\");\n        long secs \u003d toEpochDay() * SECONDS_PER_DAY + time.toSecondOfDay();\n        secs -\u003d offset.getTotalSeconds();\n        return secs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date to another date.\n     * \u003cp\u003e\n     * The comparison is primarily based on the date, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * If all the dates being compared are instances of {@code LocalDate},\n     * then the comparison will be entirely based on the date.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link java.time.chrono.ChronoLocalDate#compareTo}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override  // override for Javadoc and performance\n    public int compareTo(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other);\n        }\n        return ChronoLocalDate.super.compareTo(other);\n    }\n\n    int compareTo0(LocalDate otherDate) {\n        int cmp \u003d (year - otherDate.year);\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d (month - otherDate.month);\n            if (cmp \u003d\u003d 0) {\n                cmp \u003d (day - otherDate.day);\n            }\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date is after the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents a point on the\n     * local time-line after the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isAfter(b) \u003d\u003d false\n     *   a.isAfter(a) \u003d\u003d false\n     *   b.isAfter(a) \u003d\u003d true\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is after the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isAfter(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003e 0;\n        }\n        return ChronoLocalDate.super.isAfter(other);\n    }\n\n    /**\n     * Checks if this date is before the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents a point on the\n     * local time-line before the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isBefore(b) \u003d\u003d true\n     *   a.isBefore(a) \u003d\u003d false\n     *   b.isBefore(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is before the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isBefore(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003c 0;\n        }\n        return ChronoLocalDate.super.isBefore(other);\n    }\n\n    /**\n     * Checks if this date is equal to the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents the same point on the\n     * local time-line as the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isEqual(b) \u003d\u003d false\n     *   a.isEqual(a) \u003d\u003d true\n     *   b.isEqual(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)}\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is equal to the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isEqual(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003d\u003d 0;\n        }\n        return ChronoLocalDate.super.isEqual(other);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date is equal to another date.\n     * \u003cp\u003e\n     * Compares this {@code LocalDate} with another ensuring that the date is the same.\n     * \u003cp\u003e\n     * Only objects of type {@code LocalDate} are compared, other types return false.\n     * To compare the dates of two {@code TemporalAccessor} instances, including dates\n     * in two different chronologies, use {@link ChronoField#EPOCH_DAY} as a comparator.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof LocalDate) {\n            return compareTo0((LocalDate) obj) \u003d\u003d 0;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        int yearValue \u003d year;\n        int monthValue \u003d month;\n        int dayValue \u003d day;\n        return (yearValue \u0026 0xFFFFF800) ^ ((yearValue \u003c\u003c 11) + (monthValue \u003c\u003c 6) + (dayValue));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date as a {@code String}, such as {@code 2007-12-03}.\n     * \u003cp\u003e\n     * The output will be in the ISO-8601 format {@code uuuu-MM-dd}.\n     *\n     * @return a string representation of this date, not null\n     */\n    @Override\n    public String toString() {\n        int yearValue \u003d year;\n        int monthValue \u003d month;\n        int dayValue \u003d day;\n        int absYear \u003d Math.abs(yearValue);\n        StringBuilder buf \u003d new StringBuilder(10);\n        if (absYear \u003c 1000) {\n            if (yearValue \u003c 0) {\n                buf.append(yearValue - 10000).deleteCharAt(1);\n            } else {\n                buf.append(yearValue + 10000).deleteCharAt(0);\n            }\n        } else {\n            if (yearValue \u003e 9999) {\n                buf.append(\u0027+\u0027);\n            }\n            buf.append(yearValue);\n        }\n        return buf.append(monthValue \u003c 10 ? \"-0\" : \"-\")\n            .append(monthValue)\n            .append(dayValue \u003c 10 ? \"-0\" : \"-\")\n            .append(dayValue)\n            .toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(3);  // identifies a LocalDate\n     *  out.writeInt(year);\n     *  out.writeByte(month);\n     *  out.writeByte(day);\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.LOCAL_DATE_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(DataOutput out) throws IOException {\n        out.writeInt(year);\n        out.writeByte(month);\n        out.writeByte(day);\n    }\n\n    static LocalDate readExternal(DataInput in) throws IOException {\n        int year \u003d in.readInt();\n        int month \u003d in.readByte();\n        int dayOfMonth \u003d in.readByte();\n        return LocalDate.of(year, month, dayOfMonth);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 18, 2024 2:07:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 18, 2024 2:12:53 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5238
2024.10.18 14:13:03 WARN  Using indexes to guess the definition of parse
oct 18, 2024 2:13:05 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5326
oct 18, 2024 2:13:05 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5328
oct 18, 2024 2:13:06 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5330
oct 18, 2024 2:13:06 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5331
oct 18, 2024 2:13:06 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5334
oct 18, 2024 2:15:45 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5555
oct 18, 2024 2:17:02 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5946
oct 18, 2024 2:17:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6079
2024.10.18 14:18:08 INFO  Started: Metals version 1.3.5 in folders 'C:\Proyectos\spark-datos-energia' for client Visual Studio Code 1.94.2.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@16a4ec8f]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@e76c962]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@16a4ec8f]
2024.10.18 14:18:08 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.18 14:18:09 INFO  Attempting to connect to the build server...
2024.10.18 14:18:09 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.18 14:18:09 INFO  Attempting to connect to the build server...
2024.10.18 14:18:09 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\project\.metals\bsp.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.10.18 14:18:09 INFO  time: Connected to build server in 0.74s
2024.10.18 14:18:09 INFO  Connected to Build server: Bloop v1.6.0
2024.10.18 14:18:10 INFO  time: Imported build in 0.13s
2024.10.18 14:18:10 INFO  running doctor check
2024.10.18 14:18:10 INFO  java targets: spark-datos-energia-build, root-test, root
oct 18, 2024 2:18:11 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 2
oct 18, 2024 2:18:11 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3
oct 18, 2024 2:18:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6
oct 18, 2024 2:18:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 8
oct 18, 2024 2:18:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 9
oct 18, 2024 2:18:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 10
oct 18, 2024 2:18:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 18
2024.10.18 14:18:16 WARN  Flyway upgrade recommended: H2 2.3.230 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.10.18 14:18:26 INFO  time: indexed workspace in 16s
2024.10.18 14:18:27 INFO  compiling root (1 scala source)
2024.10.18 14:18:27 INFO  time: compiled root in 0.31s
2024.10.18 14:18:27 INFO  compiling root (1 scala source)
2024.10.18 14:18:27 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:18:26 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:18:27 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:18:27 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:18:27 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:18:27 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:18:27 INFO  time: compiled root in 0.13s
2024.10.18 14:18:27 INFO  compiling root (1 scala source)
2024.10.18 14:18:27 INFO  time: compiled root in 0.12s
2024.10.18 14:18:29 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:18:34 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:18:34 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:18:38 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:19:39 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:19:41 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:19:41 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:19:43 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:19:45 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:19:46 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:19:48 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:19:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:19:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:25 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:25 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:26 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:28 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:28 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:29 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:29 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:20:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 252
oct 18, 2024 2:20:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 253
oct 18, 2024 2:20:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 254
oct 18, 2024 2:20:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 255
oct 18, 2024 2:20:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 256
2024.10.18 14:20:30 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:31 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:34 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:34 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:35 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:20:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 298
2024.10.18 14:20:36 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:36 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:37 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:38 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:39 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:45 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:20:45 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 371
2024.10.18 14:20:46 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:48 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:49 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:20:49 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 407
2024.10.18 14:20:49 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:49 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:53 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:54 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:54 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:20:58 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:21:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:21:01 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:21:03 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:21:03 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:21:04 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:21:05 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:21:06 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:21:06 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:21:08 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:21:08 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:21:08 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:21:08 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:21:10 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:21:11 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:23:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:23:55 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:23:58 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:01 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:04 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:04 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:05 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:05 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:07 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:09 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:09 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:10 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:13 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:14 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:14 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:15 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:16 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:16 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:17 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:18 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:22 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:22 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:23 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:23 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:24 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:25 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:25 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:26 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:27 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:30 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:30 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:24:40 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:06 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:17 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:23 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:24 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:25 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:26 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:29 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:30 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:31 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:33 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:36 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:37 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:38 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:42 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:42 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:28:44 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1026
2024.10.18 14:28:46 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:46 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:46 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:28:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:29:02 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:29:02 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:29:03 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:29:03 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:29:04 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:29:05 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:29:10 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:29:10 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:29:11 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:29:11 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:29:12 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:32:35 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:32:36 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:32:44 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:23 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:24 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:25 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:28 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:30 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:36 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:34:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1281
2024.10.18 14:34:37 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:38 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:38 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:39 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:39 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:41 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:41 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:42 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:43 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:44 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:43 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:34:58 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:05 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:07 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:08 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:09 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:09 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:13 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:35:43 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:36:22 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:36:23 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:36:25 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:36:26 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:36:26 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:36:27 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:36:27 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:36:40 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:36:49 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:36:53 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:36:54 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:36:54 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:36:55 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:38:40 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:38:41 P. M. scala.meta.internal.pc.CompletionProvider expected$1
ADVERTENCIA: offset 661, count -1, length 2764
2024.10.18 14:38:41 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:38:41 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:38:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:38:53 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:38:53 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:38:54 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:38:56 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:38:59 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:39:03 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:39:04 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:39:04 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:39:06 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:39:08 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:39:10 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:39:10 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:39:11 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 1908
2024.10.18 14:39:12 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:39:13 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:39:38 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:39:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:39:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:39:51 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:39:59 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:40:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:40:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:40:01 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:40:38 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:40:48 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:40:51 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:40:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:40:53 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:40:54 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:40:54 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:40:55 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:41:11 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:41:12 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:41:16 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:43:09 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:43:09 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:43:10 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:43:45 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:43:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:43:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:44:38 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:27 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:35 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:35 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:35 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:36 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:37 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:43 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:44 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:53 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:54 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:54 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:45:59 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:07 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:09 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:10 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:09 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:10 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:11 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:12 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:13 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:23 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:25 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:26 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:26 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:26 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:27 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:28 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:29 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:29 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:30 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:31 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:34 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:35 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:44 INFO  compiling root (1 scala source)
2024.10.18 14:46:44 INFO  time: compiled root in 0.34s
2024.10.18 14:46:45 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:54 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:46:56 INFO  compiling root (1 scala source)
2024.10.18 14:46:56 INFO  time: compiled root in 0.39s
2024.10.18 14:46:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:47:16 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:47:17 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:47:19 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:47:20 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:47:20 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:47:37 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:47:42 INFO  compiling root (1 scala source)
2024.10.18 14:47:42 INFO  time: compiled root in 0.19s
2024.10.18 14:47:42 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:47:44 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:47:45 INFO  compiling root (1 scala source)
2024.10.18 14:47:45 INFO  time: compiled root in 0.28s
2024.10.18 14:47:46 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:48:13 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:48:15 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:48:17 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:48:20 INFO  compiling root (1 scala source)
2024.10.18 14:48:20 INFO  time: compiled root in 0.25s
2024.10.18 14:48:21 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:48:36 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:48:36 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:48:37 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:48:38 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:48:38 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:48:42 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:48:43 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:48:43 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:48:45 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:48:45 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:50:26 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3195
2024.10.18 14:50:54 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:51:10 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:51:42 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:51:48 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:51:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:52:19 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3509
oct 18, 2024 2:52:19 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3510
2024.10.18 14:52:20 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:52:20 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:52:27 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 3549
2024.10.18 14:53:23 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:53:32 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:53:46 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:53:47 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:53:51 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:53:51 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:53:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:53:53 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:53:55 INFO  compiling root (1 scala source)
2024.10.18 14:53:55 INFO  time: compiled root in 0.34s
2024.10.18 14:53:56 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:02 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:02 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:03 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:04 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:05 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:06 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:07 INFO  compiling root (1 scala source)
2024.10.18 14:54:07 INFO  time: compiled root in 0.24s
2024.10.18 14:54:07 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:21 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:21 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:33 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:34 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:35 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:36 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:36 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:37 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:44 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:45 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:46 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:47 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:48 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:49 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:49 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:51 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:51 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:53 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:55 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:55 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:56 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:57 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:54:58 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:55:01 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4019
2024.10.18 14:55:01 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:05 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:05 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:06 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:07 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:08 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:55:09 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4098
2024.10.18 14:55:10 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:10 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:12 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:13 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:13 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:13 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:14 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:15 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:16 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:55:16 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4190
2024.10.18 14:55:17 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:18 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:18 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:55:18 P. M. scala.meta.internal.pc.CompletionProvider expected$1
ADVERTENCIA: offset 1104, count -1, length 2995
2024.10.18 14:55:19 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:20 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:21 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:22 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:25 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:25 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:26 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:27 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:27 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:28 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:28 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:29 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:30 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:31 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:31 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:31 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:32 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:33 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:33 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:55:37 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:07 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:08 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:09 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:13 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:14 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:15 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:21 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:21 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:22 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:24 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:24 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:25 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:27 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:27 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:29 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:30 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:32 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:33 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:34 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:56:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4628
oct 18, 2024 2:56:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4633
oct 18, 2024 2:56:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4638
2024.10.18 14:56:36 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:56:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4658
2024.10.18 14:56:38 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:38 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:40 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:41 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:43 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:45 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:45 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:46 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:48 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:50 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:52 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:53 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:56:55 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:56:55 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 4852
2024.10.18 14:57:00 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:16 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:16 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:17 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:18 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:19 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:21 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:25 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:34 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:37 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:38 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:40 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:41 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:42 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:43 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:43 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:43 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:44 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:45 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:46 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
oct 18, 2024 2:58:46 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5171
2024.10.18 14:58:47 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:47 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:48 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:58:49 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:59:04 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:59:04 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:59:13 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:59:17 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:59:18 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:59:19 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:59:24 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:59:25 WARN  Could not load snapshot text for C:\Proyectos\spark-datos-energia\src\main\scala\example\ApiDataIngestion.scala
2024.10.18 14:59:28 INFO  compiling root (1 scala source)
2024.10.18 14:59:28 INFO  time: compiled root in 0.98s
oct 18, 2024 3:00:20 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 5629
2024.10.18 15:01:11 INFO  compiling root (1 scala source)
2024.10.18 15:01:11 INFO  time: compiled root in 0.19s
oct 18, 2024 3:01:28 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6110
2024.10.18 15:01:31 INFO  compiling root (1 scala source)
2024.10.18 15:01:31 INFO  time: compiled root in 0.6s
2024.10.18 15:01:58 INFO  compiling root (1 scala source)
2024.10.18 15:01:58 INFO  time: compiled root in 0.62s
2024.10.18 15:02:39 INFO  compiling root (1 scala source)
2024.10.18 15:02:39 INFO  time: compiled root in 0.58s
oct 18, 2024 3:03:10 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTENCIA: Unmatched cancel notification for request id 6378
2024.10.18 15:03:47 INFO  compiling root (1 scala source)
2024.10.18 15:03:47 INFO  time: compiled root in 0.56s
2024.10.18 15:04:00 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5' (since 45m 50.422s)
2024.10.18 15:04:00 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.18 15:04:00 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.18 15:04:01 INFO  Starting debug proxy for [example.Main]
2024.10.18 15:04:02 INFO  Loaded expression compiler in 1 second
2024.10.18 15:04:02 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:04:02 WARN  Found duplicate entry jersey-server in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:04:02 WARN  Found duplicate entry jersey-client in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:04:06 INFO  Loaded all sources and classes in 4 seconds
2024.10.18 15:04:06 INFO  Initialized Scala 3 decoder in 2 milliseconds
2024.10.18 15:04:06 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:54432 .
2024.10.18 15:04:06 INFO  Attaching to debuggee VM succeeded.
oct 18, 2024 3:04:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:07 INFO SparkContext: Running Spark version 3.5.0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:07 IN..._15-04-07-727.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:07 INFO SparkContext: OS info Windows 11, 10.0, amd64"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:07 IN..._15-04-07-731.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:07 INFO SparkContext: Java version 11.0.24"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:07 IN..._15-04-07-731.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:07 INFO ResourceUtils: \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:07 IN..._15-04-07-897.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:07 INFO ResourceUtils: No custom resources configured for spark.driver."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:07 IN..._15-04-07-898.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:07 INFO ResourceUtils: \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:07 IN..._15-04-07-899.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:07 INFO SparkContext: Submitted application: spark-javi"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:07 IN..._15-04-07-900.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:07 INFO ResourceProfile: Default ResourceProfile created, executor resources: Map(cores -\u003e name: cores, amount: 1, script: , vendor: , memory -\u003e name: memory, amount: 1024, script: , vendor: , offHeap -\u003e name: offHeap, amount: 0, script: , vendor: ), task resources: Map(cpus -\u003e name: cpus, amount: 1.0)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:07 IN..._15-04-07-921.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:07 INFO ResourceProfile: Limiting resource is cpu"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:07 IN..._15-04-07-925.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:07 INFO ResourceProfileManager: Added ResourceProfile id: 0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:07 IN..._15-04-07-926.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:07 INFO SecurityManager: Changing view acls to: jalva"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:07 IN..._15-04-07-977.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:07 INFO SecurityManager: Changing modify acls to: jalva"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:07 IN..._15-04-07-977.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:07 INFO SecurityManager: Changing view acls groups to: "
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:07 IN..._15-04-07-979.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:07 INFO SecurityManager: Changing modify acls groups to: "
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:07 IN..._15-04-07-979.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:07 INFO SecurityManager: SecurityManager: authentication disabled; ui acls disabled; users with view permissions: jalva; groups with view permissions: EMPTY; users with modify permissions: jalva; groups with modify permissions: EMPTY"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:07 IN..._15-04-07-979.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO Utils: Successfully started service \u0027sparkDriver\u0027 on port 54471."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-523.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO SparkEnv: Registering MapOutputTracker"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-546.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: An illegal reflective access operation has occurred"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: An illegal ..._15-04-08-563.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Illegal reflective access by org.apache.spark.unsafe.Platform (file:/C:/Users/jalva/AppData/Local/Coursier/Cache/v1/https/repo1.maven.org/maven2/org/apache/spark/spark-unsafe_2.13/3.5.0/spark-unsafe_2.13-3.5.0.jar) to constructor java.nio.DirectByteBuffer(long,int)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Illegal ref..._15-04-08-565.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Please consider reporting this to the maintainers of org.apache.spark.unsafe.Platform"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Please cons..._15-04-08-565.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Use --illegal-access\u003dwarn to enable warnings of further illegal reflective access operations"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Use --illeg..._15-04-08-565.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: All illegal access operations will be denied in a future release"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: All illegal..._15-04-08-565.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO SparkEnv: Registering BlockManagerMaster"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-580.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO BlockManagerMasterEndpoint: Using org.apache.spark.storage.DefaultTopologyMapper for getting topology information"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-597.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO BlockManagerMasterEndpoint: BlockManagerMasterEndpoint up"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-598.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO SparkEnv: Registering BlockManagerMasterHeartbeat"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-601.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO DiskBlockManager: Created local directory at C:\\Users\\jalva\\AppData\\Local\\Temp\\blockmgr-4d999eb0-90bf-4cbe-a2b0-2e18293db146"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-622.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO MemoryStore: MemoryStore started with capacity 2.2 GiB"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-651.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO SparkEnv: Registering OutputCommitCoordinator"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-667.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO JettyUtils: Start Jetty 0.0.0.0:4040 for SparkUI"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-784.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 WARN Utils: Service \u0027SparkUI\u0027 could not bind on port 4040. Attempting port 4041."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 WA..._15-04-08-829.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO Utils: Successfully started service \u0027SparkUI\u0027 on port 4041."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-841.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO Executor: Starting executor ID driver on host host.docker.internal"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-921.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO Executor: OS info Windows 11, 10.0, amd64"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-922.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO Executor: Java version 11.0.24"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-922.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO Executor: Starting executor with user classpath (userClassPathFirst \u003d false): \u0027\u0027"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-928.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO Executor: Created or updated repl class loader org.apache.spark.util.MutableURLClassLoader@7e9f2c32 for default."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-928.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO Utils: Successfully started service \u0027org.apache.spark.network.netty.NettyBlockTransferService\u0027 on port 54522."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-951.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO NettyBlockTransferService: Server created on host.docker.internal:54522"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-952.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO BlockManager: Using org.apache.spark.storage.RandomBlockReplicationPolicy for block replication policy"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-953.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO BlockManagerMaster: Registering BlockManager BlockManagerId(driver, host.docker.internal, 54522, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-958.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO BlockManagerMasterEndpoint: Registering block manager host.docker.internal:54522 with 2.2 GiB RAM, BlockManagerId(driver, host.docker.internal, 54522, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-962.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO BlockManagerMaster: Registered BlockManager BlockManagerId(driver, host.docker.internal, 54522, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-964.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:08 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:08 INFO BlockManager: Initialized BlockManager: BlockManagerId(driver, host.docker.internal, 54522, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:08 IN..._15-04-08-964.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:09 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:09 INFO SparkContext: Invoking stop() from shutdown hook"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:09 IN..._15-04-09-319.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:09 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:09 INFO SparkContext: SparkContext is stopping with exitCode 0."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:09 IN..._15-04-09-320.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:09 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:09 INFO SparkUI: Stopped Spark web UI at http://host.docker.internal:4041"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:09 IN..._15-04-09-321.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:09 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:09 INFO MapOutputTrackerMasterEndpoint: MapOutputTrackerMasterEndpoint stopped!"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:09 IN..._15-04-09-321.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:09 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:09 INFO MemoryStore: MemoryStore cleared"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:09 IN..._15-04-09-322.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:09 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:09 INFO BlockManager: BlockManager stopped"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:09 IN..._15-04-09-323.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:09 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:09 INFO BlockManagerMaster: BlockManagerMaster stopped"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:09 IN..._15-04-09-323.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:09 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:09 INFO OutputCommitCoordinator$OutputCommitCoordinatorEndpoint: OutputCommitCoordinator stopped!"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:09 IN..._15-04-09-326.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:09 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:09 INFO SparkContext: Successfully stopped SparkContext"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:09 IN..._15-04-09-331.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:09 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:09 INFO ShutdownHookManager: Shutdown hook called"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:09 IN..._15-04-09-333.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:09 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:09 INFO ShutdownHookManager: Deleting directory C:\\Users\\jalva\\AppData\\Local\\Temp\\spark-4d791300-6860-4747-83b4-021e8e251a22"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:09 IN..._15-04-09-333.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.18 15:04:09 INFO  Canceling debug proxy for [example.Main]
2024.10.18 15:04:09 INFO  Closing debug server tcp://0.0.0.0:54429
2024.10.18 15:04:18 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5' (since 46m 7.918s)
2024.10.18 15:04:18 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.18 15:04:18 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.18 15:04:18 INFO  Starting debug proxy for [example.Main]
2024.10.18 15:04:18 INFO  Loaded expression compiler in 2 milliseconds
2024.10.18 15:04:18 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:04:18 WARN  Found duplicate entry jersey-server in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:04:18 WARN  Found duplicate entry jersey-client in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:04:20 INFO  Loaded all sources and classes in 2 seconds
2024.10.18 15:04:20 INFO  Initialized Scala 3 decoder in 0 milliseconds
2024.10.18 15:04:20 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:54529 .
2024.10.18 15:04:20 INFO  Attaching to debuggee VM succeeded.
oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO SparkContext: Running Spark version 3.5.0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-129.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO SparkContext: OS info Windows 11, 10.0, amd64"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-132.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO SparkContext: Java version 11.0.24"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-132.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO ResourceUtils: \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-317.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO ResourceUtils: No custom resources configured for spark.driver."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-317.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO ResourceUtils: \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-318.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO SparkContext: Submitted application: spark-javi"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-318.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO ResourceProfile: Default ResourceProfile created, executor resources: Map(cores -\u003e name: cores, amount: 1, script: , vendor: , memory -\u003e name: memory, amount: 1024, script: , vendor: , offHeap -\u003e name: offHeap, amount: 0, script: , vendor: ), task resources: Map(cpus -\u003e name: cpus, amount: 1.0)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-340.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO ResourceProfile: Limiting resource is cpu"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-343.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO ResourceProfileManager: Added ResourceProfile id: 0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-344.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO SecurityManager: Changing view acls to: jalva"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-397.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO SecurityManager: Changing modify acls to: jalva"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-398.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO SecurityManager: Changing view acls groups to: "
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-398.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO SecurityManager: Changing modify acls groups to: "
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-399.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO SecurityManager: SecurityManager: authentication disabled; ui acls disabled; users with view permissions: jalva; groups with view permissions: EMPTY; users with modify permissions: jalva; groups with modify permissions: EMPTY"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-399.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO Utils: Successfully started service \u0027sparkDriver\u0027 on port 54565."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-934.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO SparkEnv: Registering MapOutputTracker"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-956.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: An illegal reflective access operation has occurred"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: An illegal ..._15-04-22-974.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Illegal reflective access by org.apache.spark.unsafe.Platform (file:/C:/Users/jalva/AppData/Local/Coursier/Cache/v1/https/repo1.maven.org/maven2/org/apache/spark/spark-unsafe_2.13/3.5.0/spark-unsafe_2.13-3.5.0.jar) to constructor java.nio.DirectByteBuffer(long,int)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Illegal ref..._15-04-22-974.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Please consider reporting this to the maintainers of org.apache.spark.unsafe.Platform"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Please cons..._15-04-22-975.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Use --illegal-access\u003dwarn to enable warnings of further illegal reflective access operations"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Use --illeg..._15-04-22-975.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: All illegal access operations will be denied in a future release"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: All illegal..._15-04-22-975.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:22 INFO SparkEnv: Registering BlockManagerMaster"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:22 IN..._15-04-22-986.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO BlockManagerMasterEndpoint: Using org.apache.spark.storage.DefaultTopologyMapper for getting topology information"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-001.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO BlockManagerMasterEndpoint: BlockManagerMasterEndpoint up"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-003.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO SparkEnv: Registering BlockManagerMasterHeartbeat"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-005.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO DiskBlockManager: Created local directory at C:\\Users\\jalva\\AppData\\Local\\Temp\\blockmgr-3da2e5a2-f0a9-4b9a-a5aa-1377b98c4406"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-023.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO MemoryStore: MemoryStore started with capacity 2.2 GiB"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-053.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO SparkEnv: Registering OutputCommitCoordinator"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-068.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO JettyUtils: Start Jetty 0.0.0.0:4040 for SparkUI"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-166.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 WARN Utils: Service \u0027SparkUI\u0027 could not bind on port 4040. Attempting port 4041."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 WA..._15-04-23-208.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO Utils: Successfully started service \u0027SparkUI\u0027 on port 4041."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-219.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO Executor: Starting executor ID driver on host host.docker.internal"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-300.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO Executor: OS info Windows 11, 10.0, amd64"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-300.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO Executor: Java version 11.0.24"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-300.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO Executor: Starting executor with user classpath (userClassPathFirst \u003d false): \u0027\u0027"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-307.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO Executor: Created or updated repl class loader org.apache.spark.util.MutableURLClassLoader@7e9f2c32 for default."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-307.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO Utils: Successfully started service \u0027org.apache.spark.network.netty.NettyBlockTransferService\u0027 on port 54616."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-334.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO NettyBlockTransferService: Server created on host.docker.internal:54616"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-335.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO BlockManager: Using org.apache.spark.storage.RandomBlockReplicationPolicy for block replication policy"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-336.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO BlockManagerMaster: Registering BlockManager BlockManagerId(driver, host.docker.internal, 54616, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-343.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO BlockManagerMasterEndpoint: Registering block manager host.docker.internal:54616 with 2.2 GiB RAM, BlockManagerId(driver, host.docker.internal, 54616, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-347.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO BlockManagerMaster: Registered BlockManager BlockManagerId(driver, host.docker.internal, 54616, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-349.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:04:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:04:23 INFO BlockManager: Initialized BlockManager: BlockManagerId(driver, host.docker.internal, 54616, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:04:23 IN..._15-04-23-349.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.18 15:04:39 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:04:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2008-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time.format;\n\nimport static java.time.temporal.ChronoField.DAY_OF_MONTH;\nimport static java.time.temporal.ChronoField.DAY_OF_WEEK;\nimport static java.time.temporal.ChronoField.DAY_OF_YEAR;\nimport static java.time.temporal.ChronoField.HOUR_OF_DAY;\nimport static java.time.temporal.ChronoField.MINUTE_OF_HOUR;\nimport static java.time.temporal.ChronoField.MONTH_OF_YEAR;\nimport static java.time.temporal.ChronoField.NANO_OF_SECOND;\nimport static java.time.temporal.ChronoField.SECOND_OF_MINUTE;\nimport static java.time.temporal.ChronoField.YEAR;\n\nimport java.io.IOException;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.time.DateTimeException;\nimport java.time.Period;\nimport java.time.ZoneId;\nimport java.time.ZoneOffset;\nimport java.time.chrono.ChronoLocalDateTime;\nimport java.time.chrono.Chronology;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatterBuilder.CompositePrinterParser;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.IsoFields;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQuery;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport sun.util.locale.provider.TimeZoneNameUtility;\n\n/**\n * Formatter for printing and parsing date-time objects.\n * \u003cp\u003e\n * This class provides the main application entry point for printing and parsing\n * and provides common implementations of {@code DateTimeFormatter}:\n * \u003cul\u003e\n * \u003cli\u003eUsing predefined constants, such as {@link #ISO_LOCAL_DATE}\u003c/li\u003e\n * \u003cli\u003eUsing pattern letters, such as {@code uuuu-MMM-dd}\u003c/li\u003e\n * \u003cli\u003eUsing localized styles, such as {@code long} or {@code medium}\u003c/li\u003e\n * \u003c/ul\u003e\n * \u003cp\u003e\n * More complex formatters are provided by\n * {@link DateTimeFormatterBuilder DateTimeFormatterBuilder}.\n *\n * \u003cp\u003e\n * The main date-time classes provide two methods - one for formatting,\n * {@code format(DateTimeFormatter formatter)}, and one for parsing,\n * {@code parse(CharSequence text, DateTimeFormatter formatter)}.\n * \u003cp\u003eFor example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *  LocalDate date \u003d LocalDate.now();\n *  String text \u003d date.format(formatter);\n *  LocalDate parsedDate \u003d LocalDate.parse(text, formatter);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * In addition to the format, formatters can be created with desired Locale,\n * Chronology, ZoneId, and DecimalStyle.\n * \u003cp\u003e\n * The {@link #withLocale withLocale} method returns a new formatter that\n * overrides the locale. The locale affects some aspects of formatting and\n * parsing. For example, the {@link #ofLocalizedDate ofLocalizedDate} provides a\n * formatter that uses the locale specific date format.\n * \u003cp\u003e\n * The {@link #withChronology withChronology} method returns a new formatter\n * that overrides the chronology. If overridden, the date-time value is\n * converted to the chronology before formatting. During parsing the date-time\n * value is converted to the chronology before it is returned.\n * \u003cp\u003e\n * The {@link #withZone withZone} method returns a new formatter that overrides\n * the zone. If overridden, the date-time value is converted to a ZonedDateTime\n * with the requested ZoneId before formatting. During parsing the ZoneId is\n * applied before the value is returned.\n * \u003cp\u003e\n * The {@link #withDecimalStyle withDecimalStyle} method returns a new formatter that\n * overrides the {@link DecimalStyle}. The DecimalStyle symbols are used for\n * formatting and parsing.\n * \u003cp\u003e\n * Some applications may need to use the older {@link Format java.text.Format}\n * class for formatting. The {@link #toFormat()} method returns an\n * implementation of {@code java.text.Format}.\n *\n * \u003ch3 id\u003d\"predefined\"\u003ePredefined Formatters\u003c/h3\u003e\n * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n * \u003ccaption\u003ePredefined Formatters\u003c/caption\u003e\n * \u003cthead\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"col\"\u003eFormatter\u003c/th\u003e\n * \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n * \u003cth scope\u003d\"col\"\u003eExample\u003c/th\u003e\n * \u003c/tr\u003e\n * \u003c/thead\u003e\n * \u003ctbody\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e{@link #ofLocalizedDate ofLocalizedDate(dateStyle)} \u003c/th\u003e\n * \u003ctd\u003e Formatter with date style from the locale \u003c/td\u003e\n * \u003ctd\u003e \u00272011-12-03\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ofLocalizedTime ofLocalizedTime(timeStyle)} \u003c/th\u003e\n * \u003ctd\u003e Formatter with time style from the locale \u003c/td\u003e\n * \u003ctd\u003e \u002710:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ofLocalizedDateTime ofLocalizedDateTime(dateTimeStyle)} \u003c/th\u003e\n * \u003ctd\u003e Formatter with a style for date and time from the locale\u003c/td\u003e\n * \u003ctd\u003e \u00273 Jun 2008 11:05:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ofLocalizedDateTime ofLocalizedDateTime(dateStyle,timeStyle)}\n * \u003c/th\u003e\n * \u003ctd\u003e Formatter with date and time styles from the locale \u003c/td\u003e\n * \u003ctd\u003e \u00273 Jun 2008 11:05\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #BASIC_ISO_DATE}\u003c/th\u003e\n * \u003ctd\u003eBasic ISO date \u003c/td\u003e \u003ctd\u003e\u002720111203\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_LOCAL_DATE}\u003c/th\u003e\n * \u003ctd\u003e ISO Local Date \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_OFFSET_DATE}\u003c/th\u003e\n * \u003ctd\u003e ISO Date with offset \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03+01:00\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_DATE}\u003c/th\u003e\n * \u003ctd\u003e ISO Date with or without offset \u003c/td\u003e\n * \u003ctd\u003e \u00272011-12-03+01:00\u0027; \u00272011-12-03\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_LOCAL_TIME}\u003c/th\u003e\n * \u003ctd\u003e Time without offset \u003c/td\u003e\n * \u003ctd\u003e\u002710:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_OFFSET_TIME}\u003c/th\u003e\n * \u003ctd\u003e Time with offset \u003c/td\u003e\n * \u003ctd\u003e\u002710:15:30+01:00\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_TIME}\u003c/th\u003e\n * \u003ctd\u003e Time with or without offset \u003c/td\u003e\n * \u003ctd\u003e\u002710:15:30+01:00\u0027; \u002710:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_LOCAL_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e ISO Local Date and Time \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_OFFSET_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e Date Time with Offset\n * \u003c/td\u003e\u003ctd\u003e\u00272011-12-03T10:15:30+01:00\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_ZONED_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e Zoned Date Time \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e Date and time with ZoneId \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_ORDINAL_DATE}\u003c/th\u003e\n * \u003ctd\u003e Year and day of year \u003c/td\u003e\n * \u003ctd\u003e\u00272012-337\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_WEEK_DATE}\u003c/th\u003e\n * \u003ctd\u003e Year and Week \u003c/td\u003e\n * \u003ctd\u003e\u00272012-W48-6\u0027\u003c/td\u003e\u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #ISO_INSTANT}\u003c/th\u003e\n * \u003ctd\u003e Date and Time of an Instant \u003c/td\u003e\n * \u003ctd\u003e\u00272011-12-03T10:15:30Z\u0027 \u003c/td\u003e\n * \u003c/tr\u003e\n * \u003ctr\u003e\n * \u003cth scope\u003d\"row\"\u003e {@link #RFC_1123_DATE_TIME}\u003c/th\u003e\n * \u003ctd\u003e RFC 1123 / RFC 822 \u003c/td\u003e\n * \u003ctd\u003e\u0027Tue, 3 Jun 2008 11:05:30 GMT\u0027\u003c/td\u003e\n * \u003c/tr\u003e\n * \u003c/tbody\u003e\n * \u003c/table\u003e\n *\n * \u003ch3 id\u003d\"patterns\"\u003ePatterns for Formatting and Parsing\u003c/h3\u003e\n * Patterns are based on a simple sequence of letters and symbols.\n * A pattern is used to create a Formatter using the\n * {@link #ofPattern(String)} and {@link #ofPattern(String, Locale)} methods.\n * For example,\n * {@code \"d MMM uuuu\"} will format 2011-12-03 as \u00273\u0026nbsp;Dec\u0026nbsp;2011\u0027.\n * A formatter created from a pattern can be used as many times as necessary,\n * it is immutable and is thread-safe.\n * \u003cp\u003e\n * For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *  LocalDate date \u003d LocalDate.now();\n *  DateTimeFormatter formatter \u003d DateTimeFormatter.ofPattern(\"yyyy MM dd\");\n *  String text \u003d date.format(formatter);\n *  LocalDate parsedDate \u003d LocalDate.parse(text, formatter);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * All letters \u0027A\u0027 to \u0027Z\u0027 and \u0027a\u0027 to \u0027z\u0027 are reserved as pattern letters. The\n * following pattern letters are defined:\n * \u003ctable class\u003d\"striped\"\u003e\n * \u003ccaption\u003ePattern Letters and Symbols\u003c/caption\u003e\n * \u003cthead\u003e\n *  \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSymbol\u003c/th\u003e   \u003cth scope\u003d\"col\"\u003eMeaning\u003c/th\u003e         \u003cth scope\u003d\"col\"\u003ePresentation\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eExamples\u003c/th\u003e\n * \u003c/thead\u003e\n * \u003ctbody\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eG\u003c/th\u003e       \u003ctd\u003eera\u003c/td\u003e                         \u003ctd\u003etext\u003c/td\u003e              \u003ctd\u003eAD; Anno Domini; A\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eu\u003c/th\u003e       \u003ctd\u003eyear\u003c/td\u003e                        \u003ctd\u003eyear\u003c/td\u003e              \u003ctd\u003e2004; 04\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ey\u003c/th\u003e       \u003ctd\u003eyear-of-era\u003c/td\u003e                 \u003ctd\u003eyear\u003c/td\u003e              \u003ctd\u003e2004; 04\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eD\u003c/th\u003e       \u003ctd\u003eday-of-year\u003c/td\u003e                 \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e189\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eM/L\u003c/th\u003e     \u003ctd\u003emonth-of-year\u003c/td\u003e               \u003ctd\u003enumber/text\u003c/td\u003e       \u003ctd\u003e7; 07; Jul; July; J\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ed\u003c/th\u003e       \u003ctd\u003eday-of-month\u003c/td\u003e                \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e10\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eg\u003c/th\u003e       \u003ctd\u003emodified-julian-day\u003c/td\u003e         \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e2451334\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eQ/q\u003c/th\u003e     \u003ctd\u003equarter-of-year\u003c/td\u003e             \u003ctd\u003enumber/text\u003c/td\u003e       \u003ctd\u003e3; 03; Q3; 3rd quarter\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eY\u003c/th\u003e       \u003ctd\u003eweek-based-year\u003c/td\u003e             \u003ctd\u003eyear\u003c/td\u003e              \u003ctd\u003e1996; 96\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ew\u003c/th\u003e       \u003ctd\u003eweek-of-week-based-year\u003c/td\u003e     \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e27\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eW\u003c/th\u003e       \u003ctd\u003eweek-of-month\u003c/td\u003e               \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e4\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eE\u003c/th\u003e       \u003ctd\u003eday-of-week\u003c/td\u003e                 \u003ctd\u003etext\u003c/td\u003e              \u003ctd\u003eTue; Tuesday; T\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ee/c\u003c/th\u003e     \u003ctd\u003elocalized day-of-week\u003c/td\u003e       \u003ctd\u003enumber/text\u003c/td\u003e       \u003ctd\u003e2; 02; Tue; Tuesday; T\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eF\u003c/th\u003e       \u003ctd\u003eday-of-week-in-month\u003c/td\u003e        \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e3\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ea\u003c/th\u003e       \u003ctd\u003eam-pm-of-day\u003c/td\u003e                \u003ctd\u003etext\u003c/td\u003e              \u003ctd\u003ePM\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eh\u003c/th\u003e       \u003ctd\u003eclock-hour-of-am-pm (1-12)\u003c/td\u003e  \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e12\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eK\u003c/th\u003e       \u003ctd\u003ehour-of-am-pm (0-11)\u003c/td\u003e        \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e0\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ek\u003c/th\u003e       \u003ctd\u003eclock-hour-of-day (1-24)\u003c/td\u003e    \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e24\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eH\u003c/th\u003e       \u003ctd\u003ehour-of-day (0-23)\u003c/td\u003e          \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e0\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003em\u003c/th\u003e       \u003ctd\u003eminute-of-hour\u003c/td\u003e              \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e30\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003es\u003c/th\u003e       \u003ctd\u003esecond-of-minute\u003c/td\u003e            \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e55\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eS\u003c/th\u003e       \u003ctd\u003efraction-of-second\u003c/td\u003e          \u003ctd\u003efraction\u003c/td\u003e          \u003ctd\u003e978\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eA\u003c/th\u003e       \u003ctd\u003emilli-of-day\u003c/td\u003e                \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e1234\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003en\u003c/th\u003e       \u003ctd\u003enano-of-second\u003c/td\u003e              \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e987654321\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eN\u003c/th\u003e       \u003ctd\u003enano-of-day\u003c/td\u003e                 \u003ctd\u003enumber\u003c/td\u003e            \u003ctd\u003e1234000000\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eV\u003c/th\u003e       \u003ctd\u003etime-zone ID\u003c/td\u003e                \u003ctd\u003ezone-id\u003c/td\u003e           \u003ctd\u003eAmerica/Los_Angeles; Z; -08:30\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ev\u003c/th\u003e       \u003ctd\u003egeneric time-zone name\u003c/td\u003e      \u003ctd\u003ezone-name\u003c/td\u003e         \u003ctd\u003ePacific Time; PT\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ez\u003c/th\u003e       \u003ctd\u003etime-zone name\u003c/td\u003e              \u003ctd\u003ezone-name\u003c/td\u003e         \u003ctd\u003ePacific Standard Time; PST\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eO\u003c/th\u003e       \u003ctd\u003elocalized zone-offset\u003c/td\u003e       \u003ctd\u003eoffset-O\u003c/td\u003e          \u003ctd\u003eGMT+8; GMT+08:00; UTC-08:00\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eX\u003c/th\u003e       \u003ctd\u003ezone-offset \u0027Z\u0027 for zero\u003c/td\u003e    \u003ctd\u003eoffset-X\u003c/td\u003e          \u003ctd\u003eZ; -08; -0830; -08:30; -083015; -08:30:15\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ex\u003c/th\u003e       \u003ctd\u003ezone-offset\u003c/td\u003e                 \u003ctd\u003eoffset-x\u003c/td\u003e          \u003ctd\u003e+0000; -08; -0830; -08:30; -083015; -08:30:15\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003eZ\u003c/th\u003e       \u003ctd\u003ezone-offset\u003c/td\u003e                 \u003ctd\u003eoffset-Z\u003c/td\u003e          \u003ctd\u003e+0000; -0800; -08:00\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003ep\u003c/th\u003e       \u003ctd\u003epad next\u003c/td\u003e                    \u003ctd\u003epad modifier\u003c/td\u003e      \u003ctd\u003e1\u003c/td\u003e\n *\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e\u0027\u003c/th\u003e       \u003ctd\u003eescape for text\u003c/td\u003e             \u003ctd\u003edelimiter\u003c/td\u003e         \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e\u0027\u0027\u003c/th\u003e      \u003ctd\u003esingle quote\u003c/td\u003e                \u003ctd\u003eliteral\u003c/td\u003e           \u003ctd\u003e\u0027\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e[\u003c/th\u003e       \u003ctd\u003eoptional section start\u003c/td\u003e      \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e]\u003c/th\u003e       \u003ctd\u003eoptional section end\u003c/td\u003e        \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e#\u003c/th\u003e       \u003ctd\u003ereserved for future use\u003c/td\u003e     \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{\u003c/th\u003e       \u003ctd\u003ereserved for future use\u003c/td\u003e     \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n *   \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e}\u003c/th\u003e       \u003ctd\u003ereserved for future use\u003c/td\u003e     \u003ctd\u003e\u003c/td\u003e                  \u003ctd\u003e\u003c/td\u003e\n * \u003c/tbody\u003e\n * \u003c/table\u003e\n * \u003cp\u003e\n * The count of pattern letters determines the format.\n * \u003cp\u003e\n * \u003cb\u003eText\u003c/b\u003e: The text style is determined based on the number of pattern\n * letters used. Less than 4 pattern letters will use the\n * {@link TextStyle#SHORT short form}. Exactly 4 pattern letters will use the\n * {@link TextStyle#FULL full form}. Exactly 5 pattern letters will use the\n * {@link TextStyle#NARROW narrow form}.\n * Pattern letters \u0027L\u0027, \u0027c\u0027, and \u0027q\u0027 specify the stand-alone form of the text styles.\n * \u003cp\u003e\n * \u003cb\u003eNumber\u003c/b\u003e: If the count of letters is one, then the value is output using\n * the minimum number of digits and without padding. Otherwise, the count of digits\n * is used as the width of the output field, with the value zero-padded as necessary.\n * The following pattern letters have constraints on the count of letters.\n * Only one letter of \u0027c\u0027 and \u0027F\u0027 can be specified.\n * Up to two letters of \u0027d\u0027, \u0027H\u0027, \u0027h\u0027, \u0027K\u0027, \u0027k\u0027, \u0027m\u0027, and \u0027s\u0027 can be specified.\n * Up to three letters of \u0027D\u0027 can be specified.\n * \u003cp\u003e\n * \u003cb\u003eNumber/Text\u003c/b\u003e: If the count of pattern letters is 3 or greater, use the\n * Text rules above. Otherwise use the Number rules above.\n * \u003cp\u003e\n * \u003cb\u003eFraction\u003c/b\u003e: Outputs the nano-of-second field as a fraction-of-second.\n * The nano-of-second value has nine digits, thus the count of pattern letters\n * is from 1 to 9. If it is less than 9, then the nano-of-second value is\n * truncated, with only the most significant digits being output.\n * \u003cp\u003e\n * \u003cb\u003eYear\u003c/b\u003e: The count of letters determines the minimum field width below\n * which padding is used. If the count of letters is two, then a\n * {@link DateTimeFormatterBuilder#appendValueReduced reduced} two digit form is\n * used. For printing, this outputs the rightmost two digits. For parsing, this\n * will parse using the base value of 2000, resulting in a year within the range\n * 2000 to 2099 inclusive. If the count of letters is less than four (but not\n * two), then the sign is only output for negative years as per\n * {@link SignStyle#NORMAL}. Otherwise, the sign is output if the pad width is\n * exceeded, as per {@link SignStyle#EXCEEDS_PAD}.\n * \u003cp\u003e\n * \u003cb\u003eZoneId\u003c/b\u003e: This outputs the time-zone ID, such as \u0027Europe/Paris\u0027. If the\n * count of letters is two, then the time-zone ID is output. Any other count of\n * letters throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eZone names\u003c/b\u003e: This outputs the display name of the time-zone ID. If the\n * pattern letter is \u0027z\u0027 the output is the daylight savings aware zone name.\n * If there is insufficient information to determine whether DST applies,\n * the name ignoring daylight savings time will be used.\n * If the count of letters is one, two or three, then the short name is output.\n * If the count of letters is four, then the full name is output.\n * Five or more letters throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * If the pattern letter is \u0027v\u0027 the output provides the zone name ignoring\n * daylight savings time. If the count of letters is one, then the short name is output.\n * If the count of letters is four, then the full name is output.\n * Two, three and five or more letters throw {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eOffset X and x\u003c/b\u003e: This formats the offset based on the number of pattern\n * letters. One letter outputs just the hour, such as \u0027+01\u0027, unless the minute\n * is non-zero in which case the minute is also output, such as \u0027+0130\u0027. Two\n * letters outputs the hour and minute, without a colon, such as \u0027+0130\u0027. Three\n * letters outputs the hour and minute, with a colon, such as \u0027+01:30\u0027. Four\n * letters outputs the hour and minute and optional second, without a colon,\n * such as \u0027+013015\u0027. Five letters outputs the hour and minute and optional\n * second, with a colon, such as \u0027+01:30:15\u0027. Six or more letters throws\n * {@code IllegalArgumentException}. Pattern letter \u0027X\u0027 (upper case) will output\n * \u0027Z\u0027 when the offset to be output would be zero, whereas pattern letter \u0027x\u0027\n * (lower case) will output \u0027+00\u0027, \u0027+0000\u0027, or \u0027+00:00\u0027.\n * \u003cp\u003e\n * \u003cb\u003eOffset O\u003c/b\u003e: This formats the localized offset based on the number of\n * pattern letters. One letter outputs the {@linkplain TextStyle#SHORT short}\n * form of the localized offset, which is localized offset text, such as \u0027GMT\u0027,\n * with hour without leading zero, optional 2-digit minute and second if\n * non-zero, and colon, for example \u0027GMT+8\u0027. Four letters outputs the\n * {@linkplain TextStyle#FULL full} form, which is localized offset text,\n * such as \u0027GMT, with 2-digit hour and minute field, optional second field\n * if non-zero, and colon, for example \u0027GMT+08:00\u0027. Any other count of letters\n * throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eOffset Z\u003c/b\u003e: This formats the offset based on the number of pattern\n * letters. One, two or three letters outputs the hour and minute, without a\n * colon, such as \u0027+0130\u0027. The output will be \u0027+0000\u0027 when the offset is zero.\n * Four letters outputs the {@linkplain TextStyle#FULL full} form of localized\n * offset, equivalent to four letters of Offset-O. The output will be the\n * corresponding localized offset text if the offset is zero. Five\n * letters outputs the hour, minute, with optional second if non-zero, with\n * colon. It outputs \u0027Z\u0027 if the offset is zero.\n * Six or more letters throws {@code IllegalArgumentException}.\n * \u003cp\u003e\n * \u003cb\u003eOptional section\u003c/b\u003e: The optional section markers work exactly like\n * calling {@link DateTimeFormatterBuilder#optionalStart()} and\n * {@link DateTimeFormatterBuilder#optionalEnd()}.\n * \u003cp\u003e\n * \u003cb\u003ePad modifier\u003c/b\u003e: Modifies the pattern that immediately follows to be\n * padded with spaces. The pad width is determined by the number of pattern\n * letters. This is the same as calling\n * {@link DateTimeFormatterBuilder#padNext(int)}.\n * \u003cp\u003e\n * For example, \u0027ppH\u0027 outputs the hour-of-day padded on the left with spaces to\n * a width of 2.\n * \u003cp\u003e\n * Any unrecognized letter is an error. Any non-letter character, other than\n * \u0027[\u0027, \u0027]\u0027, \u0027{\u0027, \u0027}\u0027, \u0027#\u0027 and the single quote will be output directly.\n * Despite this, it is recommended to use single quotes around all characters\n * that you want to output directly to ensure that future changes do not break\n * your application.\n *\n * \u003ch3 id\u003d\"resolving\"\u003eResolving\u003c/h3\u003e\n * Parsing is implemented as a two-phase operation.\n * First, the text is parsed using the layout defined by the formatter, producing\n * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.\n * Second, the parsed data is \u003cem\u003eresolved\u003c/em\u003e, by validating, combining and\n * simplifying the various fields into more useful ones.\n * \u003cp\u003e\n * Five parsing methods are supplied by this class.\n * Four of these perform both the parse and resolve phases.\n * The fifth method, {@link #parseUnresolved(CharSequence, ParsePosition)},\n * only performs the first phase, leaving the result unresolved.\n * As such, it is essentially a low-level operation.\n * \u003cp\u003e\n * The resolve phase is controlled by two parameters, set on this class.\n * \u003cp\u003e\n * The {@link ResolverStyle} is an enum that offers three different approaches,\n * strict, smart and lenient. The smart option is the default.\n * It can be set using {@link #withResolverStyle(ResolverStyle)}.\n * \u003cp\u003e\n * The {@link #withResolverFields(TemporalField...)} parameter allows the\n * set of fields that will be resolved to be filtered before resolving starts.\n * For example, if the formatter has parsed a year, month, day-of-month\n * and day-of-year, then there are two approaches to resolve a date:\n * (year + month + day-of-month) and (year + day-of-year).\n * The resolver fields allows one of the two approaches to be selected.\n * If no resolver fields are set then both approaches must result in the same date.\n * \u003cp\u003e\n * Resolving separate fields to form a complete date and time is a complex\n * process with behaviour distributed across a number of classes.\n * It follows these steps:\n * \u003col\u003e\n * \u003cli\u003eThe chronology is determined.\n * The chronology of the result is either the chronology that was parsed,\n * or if no chronology was parsed, it is the chronology set on this class,\n * or if that is null, it is {@code IsoChronology}.\n * \u003cli\u003eThe {@code ChronoField} date fields are resolved.\n * This is achieved using {@link Chronology#resolveDate(Map, ResolverStyle)}.\n * Documentation about field resolution is located in the implementation\n * of {@code Chronology}.\n * \u003cli\u003eThe {@code ChronoField} time fields are resolved.\n * This is documented on {@link ChronoField} and is the same for all chronologies.\n * \u003cli\u003eAny fields that are not {@code ChronoField} are processed.\n * This is achieved using {@link TemporalField#resolve(Map, TemporalAccessor, ResolverStyle)}.\n * Documentation about field resolution is located in the implementation\n * of {@code TemporalField}.\n * \u003cli\u003eThe {@code ChronoField} date and time fields are re-resolved.\n * This allows fields in step four to produce {@code ChronoField} values\n * and have them be processed into dates and times.\n * \u003cli\u003eA {@code LocalTime} is formed if there is at least an hour-of-day available.\n * This involves providing default values for minute, second and fraction of second.\n * \u003cli\u003eAny remaining unresolved fields are cross-checked against any\n * date and/or time that was resolved. Thus, an earlier stage would resolve\n * (year + month + day-of-month) to a date, and this stage would check that\n * day-of-week was valid for the date.\n * \u003cli\u003eIf an {@linkplain #parsedExcessDays() excess number of days}\n * was parsed then it is added to the date if a date is available.\n * \u003cli\u003e If a second-based field is present, but {@code LocalTime} was not parsed,\n * then the resolver ensures that milli, micro and nano second values are\n * available to meet the contract of {@link ChronoField}.\n * These will be set to zero if missing.\n * \u003cli\u003eIf both date and time were parsed and either an offset or zone is present,\n * the field {@link ChronoField#INSTANT_SECONDS} is created.\n * If an offset was parsed then the offset will be combined with the\n * {@code LocalDateTime} to form the instant, with any zone ignored.\n * If a {@code ZoneId} was parsed without an offset then the zone will be\n * combined with the {@code LocalDateTime} to form the instant using the rules\n * of {@link ChronoLocalDateTime#atZone(ZoneId)}.\n * \u003c/ol\u003e\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class DateTimeFormatter {\n\n    /**\n     * The printer and/or parser to use, not null.\n     */\n    private final CompositePrinterParser printerParser;\n    /**\n     * The locale to use for formatting, not null.\n     */\n    private final Locale locale;\n    /**\n     * The symbols to use for formatting, not null.\n     */\n    private final DecimalStyle decimalStyle;\n    /**\n     * The resolver style to use, not null.\n     */\n    private final ResolverStyle resolverStyle;\n    /**\n     * The fields to use in resolving, null for all fields.\n     */\n    private final Set\u003cTemporalField\u003e resolverFields;\n    /**\n     * The chronology to use for formatting, null for no override.\n     */\n    private final Chronology chrono;\n    /**\n     * The zone to use for formatting, null for no override.\n     */\n    private final ZoneId zone;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a formatter using the specified pattern.\n     * \u003cp\u003e\n     * This method will create a formatter based on a simple\n     * \u003ca href\u003d\"#patterns\"\u003epattern of letters and symbols\u003c/a\u003e\n     * as described in the class documentation.\n     * For example, {@code d MMM uuuu} will format 2011-12-03 as \u00273 Dec 2011\u0027.\n     * \u003cp\u003e\n     * The formatter will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * This can be changed using {@link DateTimeFormatter#withLocale(Locale)} on the returned formatter.\n     * Alternatively use the {@link #ofPattern(String, Locale)} variant of this method.\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses {@link ResolverStyle#SMART SMART} resolver style.\n     *\n     * @param pattern  the pattern to use, not null\n     * @return the formatter based on the pattern, not null\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormatterBuilder#appendPattern(String)\n     */\n    public static DateTimeFormatter ofPattern(String pattern) {\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n    }\n\n    /**\n     * Creates a formatter using the specified pattern and locale.\n     * \u003cp\u003e\n     * This method will create a formatter based on a simple\n     * \u003ca href\u003d\"#patterns\"\u003epattern of letters and symbols\u003c/a\u003e\n     * as described in the class documentation.\n     * For example, {@code d MMM uuuu} will format 2011-12-03 as \u00273 Dec 2011\u0027.\n     * \u003cp\u003e\n     * The formatter will use the specified locale.\n     * This can be changed using {@link DateTimeFormatter#withLocale(Locale)} on the returned formatter.\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses {@link ResolverStyle#SMART SMART} resolver style.\n     *\n     * @param pattern  the pattern to use, not null\n     * @param locale  the locale to use, not null\n     * @return the formatter based on the pattern, not null\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormatterBuilder#appendPattern(String)\n     */\n    public static DateTimeFormatter ofPattern(String pattern, Locale locale) {\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter(locale);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a locale specific date format for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a date.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     *\n     * @param dateStyle  the formatter style to obtain, not null\n     * @return the date formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedDate(FormatStyle dateStyle) {\n        Objects.requireNonNull(dateStyle, \"dateStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(dateStyle, null)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    /**\n     * Returns a locale specific time format for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a time.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     * The {@code FULL} and {@code LONG} styles typically require a time-zone.\n     * When formatting using these styles, a {@code ZoneId} must be available,\n     * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.\n     *\n     * @param timeStyle  the formatter style to obtain, not null\n     * @return the time formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedTime(FormatStyle timeStyle) {\n        Objects.requireNonNull(timeStyle, \"timeStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(null, timeStyle)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    /**\n     * Returns a locale specific date-time formatter for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a date-time.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     * The {@code FULL} and {@code LONG} styles typically require a time-zone.\n     * When formatting using these styles, a {@code ZoneId} must be available,\n     * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.\n     *\n     * @param dateTimeStyle  the formatter style to obtain, not null\n     * @return the date-time formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateTimeStyle) {\n        Objects.requireNonNull(dateTimeStyle, \"dateTimeStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(dateTimeStyle, dateTimeStyle)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    /**\n     * Returns a locale specific date and time format for the ISO chronology.\n     * \u003cp\u003e\n     * This returns a formatter that will format or parse a date-time.\n     * The exact format pattern used varies by locale.\n     * \u003cp\u003e\n     * The locale is determined from the formatter. The formatter returned directly by\n     * this method will use the {@link Locale#getDefault() default FORMAT locale}.\n     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}\n     * on the result of this method.\n     * \u003cp\u003e\n     * Note that the localized pattern is looked up lazily.\n     * This {@code DateTimeFormatter} holds the style required and the locale,\n     * looking up the pattern required on demand.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     * The {@code FULL} and {@code LONG} styles typically require a time-zone.\n     * When formatting using these styles, a {@code ZoneId} must be available,\n     * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.\n     *\n     * @param dateStyle  the date formatter style to obtain, not null\n     * @param timeStyle  the time formatter style to obtain, not null\n     * @return the date, time or date-time formatter, not null\n     */\n    public static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateStyle, FormatStyle timeStyle) {\n        Objects.requireNonNull(dateStyle, \"dateStyle\");\n        Objects.requireNonNull(timeStyle, \"timeStyle\");\n        return new DateTimeFormatterBuilder().appendLocalized(dateStyle, timeStyle)\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date without an\n     * offset, such as \u00272011-12-03\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended local date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits or more for the {@link ChronoField#YEAR year}.\n     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.\n     * Years outside that range will have a prefixed positive or negative symbol.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MONTH_OF_YEAR month-of-year}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eTwo digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_LOCAL_DATE;\n    static {\n        ISO_LOCAL_DATE \u003d new DateTimeFormatterBuilder()\n                .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(MONTH_OF_YEAR, 2)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(DAY_OF_MONTH, 2)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date with an\n     * offset, such as \u00272011-12-03+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE}\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_OFFSET_DATE;\n    static {\n        ISO_OFFSET_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE)\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date with the\n     * offset if available, such as \u00272011-12-03\u0027 or \u00272011-12-03+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE}\n     * \u003cli\u003eIf the offset is not available then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_DATE;\n    static {\n        ISO_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO time formatter that formats or parses a time without an\n     * offset, such as \u002710:15\u0027 or \u002710:15:30\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended local time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eTwo digits for the {@link ChronoField#HOUR_OF_DAY hour-of-day}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MINUTE_OF_HOUR minute-of-hour}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the second-of-minute is not available then the format is complete.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#SECOND_OF_MINUTE second-of-minute}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the nano-of-second is zero or not available then the format is complete.\n     * \u003cli\u003eA decimal point\n     * \u003cli\u003eOne to nine digits for the {@link ChronoField#NANO_OF_SECOND nano-of-second}.\n     *  As many digits will be output as required.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_LOCAL_TIME;\n    static {\n        ISO_LOCAL_TIME \u003d new DateTimeFormatterBuilder()\n                .appendValue(HOUR_OF_DAY, 2)\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(MINUTE_OF_HOUR, 2)\n                .optionalStart()\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(SECOND_OF_MINUTE, 2)\n                .optionalStart()\n                .appendFraction(NANO_OF_SECOND, 0, 9, true)\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO time formatter that formats or parses a time with an\n     * offset, such as \u002710:15+01:00\u0027 or \u002710:15:30+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_TIME}\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_OFFSET_TIME;\n    static {\n        ISO_OFFSET_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_TIME)\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO time formatter that formats or parses a time, with the\n     * offset if available, such as \u002710:15\u0027, \u002710:15:30\u0027 or \u002710:15:30+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_TIME}\n     * \u003cli\u003eIf the offset is not available then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_TIME;\n    static {\n        ISO_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_TIME)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date-time formatter that formats or parses a date-time without\n     * an offset, such as \u00272011-12-03T10:15:30\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset date-time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE}\n     * \u003cli\u003eThe letter \u0027T\u0027. Parsing is case insensitive.\n     * \u003cli\u003eThe {@link #ISO_LOCAL_TIME}\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_LOCAL_DATE_TIME;\n    static {\n        ISO_LOCAL_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE)\n                .appendLiteral(\u0027T\u0027)\n                .append(ISO_LOCAL_TIME)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date-time formatter that formats or parses a date-time with an\n     * offset, such as \u00272011-12-03T10:15:30+01:00\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended offset date-time format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE_TIME}\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  The offset parsing is lenient, which allows the minutes and seconds to be optional.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_OFFSET_DATE_TIME;\n    static {\n        ISO_OFFSET_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .append(ISO_LOCAL_DATE_TIME)\n                .parseLenient()\n                .appendOffsetId()\n                .parseStrict()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO-like date-time formatter that formats or parses a date-time with\n     * offset and zone, such as \u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * a format that extends the ISO-8601 extended offset date-time format\n     * to add the time-zone.\n     * The section in square brackets is not part of the ISO-8601 standard.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_OFFSET_DATE_TIME}\n     * \u003cli\u003eIf the zone ID is not available or is a {@code ZoneOffset} then the format is complete.\n     * \u003cli\u003eAn open square bracket \u0027[\u0027.\n     * \u003cli\u003eThe {@link ZoneId#getId() zone ID}. This is not part of the ISO-8601 standard.\n     *  Parsing is case sensitive.\n     * \u003cli\u003eA close square bracket \u0027]\u0027.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_ZONED_DATE_TIME;\n    static {\n        ISO_ZONED_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .append(ISO_OFFSET_DATE_TIME)\n                .optionalStart()\n                .appendLiteral(\u0027[\u0027)\n                .parseCaseSensitive()\n                .appendZoneRegionId()\n                .appendLiteral(\u0027]\u0027)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO-like date-time formatter that formats or parses a date-time with\n     * the offset and zone if available, such as \u00272011-12-03T10:15:30\u0027,\n     * \u00272011-12-03T10:15:30+01:00\u0027 or \u00272011-12-03T10:15:30+01:00[Europe/Paris]\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended local or offset date-time format, as well as the\n     * extended non-ISO form specifying the time-zone.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_LOCAL_DATE_TIME}\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     * \u003cli\u003eIf the zone ID is not available or is a {@code ZoneOffset} then the format is complete.\n     * \u003cli\u003eAn open square bracket \u0027[\u0027.\n     * \u003cli\u003eThe {@link ZoneId#getId() zone ID}. This is not part of the ISO-8601 standard.\n     *  Parsing is case sensitive.\n     * \u003cli\u003eA close square bracket \u0027]\u0027.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_DATE_TIME;\n    static {\n        ISO_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .append(ISO_LOCAL_DATE_TIME)\n                .optionalStart()\n                .appendOffsetId()\n                .optionalStart()\n                .appendLiteral(\u0027[\u0027)\n                .parseCaseSensitive()\n                .appendZoneRegionId()\n                .appendLiteral(\u0027]\u0027)\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses the ordinal date\n     * without an offset, such as \u00272012-337\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended ordinal date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits or more for the {@link ChronoField#YEAR year}.\n     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.\n     * Years outside that range will have a prefixed positive or negative symbol.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eThree digits for the {@link ChronoField#DAY_OF_YEAR day-of-year}.\n     *  This is pre-padded by zero to ensure three digits.\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_ORDINAL_DATE;\n    static {\n        ISO_ORDINAL_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(DAY_OF_YEAR, 3)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses the week-based date\n     * without an offset, such as \u00272012-W48-6\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 extended week-based date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits or more for the {@link IsoFields#WEEK_BASED_YEAR week-based-year}.\n     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.\n     * Years outside that range will have a prefixed positive or negative symbol.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eThe letter \u0027W\u0027. Parsing is case insensitive.\n     * \u003cli\u003eTwo digits for the {@link IsoFields#WEEK_OF_WEEK_BASED_YEAR week-of-week-based-year}.\n     *  This is pre-padded by zero to ensure three digits.\n     * \u003cli\u003eA dash\n     * \u003cli\u003eOne digit for the {@link ChronoField#DAY_OF_WEEK day-of-week}.\n     *  The value run from Monday (1) to Sunday (7).\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID}. If the offset has seconds then\n     *  they will be handled even though this is not part of the ISO-8601 standard.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_WEEK_DATE;\n    static {\n        ISO_WEEK_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendValue(IsoFields.WEEK_BASED_YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n                .appendLiteral(\"-W\")\n                .appendValue(IsoFields.WEEK_OF_WEEK_BASED_YEAR, 2)\n                .appendLiteral(\u0027-\u0027)\n                .appendValue(DAY_OF_WEEK, 1)\n                .optionalStart()\n                .appendOffsetId()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO instant formatter that formats or parses an instant in UTC,\n     * such as \u00272011-12-03T10:15:30Z\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 instant format.\n     * When formatting, the second-of-minute is always output.\n     * The nano-of-second outputs zero, three, six or nine digits as necessary.\n     * When parsing, time to at least the seconds field is required.\n     * Fractional seconds from zero to nine are parsed.\n     * The localized decimal style is not used.\n     * \u003cp\u003e\n     * This is a special case formatter intended to allow a human readable form\n     * of an {@link java.time.Instant}. The {@code Instant} class is designed to\n     * only represent a point in time and internally stores a value in nanoseconds\n     * from a fixed epoch of 1970-01-01Z. As such, an {@code Instant} cannot be\n     * formatted as a date or time without providing some form of time-zone.\n     * This formatter allows the {@code Instant} to be formatted, by providing\n     * a suitable conversion using {@code ZoneOffset.UTC}.\n     * \u003cp\u003e\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@link #ISO_OFFSET_DATE_TIME} where the instant is converted from\n     *  {@link ChronoField#INSTANT_SECONDS} and {@link ChronoField#NANO_OF_SECOND}\n     *  using the {@code UTC} offset. Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The returned formatter has no override chronology or zone.\n     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter ISO_INSTANT;\n    static {\n        ISO_INSTANT \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendInstant()\n                .toFormatter(ResolverStyle.STRICT, null);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The ISO date formatter that formats or parses a date without an\n     * offset, such as \u002720111203\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * the ISO-8601 basic local date format.\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eFour digits for the {@link ChronoField#YEAR year}.\n     *  Only years in the range 0000 to 9999 are supported.\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MONTH_OF_YEAR month-of-year}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eTwo digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the offset is not available to format or parse then the format is complete.\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID} without colons. If the offset has\n     *  seconds then they will be handled even though this is not part of the ISO-8601 standard.\n     *  The offset parsing is lenient, which allows the minutes and seconds to be optional.\n     *  Parsing is case insensitive.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * As this formatter has an optional element, it may be necessary to parse using\n     * {@link DateTimeFormatter#parseBest}.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.\n     */\n    public static final DateTimeFormatter BASIC_ISO_DATE;\n    static {\n        BASIC_ISO_DATE \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .appendValue(YEAR, 4)\n                .appendValue(MONTH_OF_YEAR, 2)\n                .appendValue(DAY_OF_MONTH, 2)\n                .optionalStart()\n                .parseLenient()\n                .appendOffset(\"+HHMMss\", \"Z\")\n                .parseStrict()\n                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * The RFC-1123 date-time formatter, such as \u0027Tue, 3 Jun 2008 11:05:30 GMT\u0027.\n     * \u003cp\u003e\n     * This returns an immutable formatter capable of formatting and parsing\n     * most of the RFC-1123 format.\n     * RFC-1123 updates RFC-822 changing the year from two digits to four.\n     * This implementation requires a four digit year.\n     * This implementation also does not handle North American or military zone\n     * names, only \u0027GMT\u0027 and offset amounts.\n     * \u003cp\u003e\n     * The format consists of:\n     * \u003cul\u003e\n     * \u003cli\u003eIf the day-of-week is not available to format or parse then jump to day-of-month.\n     * \u003cli\u003eThree letter {@link ChronoField#DAY_OF_WEEK day-of-week} in English.\n     * \u003cli\u003eA comma\n     * \u003cli\u003eA space\n     * \u003cli\u003eOne or two digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.\n     * \u003cli\u003eA space\n     * \u003cli\u003eThree letter {@link ChronoField#MONTH_OF_YEAR month-of-year} in English.\n     * \u003cli\u003eA space\n     * \u003cli\u003eFour digits for the {@link ChronoField#YEAR year}.\n     *  Only years in the range 0000 to 9999 are supported.\n     * \u003cli\u003eA space\n     * \u003cli\u003eTwo digits for the {@link ChronoField#HOUR_OF_DAY hour-of-day}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#MINUTE_OF_HOUR minute-of-hour}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eIf the second-of-minute is not available then jump to the next space.\n     * \u003cli\u003eA colon\n     * \u003cli\u003eTwo digits for the {@link ChronoField#SECOND_OF_MINUTE second-of-minute}.\n     *  This is pre-padded by zero to ensure two digits.\n     * \u003cli\u003eA space\n     * \u003cli\u003eThe {@link ZoneOffset#getId() offset ID} without colons or seconds.\n     *  An offset of zero uses \"GMT\". North American zone names and military zone names are not handled.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Parsing is case insensitive.\n     * \u003cp\u003e\n     * The returned formatter has a chronology of ISO set to ensure dates in\n     * other calendar systems are correctly converted.\n     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.\n     */\n    public static final DateTimeFormatter RFC_1123_DATE_TIME;\n    static {\n        // manually code maps to ensure correct data always used\n        // (locale data can be changed by application code)\n        Map\u003cLong, String\u003e dow \u003d new HashMap\u003c\u003e();\n        dow.put(1L, \"Mon\");\n        dow.put(2L, \"Tue\");\n        dow.put(3L, \"Wed\");\n        dow.put(4L, \"Thu\");\n        dow.put(5L, \"Fri\");\n        dow.put(6L, \"Sat\");\n        dow.put(7L, \"Sun\");\n        Map\u003cLong, String\u003e moy \u003d new HashMap\u003c\u003e();\n        moy.put(1L, \"Jan\");\n        moy.put(2L, \"Feb\");\n        moy.put(3L, \"Mar\");\n        moy.put(4L, \"Apr\");\n        moy.put(5L, \"May\");\n        moy.put(6L, \"Jun\");\n        moy.put(7L, \"Jul\");\n        moy.put(8L, \"Aug\");\n        moy.put(9L, \"Sep\");\n        moy.put(10L, \"Oct\");\n        moy.put(11L, \"Nov\");\n        moy.put(12L, \"Dec\");\n        RFC_1123_DATE_TIME \u003d new DateTimeFormatterBuilder()\n                .parseCaseInsensitive()\n                .parseLenient()\n                .optionalStart()\n                .appendText(DAY_OF_WEEK, dow)\n                .appendLiteral(\", \")\n                .optionalEnd()\n                .appendValue(DAY_OF_MONTH, 1, 2, SignStyle.NOT_NEGATIVE)\n                .appendLiteral(\u0027 \u0027)\n                .appendText(MONTH_OF_YEAR, moy)\n                .appendLiteral(\u0027 \u0027)\n                .appendValue(YEAR, 4)  // 2 digit year not handled\n                .appendLiteral(\u0027 \u0027)\n                .appendValue(HOUR_OF_DAY, 2)\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(MINUTE_OF_HOUR, 2)\n                .optionalStart()\n                .appendLiteral(\u0027:\u0027)\n                .appendValue(SECOND_OF_MINUTE, 2)\n                .optionalEnd()\n                .appendLiteral(\u0027 \u0027)\n                .appendOffset(\"+HHMM\", \"GMT\")  // should handle UT/Z/EST/EDT/CST/CDT/MST/MDT/PST/MDT\n                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * A query that provides access to the excess days that were parsed.\n     * \u003cp\u003e\n     * This returns a singleton {@linkplain TemporalQuery query} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null period, with a zero period returned instead of null.\n     * \u003cp\u003e\n     * There are two situations where this query may return a non-zero period.\n     * \u003cul\u003e\n     * \u003cli\u003eIf the {@code ResolverStyle} is {@code LENIENT} and a time is parsed\n     *  without a date, then the complete result of the parse consists of a\n     *  {@code LocalTime} and an excess {@code Period} in days.\n     *\n     * \u003cli\u003eIf the {@code ResolverStyle} is {@code SMART} and a time is parsed\n     *  without a date where the time is 24:00:00, then the complete result of\n     *  the parse consists of a {@code LocalTime} of 00:00:00 and an excess\n     *  {@code Period} of one day.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * In both cases, if a complete {@code ChronoLocalDateTime} or {@code Instant}\n     * is parsed, then the excess days are added to the date part.\n     * As a result, this query will return a zero period.\n     * \u003cp\u003e\n     * The {@code SMART} behaviour handles the common \"end of day\" 24:00 value.\n     * Processing in {@code LENIENT} mode also produces the same result:\n     * \u003cpre\u003e\n     *  Text to parse        Parsed object                         Excess days\n     *  \"2012-12-03T00:00\"   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO\n     *  \"2012-12-03T24:00\"   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO\n     *  \"00:00\"              LocalTime.of(0, 0)                    ZERO\n     *  \"24:00\"              LocalTime.of(0, 0)                    Period.ofDays(1)\n     * \u003c/pre\u003e\n     * The query can be used as follows:\n     * \u003cpre\u003e\n     *  TemporalAccessor parsed \u003d formatter.parse(str);\n     *  LocalTime time \u003d parsed.query(LocalTime::from);\n     *  Period extraDays \u003d parsed.query(DateTimeFormatter.parsedExcessDays());\n     * \u003c/pre\u003e\n     * @return a query that provides access to the excess days that were parsed\n     */\n    public static final TemporalQuery\u003cPeriod\u003e parsedExcessDays() {\n        return PARSED_EXCESS_DAYS;\n    }\n    private static final TemporalQuery\u003cPeriod\u003e PARSED_EXCESS_DAYS \u003d t -\u003e {\n        if (t instanceof Parsed) {\n            return ((Parsed) t).excessDays;\n        } else {\n            return Period.ZERO;\n        }\n    };\n\n    /**\n     * A query that provides access to whether a leap-second was parsed.\n     * \u003cp\u003e\n     * This returns a singleton {@linkplain TemporalQuery query} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null boolean, true if parsing saw a leap-second, false if not.\n     * \u003cp\u003e\n     * Instant parsing handles the special \"leap second\" time of \u002723:59:60\u0027.\n     * Leap seconds occur at \u002723:59:60\u0027 in the UTC time-zone, but at other\n     * local times in different time-zones. To avoid this potential ambiguity,\n     * the handling of leap-seconds is limited to\n     * {@link DateTimeFormatterBuilder#appendInstant()}, as that method\n     * always parses the instant with the UTC zone offset.\n     * \u003cp\u003e\n     * If the time \u002723:59:60\u0027 is received, then a simple conversion is applied,\n     * replacing the second-of-minute of 60 with 59. This query can be used\n     * on the parse result to determine if the leap-second adjustment was made.\n     * The query will return {@code true} if it did adjust to remove the\n     * leap-second, and {@code false} if not. Note that applying a leap-second\n     * smoothing mechanism, such as UTC-SLS, is the responsibility of the\n     * application, as follows:\n     * \u003cpre\u003e\n     *  TemporalAccessor parsed \u003d formatter.parse(str);\n     *  Instant instant \u003d parsed.query(Instant::from);\n     *  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {\n     *    // validate leap-second is correct and apply correct smoothing\n     *  }\n     * \u003c/pre\u003e\n     * @return a query that provides access to whether a leap-second was parsed\n     */\n    public static final TemporalQuery\u003cBoolean\u003e parsedLeapSecond() {\n        return PARSED_LEAP_SECOND;\n    }\n    private static final TemporalQuery\u003cBoolean\u003e PARSED_LEAP_SECOND \u003d t -\u003e {\n        if (t instanceof Parsed) {\n            return ((Parsed) t).leapSecond;\n        } else {\n            return Boolean.FALSE;\n        }\n    };\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param printerParser  the printer/parser to use, not null\n     * @param locale  the locale to use, not null\n     * @param decimalStyle  the DecimalStyle to use, not null\n     * @param resolverStyle  the resolver style to use, not null\n     * @param resolverFields  the fields to use during resolving, null for all fields\n     * @param chrono  the chronology to use, null for no override\n     * @param zone  the zone to use, null for no override\n     */\n    DateTimeFormatter(CompositePrinterParser printerParser,\n            Locale locale, DecimalStyle decimalStyle,\n            ResolverStyle resolverStyle, Set\u003cTemporalField\u003e resolverFields,\n            Chronology chrono, ZoneId zone) {\n        this.printerParser \u003d Objects.requireNonNull(printerParser, \"printerParser\");\n        this.resolverFields \u003d resolverFields;\n        this.locale \u003d Objects.requireNonNull(locale, \"locale\");\n        this.decimalStyle \u003d Objects.requireNonNull(decimalStyle, \"decimalStyle\");\n        this.resolverStyle \u003d Objects.requireNonNull(resolverStyle, \"resolverStyle\");\n        this.chrono \u003d chrono;\n        this.zone \u003d zone;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the locale to be used during formatting.\n     * \u003cp\u003e\n     * This is used to lookup any part of the formatter needing specific\n     * localization, such as the text or localized pattern.\n     *\n     * @return the locale of this formatter, not null\n     */\n    public Locale getLocale() {\n        return locale;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new locale.\n     * \u003cp\u003e\n     * This is used to lookup any part of the formatter needing specific\n     * localization, such as the text or localized pattern.\n     * \u003cp\u003e\n     * The locale is stored as passed in, without further processing.\n     * If the locale has \u003ca href\u003d\"../../util/Locale.html#def_locale_extension\"\u003e\n     * Unicode extensions\u003c/a\u003e, they may be used later in text\n     * processing. To set the chronology, time-zone and decimal style from\n     * unicode extensions, see {@link #localizedBy localizedBy()}.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param locale  the new locale, not null\n     * @return a formatter based on this formatter with the requested locale, not null\n     * @see #localizedBy(Locale)\n     */\n    public DateTimeFormatter withLocale(Locale locale) {\n        if (this.locale.equals(locale)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    /**\n     * Returns a copy of this formatter with localized values of the locale,\n     * calendar, region, decimal style and/or timezone, that supercede values in\n     * this formatter.\n     * \u003cp\u003e\n     * This is used to lookup any part of the formatter needing specific\n     * localization, such as the text or localized pattern. If the locale contains the\n     * \"ca\" (calendar), \"nu\" (numbering system), \"rg\" (region override), and/or\n     * \"tz\" (timezone)\n     * \u003ca href\u003d\"../../util/Locale.html#def_locale_extension\"\u003eUnicode extensions\u003c/a\u003e,\n     * the chronology, numbering system and/or the zone are overridden. If both \"ca\"\n     * and \"rg\" are specified, the chronology from the \"ca\" extension supersedes the\n     * implicit one from the \"rg\" extension. Same is true for the \"nu\" extension.\n     * \u003cp\u003e\n     * Unlike the {@link #withLocale withLocale} method, the call to this method may\n     * produce a different formatter depending on the order of method chaining with\n     * other withXXXX() methods.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param locale  the locale, not null\n     * @return a formatter based on this formatter with localized values of\n     *      the calendar, decimal style and/or timezone, that supercede values in this\n     *      formatter.\n     * @see #withLocale(Locale)\n     * @since 10\n     */\n    public DateTimeFormatter localizedBy(Locale locale) {\n        if (this.locale.equals(locale)) {\n            return this;\n        }\n\n        // Check for decimalStyle/chronology/timezone in locale object\n        Chronology c \u003d locale.getUnicodeLocaleType(\"ca\") !\u003d null ?\n                       Chronology.ofLocale(locale) : chrono;\n        DecimalStyle ds \u003d locale.getUnicodeLocaleType(\"nu\") !\u003d null ?\n                       DecimalStyle.of(locale) : decimalStyle;\n        String tzType \u003d locale.getUnicodeLocaleType(\"tz\");\n        ZoneId z  \u003d tzType !\u003d null ?\n                    TimeZoneNameUtility.convertLDMLShortID(tzType)\n                        .map(ZoneId::of)\n                        .orElse(zone) :\n                    zone;\n        return new DateTimeFormatter(printerParser, locale, ds, resolverStyle, resolverFields, c, z);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the DecimalStyle to be used during formatting.\n     *\n     * @return the locale of this formatter, not null\n     */\n    public DecimalStyle getDecimalStyle() {\n        return decimalStyle;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new DecimalStyle.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param decimalStyle  the new DecimalStyle, not null\n     * @return a formatter based on this formatter with the requested DecimalStyle, not null\n     */\n    public DateTimeFormatter withDecimalStyle(DecimalStyle decimalStyle) {\n        if (this.decimalStyle.equals(decimalStyle)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the overriding chronology to be used during formatting.\n     * \u003cp\u003e\n     * This returns the override chronology, used to convert dates.\n     * By default, a formatter has no override chronology, returning null.\n     * See {@link #withChronology(Chronology)} for more details on overriding.\n     *\n     * @return the override chronology of this formatter, null if no override\n     */\n    public Chronology getChronology() {\n        return chrono;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new override chronology.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but\n     * with the override chronology set.\n     * By default, a formatter has no override chronology, returning null.\n     * \u003cp\u003e\n     * If an override is added, then any date that is formatted or parsed will be affected.\n     * \u003cp\u003e\n     * When formatting, if the temporal object contains a date, then it will\n     * be converted to a date in the override chronology.\n     * Whether the temporal contains a date is determined by querying the\n     * {@link ChronoField#EPOCH_DAY EPOCH_DAY} field.\n     * Any time or zone will be retained unaltered unless overridden.\n     * \u003cp\u003e\n     * If the temporal object does not contain a date, but does contain one\n     * or more {@code ChronoField} date fields, then a {@code DateTimeException}\n     * is thrown. In all other cases, the override chronology is added to the temporal,\n     * replacing any previous chronology, but without changing the date/time.\n     * \u003cp\u003e\n     * When parsing, there are two distinct cases to consider.\n     * If a chronology has been parsed directly from the text, perhaps because\n     * {@link DateTimeFormatterBuilder#appendChronologyId()} was used, then\n     * this override chronology has no effect.\n     * If no zone has been parsed, then this override chronology will be used\n     * to interpret the {@code ChronoField} values into a date according to the\n     * date resolving rules of the chronology.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param chrono  the new chronology, null if no override\n     * @return a formatter based on this formatter with the requested override chronology, not null\n     */\n    public DateTimeFormatter withChronology(Chronology chrono) {\n        if (Objects.equals(this.chrono, chrono)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the overriding zone to be used during formatting.\n     * \u003cp\u003e\n     * This returns the override zone, used to convert instants.\n     * By default, a formatter has no override zone, returning null.\n     * See {@link #withZone(ZoneId)} for more details on overriding.\n     *\n     * @return the override zone of this formatter, null if no override\n     */\n    public ZoneId getZone() {\n        return zone;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new override zone.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but\n     * with the override zone set.\n     * By default, a formatter has no override zone, returning null.\n     * \u003cp\u003e\n     * If an override is added, then any instant that is formatted or parsed will be affected.\n     * \u003cp\u003e\n     * When formatting, if the temporal object contains an instant, then it will\n     * be converted to a zoned date-time using the override zone.\n     * Whether the temporal is an instant is determined by querying the\n     * {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS} field.\n     * If the input has a chronology then it will be retained unless overridden.\n     * If the input does not have a chronology, such as {@code Instant}, then\n     * the ISO chronology will be used.\n     * \u003cp\u003e\n     * If the temporal object does not contain an instant, but does contain\n     * an offset then an additional check is made. If the normalized override\n     * zone is an offset that differs from the offset of the temporal, then\n     * a {@code DateTimeException} is thrown. In all other cases, the override\n     * zone is added to the temporal, replacing any previous zone, but without\n     * changing the date/time.\n     * \u003cp\u003e\n     * When parsing, there are two distinct cases to consider.\n     * If a zone has been parsed directly from the text, perhaps because\n     * {@link DateTimeFormatterBuilder#appendZoneId()} was used, then\n     * this override zone has no effect.\n     * If no zone has been parsed, then this override zone will be included in\n     * the result of the parse where it can be used to build instants and date-times.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param zone  the new override zone, null if no override\n     * @return a formatter based on this formatter with the requested override zone, not null\n     */\n    public DateTimeFormatter withZone(ZoneId zone) {\n        if (Objects.equals(this.zone, zone)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the resolver style to use during parsing.\n     * \u003cp\u003e\n     * This returns the resolver style, used during the second phase of parsing\n     * when fields are resolved into dates and times.\n     * By default, a formatter has the {@link ResolverStyle#SMART SMART} resolver style.\n     * See {@link #withResolverStyle(ResolverStyle)} for more details.\n     *\n     * @return the resolver style of this formatter, not null\n     */\n    public ResolverStyle getResolverStyle() {\n        return resolverStyle;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new resolver style.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but\n     * with the resolver style set. By default, a formatter has the\n     * {@link ResolverStyle#SMART SMART} resolver style.\n     * \u003cp\u003e\n     * Changing the resolver style only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver style is used to control how phase 2, resolving, happens.\n     * See {@code ResolverStyle} for more information on the options available.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param resolverStyle  the new resolver style, not null\n     * @return a formatter based on this formatter with the requested resolver style, not null\n     */\n    public DateTimeFormatter withResolverStyle(ResolverStyle resolverStyle) {\n        Objects.requireNonNull(resolverStyle, \"resolverStyle\");\n        if (Objects.equals(this.resolverStyle, resolverStyle)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the resolver fields to use during parsing.\n     * \u003cp\u003e\n     * This returns the resolver fields, used during the second phase of parsing\n     * when fields are resolved into dates and times.\n     * By default, a formatter has no resolver fields, and thus returns null.\n     * See {@link #withResolverFields(Set)} for more details.\n     *\n     * @return the immutable set of resolver fields of this formatter, null if no fields\n     */\n    public Set\u003cTemporalField\u003e getResolverFields() {\n        return resolverFields;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new set of resolver fields.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but with\n     * the resolver fields set. By default, a formatter has no resolver fields.\n     * \u003cp\u003e\n     * Changing the resolver fields only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver fields are used to filter the field-value pairs between phase 1 and 2.\n     * \u003cp\u003e\n     * This can be used to select between two or more ways that a date or time might\n     * be resolved. For example, if the formatter consists of year, month, day-of-month\n     * and day-of-year, then there are two ways to resolve a date.\n     * Calling this method with the arguments {@link ChronoField#YEAR YEAR} and\n     * {@link ChronoField#DAY_OF_YEAR DAY_OF_YEAR} will ensure that the date is\n     * resolved using the year and day-of-year, effectively meaning that the month\n     * and day-of-month are ignored during the resolving phase.\n     * \u003cp\u003e\n     * In a similar manner, this method can be used to ignore secondary fields that\n     * would otherwise be cross-checked. For example, if the formatter consists of year,\n     * month, day-of-month and day-of-week, then there is only one way to resolve a\n     * date, but the parsed value for day-of-week will be cross-checked against the\n     * resolved date. Calling this method with the arguments {@link ChronoField#YEAR YEAR},\n     * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and\n     * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} will ensure that the date is\n     * resolved correctly, but without any cross-check for the day-of-week.\n     * \u003cp\u003e\n     * In implementation terms, this method behaves as follows. The result of the\n     * parsing phase can be considered to be a map of field to value. The behavior\n     * of this method is to cause that map to be filtered between phase 1 and 2,\n     * removing all fields other than those specified as arguments to this method.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param resolverFields  the new set of resolver fields, null if no fields\n     * @return a formatter based on this formatter with the requested resolver style, not null\n     */\n    public DateTimeFormatter withResolverFields(TemporalField... resolverFields) {\n        Set\u003cTemporalField\u003e fields \u003d null;\n        if (resolverFields !\u003d null) {\n            // Set.of cannot be used because it is hostile to nulls and duplicate elements\n            fields \u003d Collections.unmodifiableSet(new HashSet\u003c\u003e(Arrays.asList(resolverFields)));\n        }\n        if (Objects.equals(this.resolverFields, fields)) {\n            return this;\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, fields, chrono, zone);\n    }\n\n    /**\n     * Returns a copy of this formatter with a new set of resolver fields.\n     * \u003cp\u003e\n     * This returns a formatter with similar state to this formatter but with\n     * the resolver fields set. By default, a formatter has no resolver fields.\n     * \u003cp\u003e\n     * Changing the resolver fields only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver fields are used to filter the field-value pairs between phase 1 and 2.\n     * \u003cp\u003e\n     * This can be used to select between two or more ways that a date or time might\n     * be resolved. For example, if the formatter consists of year, month, day-of-month\n     * and day-of-year, then there are two ways to resolve a date.\n     * Calling this method with the arguments {@link ChronoField#YEAR YEAR} and\n     * {@link ChronoField#DAY_OF_YEAR DAY_OF_YEAR} will ensure that the date is\n     * resolved using the year and day-of-year, effectively meaning that the month\n     * and day-of-month are ignored during the resolving phase.\n     * \u003cp\u003e\n     * In a similar manner, this method can be used to ignore secondary fields that\n     * would otherwise be cross-checked. For example, if the formatter consists of year,\n     * month, day-of-month and day-of-week, then there is only one way to resolve a\n     * date, but the parsed value for day-of-week will be cross-checked against the\n     * resolved date. Calling this method with the arguments {@link ChronoField#YEAR YEAR},\n     * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and\n     * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} will ensure that the date is\n     * resolved correctly, but without any cross-check for the day-of-week.\n     * \u003cp\u003e\n     * In implementation terms, this method behaves as follows. The result of the\n     * parsing phase can be considered to be a map of field to value. The behavior\n     * of this method is to cause that map to be filtered between phase 1 and 2,\n     * removing all fields other than those specified as arguments to this method.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param resolverFields  the new set of resolver fields, null if no fields\n     * @return a formatter based on this formatter with the requested resolver style, not null\n     */\n    public DateTimeFormatter withResolverFields(Set\u003cTemporalField\u003e resolverFields) {\n        if (Objects.equals(this.resolverFields, resolverFields)) {\n            return this;\n        }\n        if (resolverFields !\u003d null) {\n            resolverFields \u003d Collections.unmodifiableSet(new HashSet\u003c\u003e(resolverFields));\n        }\n        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats a date-time object using this formatter.\n     * \u003cp\u003e\n     * This formats the date-time to a String using the rules of the formatter.\n     *\n     * @param temporal  the temporal object to format, not null\n     * @return the formatted string, not null\n     * @throws DateTimeException if an error occurs during formatting\n     */\n    public String format(TemporalAccessor temporal) {\n        StringBuilder buf \u003d new StringBuilder(32);\n        formatTo(temporal, buf);\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats a date-time object to an {@code Appendable} using this formatter.\n     * \u003cp\u003e\n     * This outputs the formatted date-time to the specified destination.\n     * {@link Appendable} is a general purpose interface that is implemented by all\n     * key character output classes including {@code StringBuffer}, {@code StringBuilder},\n     * {@code PrintStream} and {@code Writer}.\n     * \u003cp\u003e\n     * Although {@code Appendable} methods throw an {@code IOException}, this method does not.\n     * Instead, any {@code IOException} is wrapped in a runtime exception.\n     *\n     * @param temporal  the temporal object to format, not null\n     * @param appendable  the appendable to format to, not null\n     * @throws DateTimeException if an error occurs during formatting\n     */\n    public void formatTo(TemporalAccessor temporal, Appendable appendable) {\n        Objects.requireNonNull(temporal, \"temporal\");\n        Objects.requireNonNull(appendable, \"appendable\");\n        try {\n            DateTimePrintContext context \u003d new DateTimePrintContext(temporal, this);\n            if (appendable instanceof StringBuilder) {\n                printerParser.format(context, (StringBuilder) appendable);\n            } else {\n                // buffer output to avoid writing to appendable in case of error\n                StringBuilder buf \u003d new StringBuilder(32);\n                printerParser.format(context, buf);\n                appendable.append(buf);\n            }\n        } catch (IOException ex) {\n            throw new DateTimeException(ex.getMessage(), ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Fully parses the text producing a temporal object.\n     * \u003cp\u003e\n     * This parses the entire text producing a temporal object.\n     * It is typically more useful to use {@link #parse(CharSequence, TemporalQuery)}.\n     * The result of this method is {@code TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     * \u003cp\u003e\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    public TemporalAccessor parse(CharSequence text) {\n        Objects.requireNonNull(text, \"text\");\n        try {\n            return parseResolved0(text, null);\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    /**\n     * Parses the text using this formatter, providing control over the text position.\n     * \u003cp\u003e\n     * This parses the text without requiring the parse to start from the beginning\n     * of the string or finish at the end.\n     * The result of this method is {@code TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     * \u003cp\u003e\n     * The text will be parsed from the specified start {@code ParsePosition}.\n     * The entire length of the text does not have to be parsed, the {@code ParsePosition}\n     * will be updated with the index at the end of parsing.\n     * \u003cp\u003e\n     * The operation of this method is slightly different to similar methods using\n     * {@code ParsePosition} on {@code java.text.Format}. That class will return\n     * errors using the error index on the {@code ParsePosition}. By contrast, this\n     * method will throw a {@link DateTimeParseException} if an error occurs, with\n     * the exception containing the error index.\n     * This change in behavior is necessary due to the increased complexity of\n     * parsing and resolving dates/times in this API.\n     * \u003cp\u003e\n     * If the formatter parses the same field more than once with different values,\n     * the result will be an error.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, not null\n     * @return the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    public TemporalAccessor parse(CharSequence text, ParsePosition position) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(position, \"position\");\n        try {\n            return parseResolved0(text, position);\n        } catch (DateTimeParseException | IndexOutOfBoundsException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Fully parses the text producing an object of the specified type.\n     * \u003cp\u003e\n     * Most applications should use this method for parsing.\n     * It parses the entire text to produce the required date-time.\n     * The query is typically a method reference to a {@code from(TemporalAccessor)} method.\n     * For example:\n     * \u003cpre\u003e\n     *  LocalDateTime dt \u003d parser.parse(str, LocalDateTime::from);\n     * \u003c/pre\u003e\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param \u003cT\u003e the type of the parsed date-time\n     * @param text  the text to parse, not null\n     * @param query  the query defining the type to parse to, not null\n     * @return the parsed date-time, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    public \u003cT\u003e T parse(CharSequence text, TemporalQuery\u003cT\u003e query) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(query, \"query\");\n        try {\n            return parseResolved0(text, null).query(query);\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    /**\n     * Fully parses the text producing an object of one of the specified types.\n     * \u003cp\u003e\n     * This parse method is convenient for use when the parser can handle optional elements.\n     * For example, a pattern of \u0027uuuu-MM-dd HH.mm[ VV]\u0027 can be fully parsed to a {@code ZonedDateTime},\n     * or partially parsed to a {@code LocalDateTime}.\n     * The queries must be specified in order, starting from the best matching full-parse option\n     * and ending with the worst matching minimal parse option.\n     * The query is typically a method reference to a {@code from(TemporalAccessor)} method.\n     * \u003cp\u003e\n     * The result is associated with the first type that successfully parses.\n     * Normally, applications will use {@code instanceof} to check the result.\n     * For example:\n     * \u003cpre\u003e\n     *  TemporalAccessor dt \u003d parser.parseBest(str, ZonedDateTime::from, LocalDateTime::from);\n     *  if (dt instanceof ZonedDateTime) {\n     *   ...\n     *  } else {\n     *   ...\n     *  }\n     * \u003c/pre\u003e\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param text  the text to parse, not null\n     * @param queries  the queries defining the types to attempt to parse to,\n     *  must implement {@code TemporalAccessor}, not null\n     * @return the parsed date-time, not null\n     * @throws IllegalArgumentException if less than 2 types are specified\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    public TemporalAccessor parseBest(CharSequence text, TemporalQuery\u003c?\u003e... queries) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(queries, \"queries\");\n        if (queries.length \u003c 2) {\n            throw new IllegalArgumentException(\"At least two queries must be specified\");\n        }\n        try {\n            TemporalAccessor resolved \u003d parseResolved0(text, null);\n            for (TemporalQuery\u003c?\u003e query : queries) {\n                try {\n                    return (TemporalAccessor) resolved.query(query);\n                } catch (RuntimeException ex) {\n                    // continue\n                }\n            }\n            throw new DateTimeException(\"Unable to convert parsed text using any of the specified queries\");\n        } catch (DateTimeParseException ex) {\n            throw ex;\n        } catch (RuntimeException ex) {\n            throw createError(text, ex);\n        }\n    }\n\n    private DateTimeParseException createError(CharSequence text, RuntimeException ex) {\n        String abbr;\n        if (text.length() \u003e 64) {\n            abbr \u003d text.subSequence(0, 64).toString() + \"...\";\n        } else {\n            abbr \u003d text.toString();\n        }\n        return new DateTimeParseException(\"Text \u0027\" + abbr + \"\u0027 could not be parsed: \" + ex.getMessage(), text, 0, ex);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses and resolves the specified text.\n     * \u003cp\u003e\n     * This parses to a {@code TemporalAccessor} ensuring that the text is fully parsed.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, null if parsing whole string\n     * @return the resolved result of the parse, not null\n     * @throws DateTimeParseException if the parse fails\n     * @throws DateTimeException if an error occurs while resolving the date or time\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    private TemporalAccessor parseResolved0(final CharSequence text, final ParsePosition position) {\n        ParsePosition pos \u003d (position !\u003d null ? position : new ParsePosition(0));\n        DateTimeParseContext context \u003d parseUnresolved0(text, pos);\n        if (context \u003d\u003d null || pos.getErrorIndex() \u003e\u003d 0 || (position \u003d\u003d null \u0026\u0026 pos.getIndex() \u003c text.length())) {\n            String abbr;\n            if (text.length() \u003e 64) {\n                abbr \u003d text.subSequence(0, 64).toString() + \"...\";\n            } else {\n                abbr \u003d text.toString();\n            }\n            if (pos.getErrorIndex() \u003e\u003d 0) {\n                throw new DateTimeParseException(\"Text \u0027\" + abbr + \"\u0027 could not be parsed at index \" +\n                        pos.getErrorIndex(), text, pos.getErrorIndex());\n            } else {\n                throw new DateTimeParseException(\"Text \u0027\" + abbr + \"\u0027 could not be parsed, unparsed text found at index \" +\n                        pos.getIndex(), text, pos.getIndex());\n            }\n        }\n        return context.toResolved(resolverStyle, resolverFields);\n    }\n\n    /**\n     * Parses the text using this formatter, without resolving the result, intended\n     * for advanced use cases.\n     * \u003cp\u003e\n     * Parsing is implemented as a two-phase operation.\n     * First, the text is parsed using the layout defined by the formatter, producing\n     * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.\n     * Second, the parsed data is \u003cem\u003eresolved\u003c/em\u003e, by validating, combining and\n     * simplifying the various fields into more useful ones.\n     * This method performs the parsing stage but not the resolving stage.\n     * \u003cp\u003e\n     * The result of this method is {@code TemporalAccessor} which represents the\n     * data as seen in the input. Values are not validated, thus parsing a date string\n     * of \u00272012-00-65\u0027 would result in a temporal with three fields - year of \u00272012\u0027,\n     * month of \u00270\u0027 and day-of-month of \u002765\u0027.\n     * \u003cp\u003e\n     * The text will be parsed from the specified start {@code ParsePosition}.\n     * The entire length of the text does not have to be parsed, the {@code ParsePosition}\n     * will be updated with the index at the end of parsing.\n     * \u003cp\u003e\n     * Errors are returned using the error index field of the {@code ParsePosition}\n     * instead of {@code DateTimeParseException}.\n     * The returned error index will be set to an index indicative of the error.\n     * Callers must check for errors before using the result.\n     * \u003cp\u003e\n     * If the formatter parses the same field more than once with different values,\n     * the result will be an error.\n     * \u003cp\u003e\n     * This method is intended for advanced use cases that need access to the\n     * internal state during parsing. Typical application code should use\n     * {@link #parse(CharSequence, TemporalQuery)} or the parse method on the target type.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, not null\n     * @return the parsed text, null if the parse results in an error\n     * @throws DateTimeException if some problem occurs during parsing\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    public TemporalAccessor parseUnresolved(CharSequence text, ParsePosition position) {\n        DateTimeParseContext context \u003d parseUnresolved0(text, position);\n        if (context \u003d\u003d null) {\n            return null;\n        }\n        return context.toUnresolved();\n    }\n\n    private DateTimeParseContext parseUnresolved0(CharSequence text, ParsePosition position) {\n        Objects.requireNonNull(text, \"text\");\n        Objects.requireNonNull(position, \"position\");\n        DateTimeParseContext context \u003d new DateTimeParseContext(this);\n        int pos \u003d position.getIndex();\n        pos \u003d printerParser.parse(context, text, pos);\n        if (pos \u003c 0) {\n            position.setErrorIndex(~pos);  // index not updated from input\n            return null;\n        }\n        position.setIndex(pos);  // errorIndex not updated from input\n        return context;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the formatter as a composite printer parser.\n     *\n     * @param optional  whether the printer/parser should be optional\n     * @return the printer/parser, not null\n     */\n    CompositePrinterParser toPrinterParser(boolean optional) {\n        return printerParser.withOptional(optional);\n    }\n\n    /**\n     * Returns this formatter as a {@code java.text.Format} instance.\n     * \u003cp\u003e\n     * The returned {@link Format} instance will format any {@link TemporalAccessor}\n     * and parses to a resolved {@link TemporalAccessor}.\n     * \u003cp\u003e\n     * Exceptions will follow the definitions of {@code Format}, see those methods\n     * for details about {@code IllegalArgumentException} during formatting and\n     * {@code ParseException} or null during parsing.\n     * The format does not support attributing of the returned format string.\n     *\n     * @return this formatter as a classic format instance, not null\n     */\n    public Format toFormat() {\n        return new ClassicFormat(this, null);\n    }\n\n    /**\n     * Returns this formatter as a {@code java.text.Format} instance that will\n     * parse using the specified query.\n     * \u003cp\u003e\n     * The returned {@link Format} instance will format any {@link TemporalAccessor}\n     * and parses to the type specified.\n     * The type must be one that is supported by {@link #parse}.\n     * \u003cp\u003e\n     * Exceptions will follow the definitions of {@code Format}, see those methods\n     * for details about {@code IllegalArgumentException} during formatting and\n     * {@code ParseException} or null during parsing.\n     * The format does not support attributing of the returned format string.\n     *\n     * @param parseQuery  the query defining the type to parse to, not null\n     * @return this formatter as a classic format instance, not null\n     */\n    public Format toFormat(TemporalQuery\u003c?\u003e parseQuery) {\n        Objects.requireNonNull(parseQuery, \"parseQuery\");\n        return new ClassicFormat(this, parseQuery);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a description of the underlying formatters.\n     *\n     * @return a description of this formatter, not null\n     */\n    @Override\n    public String toString() {\n        String pattern \u003d printerParser.toString();\n        pattern \u003d pattern.startsWith(\"[\") ? pattern : pattern.substring(1, pattern.length() - 1);\n        return pattern;\n        // TODO: Fix tests to not depend on toString()\n//        return \"DateTimeFormatter[\" + locale +\n//                (chrono !\u003d null ? \",\" + chrono : \"\") +\n//                (zone !\u003d null ? \",\" + zone : \"\") +\n//                pattern + \"]\";\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements the classic Java Format API.\n     * @serial exclude\n     */\n    @SuppressWarnings(\"serial\")  // not actually serializable\n    static class ClassicFormat extends Format {\n        /** The formatter. */\n        private final DateTimeFormatter formatter;\n        /** The type to be parsed. */\n        private final TemporalQuery\u003c?\u003e parseType;\n        /** Constructor. */\n        public ClassicFormat(DateTimeFormatter formatter, TemporalQuery\u003c?\u003e parseType) {\n            this.formatter \u003d formatter;\n            this.parseType \u003d parseType;\n        }\n\n        @Override\n        public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n            Objects.requireNonNull(obj, \"obj\");\n            Objects.requireNonNull(toAppendTo, \"toAppendTo\");\n            Objects.requireNonNull(pos, \"pos\");\n            if (obj instanceof TemporalAccessor \u003d\u003d false) {\n                throw new IllegalArgumentException(\"Format target must implement TemporalAccessor\");\n            }\n            pos.setBeginIndex(0);\n            pos.setEndIndex(0);\n            try {\n                formatter.formatTo((TemporalAccessor) obj, toAppendTo);\n            } catch (RuntimeException ex) {\n                throw new IllegalArgumentException(ex.getMessage(), ex);\n            }\n            return toAppendTo;\n        }\n        @Override\n        public Object parseObject(String text) throws ParseException {\n            Objects.requireNonNull(text, \"text\");\n            try {\n                if (parseType \u003d\u003d null) {\n                    return formatter.parseResolved0(text, null);\n                }\n                return formatter.parse(text, parseType);\n            } catch (DateTimeParseException ex) {\n                throw new ParseException(ex.getMessage(), ex.getErrorIndex());\n            } catch (RuntimeException ex) {\n                throw (ParseException) new ParseException(ex.getMessage(), 0).initCause(ex);\n            }\n        }\n        @Override\n        public Object parseObject(String text, ParsePosition pos) {\n            Objects.requireNonNull(text, \"text\");\n            DateTimeParseContext context;\n            try {\n                context \u003d formatter.parseUnresolved0(text, pos);\n            } catch (IndexOutOfBoundsException ex) {\n                if (pos.getErrorIndex() \u003c 0) {\n                    pos.setErrorIndex(0);\n                }\n                return null;\n            }\n            if (context \u003d\u003d null) {\n                if (pos.getErrorIndex() \u003c 0) {\n                    pos.setErrorIndex(0);\n                }\n                return null;\n            }\n            try {\n                TemporalAccessor resolved \u003d context.toResolved(formatter.resolverStyle, formatter.resolverFields);\n                if (parseType \u003d\u003d null) {\n                    return resolved;\n                }\n                return resolved.query(parseType);\n            } catch (RuntimeException ex) {\n                pos.setErrorIndex(0);\n                return null;\n            }\n        }\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 18, 2024 3:04:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java"
  ]
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.18 15:04:39 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:545)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	jdk.internal.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:04:39 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:443)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	jdk.internal.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:04:39 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:04:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

2024.10.18 15:04:39 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.codeLens(WorkspaceLspService.scala:530)
	scala.meta.metals.lsp.DelegatingScalaService.codeLens(DelegatingScalaService.scala:150)
	jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:04:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$3(MetalsLspService.scala:1225)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$2(MetalsLspService.scala:1224)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:04:39 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.documentSymbol(WorkspaceLspService.scala:460)
	scala.meta.metals.lsp.DelegatingScalaService.documentSymbol(DelegatingScalaService.scala:91)
	jdk.internal.reflect.GeneratedMethodAccessor5.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:04:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$documentSymbol$1(MetalsLspService.scala:1055)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:04:39 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:04:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

oct 18, 2024 3:04:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/format/DateTimeFormatter.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/format/DateTimeFormatter.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.18 15:04:47 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:04:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.LocalTime.SECONDS_PER_DAY;\nimport static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH;\nimport static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR;\nimport static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_MONTH;\nimport static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_YEAR;\nimport static java.time.temporal.ChronoField.DAY_OF_MONTH;\nimport static java.time.temporal.ChronoField.DAY_OF_YEAR;\nimport static java.time.temporal.ChronoField.EPOCH_DAY;\nimport static java.time.temporal.ChronoField.ERA;\nimport static java.time.temporal.ChronoField.MONTH_OF_YEAR;\nimport static java.time.temporal.ChronoField.PROLEPTIC_MONTH;\nimport static java.time.temporal.ChronoField.YEAR;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.ChronoLocalDate;\nimport java.time.chrono.IsoEra;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneOffsetTransition;\nimport java.time.zone.ZoneRules;\nimport java.util.Objects;\nimport java.util.stream.LongStream;\nimport java.util.stream.Stream;\n\n/**\n * A date without a time-zone in the ISO-8601 calendar system,\n * such as {@code 2007-12-03}.\n * \u003cp\u003e\n * {@code LocalDate} is an immutable date-time object that represents a date,\n * often viewed as year-month-day. Other date fields, such as day-of-year,\n * day-of-week and week-of-year, can also be accessed.\n * For example, the value \"2nd October 2007\" can be stored in a {@code LocalDate}.\n * \u003cp\u003e\n * This class does not store or represent a time or time-zone.\n * Instead, it is a description of the date, as used for birthdays.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n * \u003cp\u003e\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today\u0027s rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code LocalDate} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class LocalDate\n        implements Temporal, TemporalAdjuster, ChronoLocalDate, Serializable {\n\n    /**\n     * The minimum supported {@code LocalDate}, \u0027-999999999-01-01\u0027.\n     * This could be used by an application as a \"far past\" date.\n     */\n    public static final LocalDate MIN \u003d LocalDate.of(Year.MIN_VALUE, 1, 1);\n    /**\n     * The maximum supported {@code LocalDate}, \u0027+999999999-12-31\u0027.\n     * This could be used by an application as a \"far future\" date.\n     */\n    public static final LocalDate MAX \u003d LocalDate.of(Year.MAX_VALUE, 12, 31);\n    /**\n     * The epoch year {@code LocalDate}, \u00271970-01-01\u0027.\n     */\n    public static final LocalDate EPOCH \u003d LocalDate.of(1970, 1, 1);\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 2942565459149668126L;\n    /**\n     * The number of days in a 400 year cycle.\n     */\n    private static final int DAYS_PER_CYCLE \u003d 146097;\n    /**\n     * The number of days from year zero to year 1970.\n     * There are five 400 year cycles from year zero to 2000.\n     * There are 7 leap years from 1970 to 2000.\n     */\n    static final long DAYS_0000_TO_1970 \u003d (DAYS_PER_CYCLE * 5L) - (30L * 365L + 7L);\n\n    /**\n     * The year.\n     */\n    private final int year;\n    /**\n     * The month-of-year.\n     */\n    private final short month;\n    /**\n     * The day-of-month.\n     */\n    private final short day;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date using the system clock and default time-zone, not null\n     */\n    public static LocalDate now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date using the system clock, not null\n     */\n    public static LocalDate now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date - today.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date, not null\n     */\n    public static LocalDate now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        return ofInstant(now, clock.getZone());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a year, month and day.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDate of(int year, Month month, int dayOfMonth) {\n        YEAR.checkValidValue(year);\n        Objects.requireNonNull(month, \"month\");\n        DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        return create(year, month.getValue(), dayOfMonth);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDate} from a year, month and day.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDate of(int year, int month, int dayOfMonth) {\n        YEAR.checkValidValue(year);\n        MONTH_OF_YEAR.checkValidValue(month);\n        DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        return create(year, month, dayOfMonth);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a year and day-of-year.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year and day-of-year.\n     * The day-of-year must be valid for the year, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param dayOfYear  the day-of-year to represent, from 1 to 366\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-year is invalid for the year\n     */\n    public static LocalDate ofYearDay(int year, int dayOfYear) {\n        YEAR.checkValidValue(year);\n        DAY_OF_YEAR.checkValidValue(dayOfYear);\n        boolean leap \u003d IsoChronology.INSTANCE.isLeapYear(year);\n        if (dayOfYear \u003d\u003d 366 \u0026\u0026 leap \u003d\u003d false) {\n            throw new DateTimeException(\"Invalid date \u0027DayOfYear 366\u0027 as \u0027\" + year + \"\u0027 is not a leap year\");\n        }\n        Month moy \u003d Month.of((dayOfYear - 1) / 31 + 1);\n        int monthEnd \u003d moy.firstDayOfYear(leap) + moy.length(leap) - 1;\n        if (dayOfYear \u003e monthEnd) {\n            moy \u003d moy.plus(1);\n        }\n        int dom \u003d dayOfYear - moy.firstDayOfYear(leap) + 1;\n        return new LocalDate(year, moy.getValue(), dom);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates a local date based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date.\n     *\n     * @param instant  the instant to create the date from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the local date, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     * @since 9\n     */\n    public static LocalDate ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        long localSecond \u003d instant.getEpochSecond() + offset.getTotalSeconds();\n        long localEpochDay \u003d Math.floorDiv(localSecond, SECONDS_PER_DAY);\n        return ofEpochDay(localEpochDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from the epoch day count.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified epoch-day.\n     * The {@link ChronoField#EPOCH_DAY EPOCH_DAY} is a simple incrementing count\n     * of days where day 0 is 1970-01-01. Negative numbers represent earlier days.\n     *\n     * @param epochDay  the Epoch Day to convert, based on the epoch 1970-01-01\n     * @return the local date, not null\n     * @throws DateTimeException if the epoch day exceeds the supported date range\n     */\n    public static LocalDate ofEpochDay(long epochDay) {\n        EPOCH_DAY.checkValidValue(epochDay);\n        long zeroDay \u003d epochDay + DAYS_0000_TO_1970;\n        // find the march-based year\n        zeroDay -\u003d 60;  // adjust to 0000-03-01 so leap day is at end of four year cycle\n        long adjust \u003d 0;\n        if (zeroDay \u003c 0) {\n            // adjust negative years to positive for calculation\n            long adjustCycles \u003d (zeroDay + 1) / DAYS_PER_CYCLE - 1;\n            adjust \u003d adjustCycles * 400;\n            zeroDay +\u003d -adjustCycles * DAYS_PER_CYCLE;\n        }\n        long yearEst \u003d (400 * zeroDay + 591) / DAYS_PER_CYCLE;\n        long doyEst \u003d zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);\n        if (doyEst \u003c 0) {\n            // fix estimate\n            yearEst--;\n            doyEst \u003d zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);\n        }\n        yearEst +\u003d adjust;  // reset any negative year\n        int marchDoy0 \u003d (int) doyEst;\n\n        // convert march-based values back to january-based\n        int marchMonth0 \u003d (marchDoy0 * 5 + 2) / 153;\n        int month \u003d (marchMonth0 + 2) % 12 + 1;\n        int dom \u003d marchDoy0 - (marchMonth0 * 306 + 5) / 10 + 1;\n        yearEst +\u003d marchMonth0 / 10;\n\n        // check year now we are certain it is correct\n        int year \u003d YEAR.checkValidIntValue(yearEst);\n        return new LocalDate(year, month, dom);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a temporal object.\n     * \u003cp\u003e\n     * This obtains a local date based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code LocalDate}.\n     * \u003cp\u003e\n     * The conversion uses the {@link TemporalQueries#localDate()} query, which relies\n     * on extracting the {@link ChronoField#EPOCH_DAY EPOCH_DAY} field.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code LocalDate::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the local date, not null\n     * @throws DateTimeException if unable to convert to a {@code LocalDate}\n     */\n    public static LocalDate from(TemporalAccessor temporal) {\n        Objects.requireNonNull(temporal, \"temporal\");\n        LocalDate date \u003d temporal.query(TemporalQueries.localDate());\n        if (date \u003d\u003d null) {\n            throw new DateTimeException(\"Unable to obtain LocalDate from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName());\n        }\n        return date;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a text string such as {@code 2007-12-03}.\n     * \u003cp\u003e\n     * The string must represent a valid date and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_DATE}.\n     *\n     * @param text  the text to parse such as \"2007-12-03\", not null\n     * @return the parsed local date, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDate parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_LOCAL_DATE);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDate} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed local date, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDate parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, LocalDate::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a local date from the year, month and day fields.\n     *\n     * @param year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 to 12, validated\n     * @param dayOfMonth  the day-of-month to represent, validated from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the day-of-month is invalid for the month-year\n     */\n    private static LocalDate create(int year, int month, int dayOfMonth) {\n        if (dayOfMonth \u003e 28) {\n            int dom \u003d 31;\n            switch (month) {\n                case 2:\n                    dom \u003d (IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n                    break;\n                case 4:\n                case 6:\n                case 9:\n                case 11:\n                    dom \u003d 30;\n                    break;\n            }\n            if (dayOfMonth \u003e dom) {\n                if (dayOfMonth \u003d\u003d 29) {\n                    throw new DateTimeException(\"Invalid date \u0027February 29\u0027 as \u0027\" + year + \"\u0027 is not a leap year\");\n                } else {\n                    throw new DateTimeException(\"Invalid date \u0027\" + Month.of(month).name() + \" \" + dayOfMonth + \"\u0027\");\n                }\n            }\n        }\n        return new LocalDate(year, month, dayOfMonth);\n    }\n\n    /**\n     * Resolves the date, resolving days past the end of month.\n     *\n     * @param year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, validated from 1 to 12\n     * @param day  the day-of-month to represent, validated from 1 to 31\n     * @return the resolved date, not null\n     */\n    private static LocalDate resolvePreviousValid(int year, int month, int day) {\n        switch (month) {\n            case 2:\n                day \u003d Math.min(day, IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n                break;\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                day \u003d Math.min(day, 30);\n                break;\n        }\n        return new LocalDate(year, month, day);\n    }\n\n    /**\n     * Constructor, previously validated.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, valid for year-month, from 1 to 31\n     */\n    private LocalDate(int year, int month, int dayOfMonth) {\n        this.year \u003d year;\n        this.month \u003d (short) month;\n        this.day \u003d (short) dayOfMonth;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalField field) {\n        return ChronoLocalDate.super.isSupported(field);\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        return ChronoLocalDate.super.isSupported(unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            if (f.isDateBased()) {\n                switch (f) {\n                    case DAY_OF_MONTH: return ValueRange.of(1, lengthOfMonth());\n                    case DAY_OF_YEAR: return ValueRange.of(1, lengthOfYear());\n                    case ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, getMonth() \u003d\u003d Month.FEBRUARY \u0026\u0026 isLeapYear() \u003d\u003d false ? 4 : 5);\n                    case YEAR_OF_ERA:\n                        return (getYear() \u003c\u003d 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n                }\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date, except {@code EPOCH_DAY} and {@code PROLEPTIC_MONTH}\n     * which are too large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc and performance\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            return get0(field);\n        }\n        return ChronoLocalDate.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            if (field \u003d\u003d EPOCH_DAY) {\n                return toEpochDay();\n            }\n            if (field \u003d\u003d PROLEPTIC_MONTH) {\n                return getProlepticMonth();\n            }\n            return get0(field);\n        }\n        return field.getFrom(this);\n    }\n\n    private int get0(TemporalField field) {\n        switch ((ChronoField) field) {\n            case DAY_OF_WEEK: return getDayOfWeek().getValue();\n            case ALIGNED_DAY_OF_WEEK_IN_MONTH: return ((day - 1) % 7) + 1;\n            case ALIGNED_DAY_OF_WEEK_IN_YEAR: return ((getDayOfYear() - 1) % 7) + 1;\n            case DAY_OF_MONTH: return day;\n            case DAY_OF_YEAR: return getDayOfYear();\n            case EPOCH_DAY: throw new UnsupportedTemporalTypeException(\"Invalid field \u0027EpochDay\u0027 for get() method, use getLong() instead\");\n            case ALIGNED_WEEK_OF_MONTH: return ((day - 1) / 7) + 1;\n            case ALIGNED_WEEK_OF_YEAR: return ((getDayOfYear() - 1) / 7) + 1;\n            case MONTH_OF_YEAR: return month;\n            case PROLEPTIC_MONTH: throw new UnsupportedTemporalTypeException(\"Invalid field \u0027ProlepticMonth\u0027 for get() method, use getLong() instead\");\n            case YEAR_OF_ERA: return (year \u003e\u003d 1 ? year : 1 - year);\n            case YEAR: return year;\n            case ERA: return (year \u003e\u003d 1 ? 1 : 0);\n        }\n        throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n    }\n\n    private long getProlepticMonth() {\n        return (year * 12L + month - 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology of this date, which is the ISO calendar system.\n     * \u003cp\u003e\n     * The {@code Chronology} represents the calendar system in use.\n     * The ISO-8601 calendar system is the modern civil calendar system used today\n     * in most of the world. It is equivalent to the proleptic Gregorian calendar\n     * system, in which today\u0027s rules for leap years are applied for all time.\n     *\n     * @return the ISO chronology, not null\n     */\n    @Override\n    public IsoChronology getChronology() {\n        return IsoChronology.INSTANCE;\n    }\n\n    /**\n     * Gets the era applicable at this date.\n     * \u003cp\u003e\n     * The official ISO-8601 standard does not define eras, however {@code IsoChronology} does.\n     * It defines two eras, \u0027CE\u0027 from year one onwards and \u0027BCE\u0027 from year zero backwards.\n     * Since dates before the Julian-Gregorian cutover are not in line with history,\n     * the cutover between \u0027BCE\u0027 and \u0027CE\u0027 is also not aligned with the commonly used\n     * eras, often referred to using \u0027BC\u0027 and \u0027AD\u0027.\n     * \u003cp\u003e\n     * Users of this class should typically ignore this method as it exists primarily\n     * to fulfill the {@link ChronoLocalDate} contract where it is necessary to support\n     * the Japanese calendar system.\n     *\n     * @return the IsoEra applicable at this date, not null\n     */\n    @Override // override for Javadoc\n    public IsoEra getEra() {\n        return (getYear() \u003e\u003d 1 ? IsoEra.CE : IsoEra.BCE);\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return year;\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return month;\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return Month.of(month);\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return day;\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return getMonth().firstDayOfYear(isLeapYear()) + day - 1;\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        int dow0 \u003d Math.floorMod(toEpochDay() + 3, 7);\n        return DayOfWeek.of(dow0 + 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     * \u003cp\u003e\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     * \u003cp\u003e\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     * \u003cp\u003e\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return true if the year is leap, false otherwise\n     */\n    @Override // override for Javadoc and performance\n    public boolean isLeapYear() {\n        return IsoChronology.INSTANCE.isLeapYear(year);\n    }\n\n    /**\n     * Returns the length of the month represented by this date.\n     * \u003cp\u003e\n     * This returns the length of the month in days.\n     * For example, a date in January would return 31.\n     *\n     * @return the length of the month in days\n     */\n    @Override\n    public int lengthOfMonth() {\n        switch (month) {\n            case 2:\n                return (isLeapYear() ? 29 : 28);\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Returns the length of the year represented by this date.\n     * \u003cp\u003e\n     * This returns the length of the year in days, either 365 or 366.\n     *\n     * @return 366 if the year is leap, 365 otherwise\n     */\n    @Override // override for Javadoc and performance\n    public int lengthOfYear() {\n        return (isLeapYear() ? 366 : 365);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the date adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * \u003cp\u003e\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d localDate.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return a {@code LocalDate} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return (LocalDate) adjuster;\n        }\n        return (LocalDate) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAY_OF_WEEK} -\n     *  Returns a {@code LocalDate} with the specified day-of-week.\n     *  The date is adjusted up to 6 days forward or backward within the boundary\n     *  of a Monday to Sunday week.\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH} -\n     *  Returns a {@code LocalDate} with the specified aligned-day-of-week.\n     *  The date is adjusted to the specified month-based aligned-day-of-week.\n     *  Aligned weeks are counted such that the first week of a given month starts\n     *  on the first day of that month.\n     *  This may cause the date to be moved up to 6 days into the following month.\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR} -\n     *  Returns a {@code LocalDate} with the specified aligned-day-of-week.\n     *  The date is adjusted to the specified year-based aligned-day-of-week.\n     *  Aligned weeks are counted such that the first week of a given year starts\n     *  on the first day of that year.\n     *  This may cause the date to be moved up to 6 days into the following year.\n     * \u003cli\u003e{@code DAY_OF_MONTH} -\n     *  Returns a {@code LocalDate} with the specified day-of-month.\n     *  The month and year will be unchanged. If the day-of-month is invalid for the\n     *  year and month, then a {@code DateTimeException} is thrown.\n     * \u003cli\u003e{@code DAY_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified day-of-year.\n     *  The year will be unchanged. If the day-of-year is invalid for the\n     *  year, then a {@code DateTimeException} is thrown.\n     * \u003cli\u003e{@code EPOCH_DAY} -\n     *  Returns a {@code LocalDate} with the specified epoch-day.\n     *  This completely replaces the date and is equivalent to {@link #ofEpochDay(long)}.\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH} -\n     *  Returns a {@code LocalDate} with the specified aligned-week-of-month.\n     *  Aligned weeks are counted such that the first week of a given month starts\n     *  on the first day of that month.\n     *  This adjustment moves the date in whole week chunks to match the specified week.\n     *  The result will have the same day-of-week as this date.\n     *  This may cause the date to be moved into the following month.\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified aligned-week-of-year.\n     *  Aligned weeks are counted such that the first week of a given year starts\n     *  on the first day of that year.\n     *  This adjustment moves the date in whole week chunks to match the specified week.\n     *  The result will have the same day-of-week as this date.\n     *  This may cause the date to be moved into the following year.\n     * \u003cli\u003e{@code MONTH_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified month-of-year.\n     *  The year will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code PROLEPTIC_MONTH} -\n     *  Returns a {@code LocalDate} with the specified proleptic-month.\n     *  The day-of-month will be unchanged, unless it would be invalid for the new month\n     *  and year. In that case, the day-of-month is adjusted to the maximum valid value\n     *  for the new month and year.\n     * \u003cli\u003e{@code YEAR_OF_ERA} -\n     *  Returns a {@code LocalDate} with the specified year-of-era.\n     *  The era and month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code YEAR} -\n     *  Returns a {@code LocalDate} with the specified year.\n     *  The month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code ERA} -\n     *  Returns a {@code LocalDate} with the specified era.\n     *  The year-of-era and month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return a {@code LocalDate} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            f.checkValidValue(newValue);\n            switch (f) {\n                case DAY_OF_WEEK: return plusDays(newValue - getDayOfWeek().getValue());\n                case ALIGNED_DAY_OF_WEEK_IN_MONTH: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n                case ALIGNED_DAY_OF_WEEK_IN_YEAR: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                case DAY_OF_MONTH: return withDayOfMonth((int) newValue);\n                case DAY_OF_YEAR: return withDayOfYear((int) newValue);\n                case EPOCH_DAY: return LocalDate.ofEpochDay(newValue);\n                case ALIGNED_WEEK_OF_MONTH: return plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_MONTH));\n                case ALIGNED_WEEK_OF_YEAR: return plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_YEAR));\n                case MONTH_OF_YEAR: return withMonth((int) newValue);\n                case PROLEPTIC_MONTH: return plusMonths(newValue - getProlepticMonth());\n                case YEAR_OF_ERA: return withYear((int) (year \u003e\u003d 1 ? newValue : 1 - newValue));\n                case YEAR: return withYear((int) newValue);\n                case ERA: return (getLong(ERA) \u003d\u003d newValue ? this : withYear(1 - year));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the year altered.\n     * \u003cp\u003e\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return a {@code LocalDate} based on this date with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public LocalDate withYear(int year) {\n        if (this.year \u003d\u003d year) {\n            return this;\n        }\n        YEAR.checkValidValue(year);\n        return resolvePreviousValid(year, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the month-of-year altered.\n     * \u003cp\u003e\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return a {@code LocalDate} based on this date with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public LocalDate withMonth(int month) {\n        if (this.month \u003d\u003d month) {\n            return this;\n        }\n        MONTH_OF_YEAR.checkValidValue(month);\n        return resolvePreviousValid(year, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting date is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return a {@code LocalDate} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public LocalDate withDayOfMonth(int dayOfMonth) {\n        if (this.day \u003d\u003d dayOfMonth) {\n            return this;\n        }\n        return of(year, month, dayOfMonth);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the day-of-year altered.\n     * \u003cp\u003e\n     * If the resulting date is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return a {@code LocalDate} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public LocalDate withDayOfYear(int dayOfYear) {\n        if (this.getDayOfYear() \u003d\u003d dayOfYear) {\n            return this;\n        }\n        return ofYearDay(year, dayOfYear);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return a {@code LocalDate} based on this date with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate plus(TemporalAmount amountToAdd) {\n        if (amountToAdd instanceof Period) {\n            Period periodToAdd \u003d (Period) amountToAdd;\n            return plusMonths(periodToAdd.toTotalMonths()).plusDays(periodToAdd.getDays());\n        }\n        Objects.requireNonNull(amountToAdd, \"amountToAdd\");\n        return (LocalDate) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, adding the amount can cause the resulting date to become invalid.\n     * For example, adding one month to 31st January would result in 31st February.\n     * In cases like this, the unit is responsible for resolving the date.\n     * Typically it will choose the previous valid date, which would be the last valid\n     * day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented here.\n     * The supported fields behave as follows:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAYS} -\n     *  Returns a {@code LocalDate} with the specified number of days added.\n     *  This is equivalent to {@link #plusDays(long)}.\n     * \u003cli\u003e{@code WEEKS} -\n     *  Returns a {@code LocalDate} with the specified number of weeks added.\n     *  This is equivalent to {@link #plusWeeks(long)} and uses a 7 day week.\n     * \u003cli\u003e{@code MONTHS} -\n     *  Returns a {@code LocalDate} with the specified number of months added.\n     *  This is equivalent to {@link #plusMonths(long)}.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code YEARS} -\n     *  Returns a {@code LocalDate} with the specified number of years added.\n     *  This is equivalent to {@link #plusYears(long)}.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code DECADES} -\n     *  Returns a {@code LocalDate} with the specified number of decades added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 10.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code CENTURIES} -\n     *  Returns a {@code LocalDate} with the specified number of centuries added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 100.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code MILLENNIA} -\n     *  Returns a {@code LocalDate} with the specified number of millennia added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 1,000.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code ERAS} -\n     *  Returns a {@code LocalDate} with the specified number of eras added.\n     *  Only two eras are supported so the amount must be one, zero or minus one.\n     *  If the amount is non-zero then the year is changed such that the year-of-era\n     *  is unchanged.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * All other {@code ChronoUnit} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return a {@code LocalDate} based on this date with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            ChronoUnit f \u003d (ChronoUnit) unit;\n            switch (f) {\n                case DAYS: return plusDays(amountToAdd);\n                case WEEKS: return plusWeeks(amountToAdd);\n                case MONTHS: return plusMonths(amountToAdd);\n                case YEARS: return plusYears(amountToAdd);\n                case DECADES: return plusYears(Math.multiplyExact(amountToAdd, 10));\n                case CENTURIES: return plusYears(Math.multiplyExact(amountToAdd, 100));\n                case MILLENNIA: return plusYears(Math.multiplyExact(amountToAdd, 1000));\n                case ERAS: return with(ERA, Math.addExact(getLong(ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param yearsToAdd  the years to add, may be negative\n     * @return a {@code LocalDate} based on this date with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusYears(long yearsToAdd) {\n        if (yearsToAdd \u003d\u003d 0) {\n            return this;\n        }\n        int newYear \u003d YEAR.checkValidIntValue(year + yearsToAdd);  // safe overflow\n        return resolvePreviousValid(newYear, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param monthsToAdd  the months to add, may be negative\n     * @return a {@code LocalDate} based on this date with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusMonths(long monthsToAdd) {\n        if (monthsToAdd \u003d\u003d 0) {\n            return this;\n        }\n        long monthCount \u003d year * 12L + (month - 1);\n        long calcMonths \u003d monthCount + monthsToAdd;  // safe overflow\n        int newYear \u003d YEAR.checkValidIntValue(Math.floorDiv(calcMonths, 12));\n        int newMonth \u003d Math.floorMod(calcMonths, 12) + 1;\n        return resolvePreviousValid(newYear, newMonth, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeksToAdd  the weeks to add, may be negative\n     * @return a {@code LocalDate} based on this date with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusWeeks(long weeksToAdd) {\n        return plusDays(Math.multiplyExact(weeksToAdd, 7));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param daysToAdd  the days to add, may be negative\n     * @return a {@code LocalDate} based on this date with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusDays(long daysToAdd) {\n        if (daysToAdd \u003d\u003d 0) {\n            return this;\n        }\n        long dom \u003d day + daysToAdd;\n        if (dom \u003e 0) {\n            if (dom \u003c\u003d 28) {\n                return new LocalDate(year, month, (int) dom);\n            } else if (dom \u003c\u003d 59) { // 59th Jan is 28th Feb, 59th Feb is 31st Mar\n                long monthLen \u003d lengthOfMonth();\n                if (dom \u003c\u003d monthLen) {\n                    return new LocalDate(year, month, (int) dom);\n                } else if (month \u003c 12) {\n                    return new LocalDate(year, month + 1, (int) (dom - monthLen));\n                } else {\n                    YEAR.checkValidValue(year + 1);\n                    return new LocalDate(year + 1, 1, (int) (dom - monthLen));\n                }\n            }\n        }\n\n        long mjDay \u003d Math.addExact(toEpochDay(), daysToAdd);\n        return LocalDate.ofEpochDay(mjDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return a {@code LocalDate} based on this date with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate minus(TemporalAmount amountToSubtract) {\n        if (amountToSubtract instanceof Period) {\n            Period periodToSubtract \u003d (Period) amountToSubtract;\n            return minusMonths(periodToSubtract.toTotalMonths()).minusDays(periodToSubtract.getDays());\n        }\n        Objects.requireNonNull(amountToSubtract, \"amountToSubtract\");\n        return (LocalDate) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return a {@code LocalDate} based on this date with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param yearsToSubtract  the years to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusYears(long yearsToSubtract) {\n        return (yearsToSubtract \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-yearsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param monthsToSubtract  the months to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusMonths(long monthsToSubtract) {\n        return (monthsToSubtract \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-monthsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeksToSubtract  the weeks to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusWeeks(long weeksToSubtract) {\n        return (weeksToSubtract \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeksToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param daysToSubtract  the days to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusDays(long daysToSubtract) {\n        return (daysToSubtract \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-daysToSubtract));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date using the specified query.\n     * \u003cp\u003e\n     * This queries this date using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) this;\n        }\n        return ChronoLocalDate.super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the date changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * passing {@link ChronoField#EPOCH_DAY} as the field.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisLocalDate.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisLocalDate);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc\n    public Temporal adjustInto(Temporal temporal) {\n        return ChronoLocalDate.super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the amount of time until another date in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code LocalDate}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code LocalDate} using {@link #from(TemporalAccessor)}.\n     * For example, the amount in days between two dates can be calculated\n     * using {@code startDate.until(endDate, DAYS)}.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two dates.\n     * For example, the amount in months between 2012-06-15 and 2012-08-14\n     * will only be one month as it is one day short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code DAYS}, {@code WEEKS}, {@code MONTHS}, {@code YEARS},\n     * {@code DECADES}, {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS}\n     * are supported. Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to a {@code LocalDate}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date and the end date\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to a {@code LocalDate}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        LocalDate end \u003d LocalDate.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch ((ChronoUnit) unit) {\n                case DAYS: return daysUntil(end);\n                case WEEKS: return daysUntil(end) / 7;\n                case MONTHS: return monthsUntil(end);\n                case YEARS: return monthsUntil(end) / 12;\n                case DECADES: return monthsUntil(end) / 120;\n                case CENTURIES: return monthsUntil(end) / 1200;\n                case MILLENNIA: return monthsUntil(end) / 12000;\n                case ERAS: return end.getLong(ERA) - getLong(ERA);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    long daysUntil(LocalDate end) {\n        return end.toEpochDay() - toEpochDay();  // no overflow\n    }\n\n    private long monthsUntil(LocalDate end) {\n        long packed1 \u003d getProlepticMonth() * 32L + getDayOfMonth();  // no overflow\n        long packed2 \u003d end.getProlepticMonth() * 32L + end.getDayOfMonth();  // no overflow\n        return (packed2 - packed1) / 32;\n    }\n\n    /**\n     * Calculates the period between this date and another date as a {@code Period}.\n     * \u003cp\u003e\n     * This calculates the period between two dates in terms of years, months and days.\n     * The start and end points are {@code this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The negative sign will be the same in each of year, month and day.\n     * \u003cp\u003e\n     * The calculation is performed using the ISO calendar system.\n     * If necessary, the input date will be converted to ISO.\n     * \u003cp\u003e\n     * The start date is included, but the end date is not.\n     * The period is calculated by removing complete months, then calculating\n     * the remaining number of days, adjusting to ensure that both have the same sign.\n     * The number of months is then normalized into years and months based on a 12 month year.\n     * A month is considered to be complete if the end day-of-month is greater\n     * than or equal to the start day-of-month.\n     * For example, from {@code 2010-01-15} to {@code 2011-03-18} is \"1 year, 2 months and 3 days\".\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link Period#between(LocalDate, LocalDate)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   period \u003d start.until(end);\n     *   period \u003d Period.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     *\n     * @param endDateExclusive  the end date, exclusive, which may be in any chronology, not null\n     * @return the period between this date and the end date, not null\n     */\n    @Override\n    public Period until(ChronoLocalDate endDateExclusive) {\n        LocalDate end \u003d LocalDate.from(endDateExclusive);\n        long totalMonths \u003d end.getProlepticMonth() - this.getProlepticMonth();  // safe\n        int days \u003d end.day - this.day;\n        if (totalMonths \u003e 0 \u0026\u0026 days \u003c 0) {\n            totalMonths--;\n            LocalDate calcDate \u003d this.plusMonths(totalMonths);\n            days \u003d (int) (end.toEpochDay() - calcDate.toEpochDay());  // safe\n        } else if (totalMonths \u003c 0 \u0026\u0026 days \u003e 0) {\n            totalMonths++;\n            days -\u003d end.lengthOfMonth();\n        }\n        long years \u003d totalMonths / 12;  // safe\n        int months \u003d (int) (totalMonths % 12);  // safe\n        return Period.of(Math.toIntExact(years), months, days);\n    }\n\n    /**\n     * Returns a sequential ordered stream of dates. The returned stream starts from this date\n     * (inclusive) and goes to {@code endExclusive} (exclusive) by an incremental step of 1 day.\n     * \u003cp\u003e\n     * This method is equivalent to {@code datesUntil(endExclusive, Period.ofDays(1))}.\n     *\n     * @param endExclusive  the end date, exclusive, not null\n     * @return a sequential {@code Stream} for the range of {@code LocalDate} values\n     * @throws IllegalArgumentException if end date is before this date\n     * @since 9\n     */\n    public Stream\u003cLocalDate\u003e datesUntil(LocalDate endExclusive) {\n        long end \u003d endExclusive.toEpochDay();\n        long start \u003d toEpochDay();\n        if (end \u003c start) {\n            throw new IllegalArgumentException(endExclusive + \" \u003c \" + this);\n        }\n        return LongStream.range(start, end).mapToObj(LocalDate::ofEpochDay);\n    }\n\n    /**\n     * Returns a sequential ordered stream of dates by given incremental step. The returned stream\n     * starts from this date (inclusive) and goes to {@code endExclusive} (exclusive).\n     * \u003cp\u003e\n     * The n-th date which appears in the stream is equal to {@code this.plus(step.multipliedBy(n))}\n     * (but the result of step multiplication never overflows). For example, if this date is\n     * {@code 2015-01-31}, the end date is {@code 2015-05-01} and the step is 1 month, then the\n     * stream contains {@code 2015-01-31}, {@code 2015-02-28}, {@code 2015-03-31}, and\n     * {@code 2015-04-30}.\n     *\n     * @param endExclusive  the end date, exclusive, not null\n     * @param step  the non-zero, non-negative {@code Period} which represents the step.\n     * @return a sequential {@code Stream} for the range of {@code LocalDate} values\n     * @throws IllegalArgumentException if step is zero, or {@code step.getDays()} and\n     *             {@code step.toTotalMonths()} have opposite sign, or end date is before this date\n     *             and step is positive, or end date is after this date and step is negative\n     * @since 9\n     */\n    public Stream\u003cLocalDate\u003e datesUntil(LocalDate endExclusive, Period step) {\n        if (step.isZero()) {\n            throw new IllegalArgumentException(\"step is zero\");\n        }\n        long end \u003d endExclusive.toEpochDay();\n        long start \u003d toEpochDay();\n        long until \u003d end - start;\n        long months \u003d step.toTotalMonths();\n        long days \u003d step.getDays();\n        if ((months \u003c 0 \u0026\u0026 days \u003e 0) || (months \u003e 0 \u0026\u0026 days \u003c 0)) {\n            throw new IllegalArgumentException(\"period months and days are of opposite sign\");\n        }\n        if (until \u003d\u003d 0) {\n            return Stream.empty();\n        }\n        int sign \u003d months \u003e 0 || days \u003e 0 ? 1 : -1;\n        if (sign \u003c 0 ^ until \u003c 0) {\n            throw new IllegalArgumentException(endExclusive + (sign \u003c 0 ? \" \u003e \" : \" \u003c \") + this);\n        }\n        if (months \u003d\u003d 0) {\n            long steps \u003d (until - sign) / days; // non-negative\n            return LongStream.rangeClosed(0, steps).mapToObj(\n                    n -\u003e LocalDate.ofEpochDay(start + n * days));\n        }\n        // 48699/1600 \u003d 365.2425/12, no overflow, non-negative result\n        long steps \u003d until * 1600 / (months * 48699 + days * 1600) + 1;\n        long addMonths \u003d months * steps;\n        long addDays \u003d days * steps;\n        long maxAddMonths \u003d months \u003e 0 ? MAX.getProlepticMonth() - getProlepticMonth()\n                : getProlepticMonth() - MIN.getProlepticMonth();\n        // adjust steps estimation\n        if (addMonths * sign \u003e maxAddMonths\n                || (plusMonths(addMonths).toEpochDay() + addDays) * sign \u003e\u003d end * sign) {\n            steps--;\n            addMonths -\u003d months;\n            addDays -\u003d days;\n            if (addMonths * sign \u003e maxAddMonths\n                    || (plusMonths(addMonths).toEpochDay() + addDays) * sign \u003e\u003d end * sign) {\n                steps--;\n            }\n        }\n        return LongStream.rangeClosed(0, steps).mapToObj(\n                n -\u003e this.plusMonths(months * n).plusDays(days * n));\n    }\n\n    /**\n     * Formats this date using the specified formatter.\n     * \u003cp\u003e\n     * This date will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    @Override  // override for Javadoc and performance\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param time  the time to combine with, not null\n     * @return the local date-time formed from this date and the specified time, not null\n     */\n    @Override\n    public LocalDateTime atTime(LocalTime time) {\n        return LocalDateTime.of(this, time);\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour and minute.\n     * The seconds and nanosecond fields will be set to zero.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute) {\n        return atTime(LocalTime.of(hour, minute));\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour, minute and second.\n     * The nanosecond field will be set to zero.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute, int second) {\n        return atTime(LocalTime.of(hour, minute, second));\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour, minute, second and nanosecond.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute, int second, int nanoOfSecond) {\n        return atTime(LocalTime.of(hour, minute, second, nanoOfSecond));\n    }\n\n    /**\n     * Combines this date with an offset time to create an {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param time  the time to combine with, not null\n     * @return the offset date-time formed from this date and the specified time, not null\n     */\n    public OffsetDateTime atTime(OffsetTime time) {\n        return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.getOffset());\n    }\n\n    /**\n     * Combines this date with the time of midnight to create a {@code LocalDateTime}\n     * at the start of this date.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the time of\n     * midnight, 00:00, at the start of this date.\n     *\n     * @return the local date-time of midnight at the start of this date, not null\n     */\n    public LocalDateTime atStartOfDay() {\n        return LocalDateTime.of(this, LocalTime.MIDNIGHT);\n    }\n\n    /**\n     * Returns a zoned date-time from this date at the earliest valid time according\n     * to the rules in the time-zone.\n     * \u003cp\u003e\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may not be midnight.\n     * \u003cp\u003e\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, there are two valid offsets, and the earlier one is used,\n     * corresponding to the first occurrence of midnight on the date.\n     * In the case of a gap, the zoned date-time will represent the instant just after the gap.\n     * \u003cp\u003e\n     * If the zone ID is a {@link ZoneOffset}, then the result always has a time of midnight.\n     * \u003cp\u003e\n     * To convert to a specific time in a given time-zone call {@link #atTime(LocalTime)}\n     * followed by {@link LocalDateTime#atZone(ZoneId)}.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atStartOfDay(ZoneId zone) {\n        Objects.requireNonNull(zone, \"zone\");\n        // need to handle case where there is a gap from 11:30 to 00:30\n        // standard ZDT factory would result in 01:00 rather than 00:30\n        LocalDateTime ldt \u003d atTime(LocalTime.MIDNIGHT);\n        if (zone instanceof ZoneOffset \u003d\u003d false) {\n            ZoneRules rules \u003d zone.getRules();\n            ZoneOffsetTransition trans \u003d rules.getTransition(ldt);\n            if (trans !\u003d null \u0026\u0026 trans.isGap()) {\n                ldt \u003d trans.getDateTimeAfter();\n            }\n        }\n        return ZonedDateTime.of(ldt, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public long toEpochDay() {\n        long y \u003d year;\n        long m \u003d month;\n        long total \u003d 0;\n        total +\u003d 365 * y;\n        if (y \u003e\u003d 0) {\n            total +\u003d (y + 3) / 4 - (y + 99) / 100 + (y + 399) / 400;\n        } else {\n            total -\u003d y / -4 - y / -100 + y / -400;\n        }\n        total +\u003d ((367 * m - 362) / 12);\n        total +\u003d day - 1;\n        if (m \u003e 2) {\n            total--;\n            if (isLeapYear() \u003d\u003d false) {\n                total--;\n            }\n        }\n        return total - DAYS_0000_TO_1970;\n    }\n\n    /**\n     * Converts this {@code LocalDate} to the number of seconds since the epoch\n     * of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This combines this local date with the specified time and\n     * offset to calculate the epoch-second value, which is the\n     * number of elapsed seconds from 1970-01-01T00:00:00Z.\n     * Instants on the time-line after the epoch are positive, earlier\n     * are negative.\n     *\n     * @param time the local time, not null\n     * @param offset the zone offset, not null\n     * @return the number of seconds since the epoch of 1970-01-01T00:00:00Z, may be negative\n     * @since 9\n     */\n    public long toEpochSecond(LocalTime time, ZoneOffset offset) {\n        Objects.requireNonNull(time, \"time\");\n        Objects.requireNonNull(offset, \"offset\");\n        long secs \u003d toEpochDay() * SECONDS_PER_DAY + time.toSecondOfDay();\n        secs -\u003d offset.getTotalSeconds();\n        return secs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date to another date.\n     * \u003cp\u003e\n     * The comparison is primarily based on the date, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * If all the dates being compared are instances of {@code LocalDate},\n     * then the comparison will be entirely based on the date.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link java.time.chrono.ChronoLocalDate#compareTo}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override  // override for Javadoc and performance\n    public int compareTo(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other);\n        }\n        return ChronoLocalDate.super.compareTo(other);\n    }\n\n    int compareTo0(LocalDate otherDate) {\n        int cmp \u003d (year - otherDate.year);\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d (month - otherDate.month);\n            if (cmp \u003d\u003d 0) {\n                cmp \u003d (day - otherDate.day);\n            }\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date is after the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents a point on the\n     * local time-line after the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isAfter(b) \u003d\u003d false\n     *   a.isAfter(a) \u003d\u003d false\n     *   b.isAfter(a) \u003d\u003d true\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is after the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isAfter(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003e 0;\n        }\n        return ChronoLocalDate.super.isAfter(other);\n    }\n\n    /**\n     * Checks if this date is before the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents a point on the\n     * local time-line before the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isBefore(b) \u003d\u003d true\n     *   a.isBefore(a) \u003d\u003d false\n     *   b.isBefore(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is before the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isBefore(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003c 0;\n        }\n        return ChronoLocalDate.super.isBefore(other);\n    }\n\n    /**\n     * Checks if this date is equal to the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents the same point on the\n     * local time-line as the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isEqual(b) \u003d\u003d false\n     *   a.isEqual(a) \u003d\u003d true\n     *   b.isEqual(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)}\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is equal to the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isEqual(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003d\u003d 0;\n        }\n        return ChronoLocalDate.super.isEqual(other);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date is equal to another date.\n     * \u003cp\u003e\n     * Compares this {@code LocalDate} with another ensuring that the date is the same.\n     * \u003cp\u003e\n     * Only objects of type {@code LocalDate} are compared, other types return false.\n     * To compare the dates of two {@code TemporalAccessor} instances, including dates\n     * in two different chronologies, use {@link ChronoField#EPOCH_DAY} as a comparator.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof LocalDate) {\n            return compareTo0((LocalDate) obj) \u003d\u003d 0;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        int yearValue \u003d year;\n        int monthValue \u003d month;\n        int dayValue \u003d day;\n        return (yearValue \u0026 0xFFFFF800) ^ ((yearValue \u003c\u003c 11) + (monthValue \u003c\u003c 6) + (dayValue));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date as a {@code String}, such as {@code 2007-12-03}.\n     * \u003cp\u003e\n     * The output will be in the ISO-8601 format {@code uuuu-MM-dd}.\n     *\n     * @return a string representation of this date, not null\n     */\n    @Override\n    public String toString() {\n        int yearValue \u003d year;\n        int monthValue \u003d month;\n        int dayValue \u003d day;\n        int absYear \u003d Math.abs(yearValue);\n        StringBuilder buf \u003d new StringBuilder(10);\n        if (absYear \u003c 1000) {\n            if (yearValue \u003c 0) {\n                buf.append(yearValue - 10000).deleteCharAt(1);\n            } else {\n                buf.append(yearValue + 10000).deleteCharAt(0);\n            }\n        } else {\n            if (yearValue \u003e 9999) {\n                buf.append(\u0027+\u0027);\n            }\n            buf.append(yearValue);\n        }\n        return buf.append(monthValue \u003c 10 ? \"-0\" : \"-\")\n            .append(monthValue)\n            .append(dayValue \u003c 10 ? \"-0\" : \"-\")\n            .append(dayValue)\n            .toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(3);  // identifies a LocalDate\n     *  out.writeInt(year);\n     *  out.writeByte(month);\n     *  out.writeByte(day);\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.LOCAL_DATE_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(DataOutput out) throws IOException {\n        out.writeInt(year);\n        out.writeByte(month);\n        out.writeByte(day);\n    }\n\n    static LocalDate readExternal(DataInput in) throws IOException {\n        int year \u003d in.readInt();\n        int month \u003d in.readByte();\n        int dayOfMonth \u003d in.readByte();\n        return LocalDate.of(year, month, dayOfMonth);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 18, 2024 3:04:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java"
  ]
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.18 15:04:47 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:545)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	jdk.internal.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:04:47 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:443)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	jdk.internal.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:04:47 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:04:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

2024.10.18 15:04:47 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.codeLens(WorkspaceLspService.scala:530)
	scala.meta.metals.lsp.DelegatingScalaService.codeLens(DelegatingScalaService.scala:150)
	jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:04:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$3(MetalsLspService.scala:1225)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$2(MetalsLspService.scala:1224)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:04:47 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.documentSymbol(WorkspaceLspService.scala:460)
	scala.meta.metals.lsp.DelegatingScalaService.documentSymbol(DelegatingScalaService.scala:91)
	jdk.internal.reflect.GeneratedMethodAccessor5.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:04:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$documentSymbol$1(MetalsLspService.scala:1055)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:04:47 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:04:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

2024.10.18 15:04:52 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:443)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	jdk.internal.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:04:54 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:443)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	jdk.internal.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:04:58 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.18 15:05:00 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.LocalTime.SECONDS_PER_DAY;\nimport static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH;\nimport static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR;\nimport static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_MONTH;\nimport static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_YEAR;\nimport static java.time.temporal.ChronoField.DAY_OF_MONTH;\nimport static java.time.temporal.ChronoField.DAY_OF_YEAR;\nimport static java.time.temporal.ChronoField.EPOCH_DAY;\nimport static java.time.temporal.ChronoField.ERA;\nimport static java.time.temporal.ChronoField.MONTH_OF_YEAR;\nimport static java.time.temporal.ChronoField.PROLEPTIC_MONTH;\nimport static java.time.temporal.ChronoField.YEAR;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.ChronoLocalDate;\nimport java.time.chrono.IsoEra;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneOffsetTransition;\nimport java.time.zone.ZoneRules;\nimport java.util.Objects;\nimport java.util.stream.LongStream;\nimport java.util.stream.Stream;\n\n/**\n * A date without a time-zone in the ISO-8601 calendar system,\n * such as {@code 2007-12-03}.\n * \u003cp\u003e\n * {@code LocalDate} is an immutable date-time object that represents a date,\n * often viewed as year-month-day. Other date fields, such as day-of-year,\n * day-of-week and week-of-year, can also be accessed.\n * For example, the value \"2nd October 2007\" can be stored in a {@code LocalDate}.\n * \u003cp\u003e\n * This class does not store or represent a time or time-zone.\n * Instead, it is a description of the date, as used for birthdays.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n * \u003cp\u003e\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today\u0027s rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code LocalDate} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class LocalDate\n        implements Temporal, TemporalAdjuster, ChronoLocalDate, Serializable {\n\n    /**\n     * The minimum supported {@code LocalDate}, \u0027-999999999-01-01\u0027.\n     * This could be used by an application as a \"far past\" date.\n     */\n    public static final LocalDate MIN \u003d LocalDate.of(Year.MIN_VALUE, 1, 1);\n    /**\n     * The maximum supported {@code LocalDate}, \u0027+999999999-12-31\u0027.\n     * This could be used by an application as a \"far future\" date.\n     */\n    public static final LocalDate MAX \u003d LocalDate.of(Year.MAX_VALUE, 12, 31);\n    /**\n     * The epoch year {@code LocalDate}, \u00271970-01-01\u0027.\n     */\n    public static final LocalDate EPOCH \u003d LocalDate.of(1970, 1, 1);\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 2942565459149668126L;\n    /**\n     * The number of days in a 400 year cycle.\n     */\n    private static final int DAYS_PER_CYCLE \u003d 146097;\n    /**\n     * The number of days from year zero to year 1970.\n     * There are five 400 year cycles from year zero to 2000.\n     * There are 7 leap years from 1970 to 2000.\n     */\n    static final long DAYS_0000_TO_1970 \u003d (DAYS_PER_CYCLE * 5L) - (30L * 365L + 7L);\n\n    /**\n     * The year.\n     */\n    private final int year;\n    /**\n     * The month-of-year.\n     */\n    private final short month;\n    /**\n     * The day-of-month.\n     */\n    private final short day;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date using the system clock and default time-zone, not null\n     */\n    public static LocalDate now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date using the system clock, not null\n     */\n    public static LocalDate now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date - today.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date, not null\n     */\n    public static LocalDate now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        return ofInstant(now, clock.getZone());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a year, month and day.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDate of(int year, Month month, int dayOfMonth) {\n        YEAR.checkValidValue(year);\n        Objects.requireNonNull(month, \"month\");\n        DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        return create(year, month.getValue(), dayOfMonth);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDate} from a year, month and day.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDate of(int year, int month, int dayOfMonth) {\n        YEAR.checkValidValue(year);\n        MONTH_OF_YEAR.checkValidValue(month);\n        DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        return create(year, month, dayOfMonth);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a year and day-of-year.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year and day-of-year.\n     * The day-of-year must be valid for the year, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param dayOfYear  the day-of-year to represent, from 1 to 366\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-year is invalid for the year\n     */\n    public static LocalDate ofYearDay(int year, int dayOfYear) {\n        YEAR.checkValidValue(year);\n        DAY_OF_YEAR.checkValidValue(dayOfYear);\n        boolean leap \u003d IsoChronology.INSTANCE.isLeapYear(year);\n        if (dayOfYear \u003d\u003d 366 \u0026\u0026 leap \u003d\u003d false) {\n            throw new DateTimeException(\"Invalid date \u0027DayOfYear 366\u0027 as \u0027\" + year + \"\u0027 is not a leap year\");\n        }\n        Month moy \u003d Month.of((dayOfYear - 1) / 31 + 1);\n        int monthEnd \u003d moy.firstDayOfYear(leap) + moy.length(leap) - 1;\n        if (dayOfYear \u003e monthEnd) {\n            moy \u003d moy.plus(1);\n        }\n        int dom \u003d dayOfYear - moy.firstDayOfYear(leap) + 1;\n        return new LocalDate(year, moy.getValue(), dom);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates a local date based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date.\n     *\n     * @param instant  the instant to create the date from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the local date, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     * @since 9\n     */\n    public static LocalDate ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        long localSecond \u003d instant.getEpochSecond() + offset.getTotalSeconds();\n        long localEpochDay \u003d Math.floorDiv(localSecond, SECONDS_PER_DAY);\n        return ofEpochDay(localEpochDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from the epoch day count.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified epoch-day.\n     * The {@link ChronoField#EPOCH_DAY EPOCH_DAY} is a simple incrementing count\n     * of days where day 0 is 1970-01-01. Negative numbers represent earlier days.\n     *\n     * @param epochDay  the Epoch Day to convert, based on the epoch 1970-01-01\n     * @return the local date, not null\n     * @throws DateTimeException if the epoch day exceeds the supported date range\n     */\n    public static LocalDate ofEpochDay(long epochDay) {\n        EPOCH_DAY.checkValidValue(epochDay);\n        long zeroDay \u003d epochDay + DAYS_0000_TO_1970;\n        // find the march-based year\n        zeroDay -\u003d 60;  // adjust to 0000-03-01 so leap day is at end of four year cycle\n        long adjust \u003d 0;\n        if (zeroDay \u003c 0) {\n            // adjust negative years to positive for calculation\n            long adjustCycles \u003d (zeroDay + 1) / DAYS_PER_CYCLE - 1;\n            adjust \u003d adjustCycles * 400;\n            zeroDay +\u003d -adjustCycles * DAYS_PER_CYCLE;\n        }\n        long yearEst \u003d (400 * zeroDay + 591) / DAYS_PER_CYCLE;\n        long doyEst \u003d zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);\n        if (doyEst \u003c 0) {\n            // fix estimate\n            yearEst--;\n            doyEst \u003d zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);\n        }\n        yearEst +\u003d adjust;  // reset any negative year\n        int marchDoy0 \u003d (int) doyEst;\n\n        // convert march-based values back to january-based\n        int marchMonth0 \u003d (marchDoy0 * 5 + 2) / 153;\n        int month \u003d (marchMonth0 + 2) % 12 + 1;\n        int dom \u003d marchDoy0 - (marchMonth0 * 306 + 5) / 10 + 1;\n        yearEst +\u003d marchMonth0 / 10;\n\n        // check year now we are certain it is correct\n        int year \u003d YEAR.checkValidIntValue(yearEst);\n        return new LocalDate(year, month, dom);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a temporal object.\n     * \u003cp\u003e\n     * This obtains a local date based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code LocalDate}.\n     * \u003cp\u003e\n     * The conversion uses the {@link TemporalQueries#localDate()} query, which relies\n     * on extracting the {@link ChronoField#EPOCH_DAY EPOCH_DAY} field.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code LocalDate::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the local date, not null\n     * @throws DateTimeException if unable to convert to a {@code LocalDate}\n     */\n    public static LocalDate from(TemporalAccessor temporal) {\n        Objects.requireNonNull(temporal, \"temporal\");\n        LocalDate date \u003d temporal.query(TemporalQueries.localDate());\n        if (date \u003d\u003d null) {\n            throw new DateTimeException(\"Unable to obtain LocalDate from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName());\n        }\n        return date;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a text string such as {@code 2007-12-03}.\n     * \u003cp\u003e\n     * The string must represent a valid date and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_DATE}.\n     *\n     * @param text  the text to parse such as \"2007-12-03\", not null\n     * @return the parsed local date, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDate parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_LOCAL_DATE);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDate} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed local date, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDate parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, LocalDate::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a local date from the year, month and day fields.\n     *\n     * @param year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 to 12, validated\n     * @param dayOfMonth  the day-of-month to represent, validated from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the day-of-month is invalid for the month-year\n     */\n    private static LocalDate create(int year, int month, int dayOfMonth) {\n        if (dayOfMonth \u003e 28) {\n            int dom \u003d 31;\n            switch (month) {\n                case 2:\n                    dom \u003d (IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n                    break;\n                case 4:\n                case 6:\n                case 9:\n                case 11:\n                    dom \u003d 30;\n                    break;\n            }\n            if (dayOfMonth \u003e dom) {\n                if (dayOfMonth \u003d\u003d 29) {\n                    throw new DateTimeException(\"Invalid date \u0027February 29\u0027 as \u0027\" + year + \"\u0027 is not a leap year\");\n                } else {\n                    throw new DateTimeException(\"Invalid date \u0027\" + Month.of(month).name() + \" \" + dayOfMonth + \"\u0027\");\n                }\n            }\n        }\n        return new LocalDate(year, month, dayOfMonth);\n    }\n\n    /**\n     * Resolves the date, resolving days past the end of month.\n     *\n     * @param year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, validated from 1 to 12\n     * @param day  the day-of-month to represent, validated from 1 to 31\n     * @return the resolved date, not null\n     */\n    private static LocalDate resolvePreviousValid(int year, int month, int day) {\n        switch (month) {\n            case 2:\n                day \u003d Math.min(day, IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n                break;\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                day \u003d Math.min(day, 30);\n                break;\n        }\n        return new LocalDate(year, month, day);\n    }\n\n    /**\n     * Constructor, previously validated.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, valid for year-month, from 1 to 31\n     */\n    private LocalDate(int year, int month, int dayOfMonth) {\n        this.year \u003d year;\n        this.month \u003d (short) month;\n        this.day \u003d (short) dayOfMonth;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalField field) {\n        return ChronoLocalDate.super.isSupported(field);\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        return ChronoLocalDate.super.isSupported(unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            if (f.isDateBased()) {\n                switch (f) {\n                    case DAY_OF_MONTH: return ValueRange.of(1, lengthOfMonth());\n                    case DAY_OF_YEAR: return ValueRange.of(1, lengthOfYear());\n                    case ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, getMonth() \u003d\u003d Month.FEBRUARY \u0026\u0026 isLeapYear() \u003d\u003d false ? 4 : 5);\n                    case YEAR_OF_ERA:\n                        return (getYear() \u003c\u003d 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n                }\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date, except {@code EPOCH_DAY} and {@code PROLEPTIC_MONTH}\n     * which are too large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc and performance\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            return get0(field);\n        }\n        return ChronoLocalDate.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            if (field \u003d\u003d EPOCH_DAY) {\n                return toEpochDay();\n            }\n            if (field \u003d\u003d PROLEPTIC_MONTH) {\n                return getProlepticMonth();\n            }\n            return get0(field);\n        }\n        return field.getFrom(this);\n    }\n\n    private int get0(TemporalField field) {\n        switch ((ChronoField) field) {\n            case DAY_OF_WEEK: return getDayOfWeek().getValue();\n            case ALIGNED_DAY_OF_WEEK_IN_MONTH: return ((day - 1) % 7) + 1;\n            case ALIGNED_DAY_OF_WEEK_IN_YEAR: return ((getDayOfYear() - 1) % 7) + 1;\n            case DAY_OF_MONTH: return day;\n            case DAY_OF_YEAR: return getDayOfYear();\n            case EPOCH_DAY: throw new UnsupportedTemporalTypeException(\"Invalid field \u0027EpochDay\u0027 for get() method, use getLong() instead\");\n            case ALIGNED_WEEK_OF_MONTH: return ((day - 1) / 7) + 1;\n            case ALIGNED_WEEK_OF_YEAR: return ((getDayOfYear() - 1) / 7) + 1;\n            case MONTH_OF_YEAR: return month;\n            case PROLEPTIC_MONTH: throw new UnsupportedTemporalTypeException(\"Invalid field \u0027ProlepticMonth\u0027 for get() method, use getLong() instead\");\n            case YEAR_OF_ERA: return (year \u003e\u003d 1 ? year : 1 - year);\n            case YEAR: return year;\n            case ERA: return (year \u003e\u003d 1 ? 1 : 0);\n        }\n        throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n    }\n\n    private long getProlepticMonth() {\n        return (year * 12L + month - 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology of this date, which is the ISO calendar system.\n     * \u003cp\u003e\n     * The {@code Chronology} represents the calendar system in use.\n     * The ISO-8601 calendar system is the modern civil calendar system used today\n     * in most of the world. It is equivalent to the proleptic Gregorian calendar\n     * system, in which today\u0027s rules for leap years are applied for all time.\n     *\n     * @return the ISO chronology, not null\n     */\n    @Override\n    public IsoChronology getChronology() {\n        return IsoChronology.INSTANCE;\n    }\n\n    /**\n     * Gets the era applicable at this date.\n     * \u003cp\u003e\n     * The official ISO-8601 standard does not define eras, however {@code IsoChronology} does.\n     * It defines two eras, \u0027CE\u0027 from year one onwards and \u0027BCE\u0027 from year zero backwards.\n     * Since dates before the Julian-Gregorian cutover are not in line with history,\n     * the cutover between \u0027BCE\u0027 and \u0027CE\u0027 is also not aligned with the commonly used\n     * eras, often referred to using \u0027BC\u0027 and \u0027AD\u0027.\n     * \u003cp\u003e\n     * Users of this class should typically ignore this method as it exists primarily\n     * to fulfill the {@link ChronoLocalDate} contract where it is necessary to support\n     * the Japanese calendar system.\n     *\n     * @return the IsoEra applicable at this date, not null\n     */\n    @Override // override for Javadoc\n    public IsoEra getEra() {\n        return (getYear() \u003e\u003d 1 ? IsoEra.CE : IsoEra.BCE);\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return year;\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return month;\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return Month.of(month);\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return day;\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return getMonth().firstDayOfYear(isLeapYear()) + day - 1;\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        int dow0 \u003d Math.floorMod(toEpochDay() + 3, 7);\n        return DayOfWeek.of(dow0 + 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     * \u003cp\u003e\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     * \u003cp\u003e\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     * \u003cp\u003e\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return true if the year is leap, false otherwise\n     */\n    @Override // override for Javadoc and performance\n    public boolean isLeapYear() {\n        return IsoChronology.INSTANCE.isLeapYear(year);\n    }\n\n    /**\n     * Returns the length of the month represented by this date.\n     * \u003cp\u003e\n     * This returns the length of the month in days.\n     * For example, a date in January would return 31.\n     *\n     * @return the length of the month in days\n     */\n    @Override\n    public int lengthOfMonth() {\n        switch (month) {\n            case 2:\n                return (isLeapYear() ? 29 : 28);\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Returns the length of the year represented by this date.\n     * \u003cp\u003e\n     * This returns the length of the year in days, either 365 or 366.\n     *\n     * @return 366 if the year is leap, 365 otherwise\n     */\n    @Override // override for Javadoc and performance\n    public int lengthOfYear() {\n        return (isLeapYear() ? 366 : 365);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the date adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * \u003cp\u003e\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d localDate.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return a {@code LocalDate} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return (LocalDate) adjuster;\n        }\n        return (LocalDate) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAY_OF_WEEK} -\n     *  Returns a {@code LocalDate} with the specified day-of-week.\n     *  The date is adjusted up to 6 days forward or backward within the boundary\n     *  of a Monday to Sunday week.\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH} -\n     *  Returns a {@code LocalDate} with the specified aligned-day-of-week.\n     *  The date is adjusted to the specified month-based aligned-day-of-week.\n     *  Aligned weeks are counted such that the first week of a given month starts\n     *  on the first day of that month.\n     *  This may cause the date to be moved up to 6 days into the following month.\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR} -\n     *  Returns a {@code LocalDate} with the specified aligned-day-of-week.\n     *  The date is adjusted to the specified year-based aligned-day-of-week.\n     *  Aligned weeks are counted such that the first week of a given year starts\n     *  on the first day of that year.\n     *  This may cause the date to be moved up to 6 days into the following year.\n     * \u003cli\u003e{@code DAY_OF_MONTH} -\n     *  Returns a {@code LocalDate} with the specified day-of-month.\n     *  The month and year will be unchanged. If the day-of-month is invalid for the\n     *  year and month, then a {@code DateTimeException} is thrown.\n     * \u003cli\u003e{@code DAY_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified day-of-year.\n     *  The year will be unchanged. If the day-of-year is invalid for the\n     *  year, then a {@code DateTimeException} is thrown.\n     * \u003cli\u003e{@code EPOCH_DAY} -\n     *  Returns a {@code LocalDate} with the specified epoch-day.\n     *  This completely replaces the date and is equivalent to {@link #ofEpochDay(long)}.\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH} -\n     *  Returns a {@code LocalDate} with the specified aligned-week-of-month.\n     *  Aligned weeks are counted such that the first week of a given month starts\n     *  on the first day of that month.\n     *  This adjustment moves the date in whole week chunks to match the specified week.\n     *  The result will have the same day-of-week as this date.\n     *  This may cause the date to be moved into the following month.\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified aligned-week-of-year.\n     *  Aligned weeks are counted such that the first week of a given year starts\n     *  on the first day of that year.\n     *  This adjustment moves the date in whole week chunks to match the specified week.\n     *  The result will have the same day-of-week as this date.\n     *  This may cause the date to be moved into the following year.\n     * \u003cli\u003e{@code MONTH_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified month-of-year.\n     *  The year will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code PROLEPTIC_MONTH} -\n     *  Returns a {@code LocalDate} with the specified proleptic-month.\n     *  The day-of-month will be unchanged, unless it would be invalid for the new month\n     *  and year. In that case, the day-of-month is adjusted to the maximum valid value\n     *  for the new month and year.\n     * \u003cli\u003e{@code YEAR_OF_ERA} -\n     *  Returns a {@code LocalDate} with the specified year-of-era.\n     *  The era and month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code YEAR} -\n     *  Returns a {@code LocalDate} with the specified year.\n     *  The month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code ERA} -\n     *  Returns a {@code LocalDate} with the specified era.\n     *  The year-of-era and month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return a {@code LocalDate} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            f.checkValidValue(newValue);\n            switch (f) {\n                case DAY_OF_WEEK: return plusDays(newValue - getDayOfWeek().getValue());\n                case ALIGNED_DAY_OF_WEEK_IN_MONTH: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n                case ALIGNED_DAY_OF_WEEK_IN_YEAR: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                case DAY_OF_MONTH: return withDayOfMonth((int) newValue);\n                case DAY_OF_YEAR: return withDayOfYear((int) newValue);\n                case EPOCH_DAY: return LocalDate.ofEpochDay(newValue);\n                case ALIGNED_WEEK_OF_MONTH: return plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_MONTH));\n                case ALIGNED_WEEK_OF_YEAR: return plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_YEAR));\n                case MONTH_OF_YEAR: return withMonth((int) newValue);\n                case PROLEPTIC_MONTH: return plusMonths(newValue - getProlepticMonth());\n                case YEAR_OF_ERA: return withYear((int) (year \u003e\u003d 1 ? newValue : 1 - newValue));\n                case YEAR: return withYear((int) newValue);\n                case ERA: return (getLong(ERA) \u003d\u003d newValue ? this : withYear(1 - year));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the year altered.\n     * \u003cp\u003e\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return a {@code LocalDate} based on this date with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public LocalDate withYear(int year) {\n        if (this.year \u003d\u003d year) {\n            return this;\n        }\n        YEAR.checkValidValue(year);\n        return resolvePreviousValid(year, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the month-of-year altered.\n     * \u003cp\u003e\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return a {@code LocalDate} based on this date with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public LocalDate withMonth(int month) {\n        if (this.month \u003d\u003d month) {\n            return this;\n        }\n        MONTH_OF_YEAR.checkValidValue(month);\n        return resolvePreviousValid(year, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting date is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return a {@code LocalDate} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public LocalDate withDayOfMonth(int dayOfMonth) {\n        if (this.day \u003d\u003d dayOfMonth) {\n            return this;\n        }\n        return of(year, month, dayOfMonth);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the day-of-year altered.\n     * \u003cp\u003e\n     * If the resulting date is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return a {@code LocalDate} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public LocalDate withDayOfYear(int dayOfYear) {\n        if (this.getDayOfYear() \u003d\u003d dayOfYear) {\n            return this;\n        }\n        return ofYearDay(year, dayOfYear);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return a {@code LocalDate} based on this date with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate plus(TemporalAmount amountToAdd) {\n        if (amountToAdd instanceof Period) {\n            Period periodToAdd \u003d (Period) amountToAdd;\n            return plusMonths(periodToAdd.toTotalMonths()).plusDays(periodToAdd.getDays());\n        }\n        Objects.requireNonNull(amountToAdd, \"amountToAdd\");\n        return (LocalDate) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, adding the amount can cause the resulting date to become invalid.\n     * For example, adding one month to 31st January would result in 31st February.\n     * In cases like this, the unit is responsible for resolving the date.\n     * Typically it will choose the previous valid date, which would be the last valid\n     * day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented here.\n     * The supported fields behave as follows:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAYS} -\n     *  Returns a {@code LocalDate} with the specified number of days added.\n     *  This is equivalent to {@link #plusDays(long)}.\n     * \u003cli\u003e{@code WEEKS} -\n     *  Returns a {@code LocalDate} with the specified number of weeks added.\n     *  This is equivalent to {@link #plusWeeks(long)} and uses a 7 day week.\n     * \u003cli\u003e{@code MONTHS} -\n     *  Returns a {@code LocalDate} with the specified number of months added.\n     *  This is equivalent to {@link #plusMonths(long)}.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code YEARS} -\n     *  Returns a {@code LocalDate} with the specified number of years added.\n     *  This is equivalent to {@link #plusYears(long)}.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code DECADES} -\n     *  Returns a {@code LocalDate} with the specified number of decades added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 10.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code CENTURIES} -\n     *  Returns a {@code LocalDate} with the specified number of centuries added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 100.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code MILLENNIA} -\n     *  Returns a {@code LocalDate} with the specified number of millennia added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 1,000.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code ERAS} -\n     *  Returns a {@code LocalDate} with the specified number of eras added.\n     *  Only two eras are supported so the amount must be one, zero or minus one.\n     *  If the amount is non-zero then the year is changed such that the year-of-era\n     *  is unchanged.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * All other {@code ChronoUnit} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return a {@code LocalDate} based on this date with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            ChronoUnit f \u003d (ChronoUnit) unit;\n            switch (f) {\n                case DAYS: return plusDays(amountToAdd);\n                case WEEKS: return plusWeeks(amountToAdd);\n                case MONTHS: return plusMonths(amountToAdd);\n                case YEARS: return plusYears(amountToAdd);\n                case DECADES: return plusYears(Math.multiplyExact(amountToAdd, 10));\n                case CENTURIES: return plusYears(Math.multiplyExact(amountToAdd, 100));\n                case MILLENNIA: return plusYears(Math.multiplyExact(amountToAdd, 1000));\n                case ERAS: return with(ERA, Math.addExact(getLong(ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param yearsToAdd  the years to add, may be negative\n     * @return a {@code LocalDate} based on this date with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusYears(long yearsToAdd) {\n        if (yearsToAdd \u003d\u003d 0) {\n            return this;\n        }\n        int newYear \u003d YEAR.checkValidIntValue(year + yearsToAdd);  // safe overflow\n        return resolvePreviousValid(newYear, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param monthsToAdd  the months to add, may be negative\n     * @return a {@code LocalDate} based on this date with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusMonths(long monthsToAdd) {\n        if (monthsToAdd \u003d\u003d 0) {\n            return this;\n        }\n        long monthCount \u003d year * 12L + (month - 1);\n        long calcMonths \u003d monthCount + monthsToAdd;  // safe overflow\n        int newYear \u003d YEAR.checkValidIntValue(Math.floorDiv(calcMonths, 12));\n        int newMonth \u003d Math.floorMod(calcMonths, 12) + 1;\n        return resolvePreviousValid(newYear, newMonth, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeksToAdd  the weeks to add, may be negative\n     * @return a {@code LocalDate} based on this date with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusWeeks(long weeksToAdd) {\n        return plusDays(Math.multiplyExact(weeksToAdd, 7));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param daysToAdd  the days to add, may be negative\n     * @return a {@code LocalDate} based on this date with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusDays(long daysToAdd) {\n        if (daysToAdd \u003d\u003d 0) {\n            return this;\n        }\n        long dom \u003d day + daysToAdd;\n        if (dom \u003e 0) {\n            if (dom \u003c\u003d 28) {\n                return new LocalDate(year, month, (int) dom);\n            } else if (dom \u003c\u003d 59) { // 59th Jan is 28th Feb, 59th Feb is 31st Mar\n                long monthLen \u003d lengthOfMonth();\n                if (dom \u003c\u003d monthLen) {\n                    return new LocalDate(year, month, (int) dom);\n                } else if (month \u003c 12) {\n                    return new LocalDate(year, month + 1, (int) (dom - monthLen));\n                } else {\n                    YEAR.checkValidValue(year + 1);\n                    return new LocalDate(year + 1, 1, (int) (dom - monthLen));\n                }\n            }\n        }\n\n        long mjDay \u003d Math.addExact(toEpochDay(), daysToAdd);\n        return LocalDate.ofEpochDay(mjDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return a {@code LocalDate} based on this date with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate minus(TemporalAmount amountToSubtract) {\n        if (amountToSubtract instanceof Period) {\n            Period periodToSubtract \u003d (Period) amountToSubtract;\n            return minusMonths(periodToSubtract.toTotalMonths()).minusDays(periodToSubtract.getDays());\n        }\n        Objects.requireNonNull(amountToSubtract, \"amountToSubtract\");\n        return (LocalDate) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return a {@code LocalDate} based on this date with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param yearsToSubtract  the years to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusYears(long yearsToSubtract) {\n        return (yearsToSubtract \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-yearsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param monthsToSubtract  the months to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusMonths(long monthsToSubtract) {\n        return (monthsToSubtract \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-monthsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeksToSubtract  the weeks to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusWeeks(long weeksToSubtract) {\n        return (weeksToSubtract \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeksToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param daysToSubtract  the days to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusDays(long daysToSubtract) {\n        return (daysToSubtract \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-daysToSubtract));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date using the specified query.\n     * \u003cp\u003e\n     * This queries this date using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) this;\n        }\n        return ChronoLocalDate.super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the date changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * passing {@link ChronoField#EPOCH_DAY} as the field.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisLocalDate.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisLocalDate);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc\n    public Temporal adjustInto(Temporal temporal) {\n        return ChronoLocalDate.super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the amount of time until another date in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code LocalDate}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code LocalDate} using {@link #from(TemporalAccessor)}.\n     * For example, the amount in days between two dates can be calculated\n     * using {@code startDate.until(endDate, DAYS)}.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two dates.\n     * For example, the amount in months between 2012-06-15 and 2012-08-14\n     * will only be one month as it is one day short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code DAYS}, {@code WEEKS}, {@code MONTHS}, {@code YEARS},\n     * {@code DECADES}, {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS}\n     * are supported. Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to a {@code LocalDate}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date and the end date\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to a {@code LocalDate}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        LocalDate end \u003d LocalDate.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch ((ChronoUnit) unit) {\n                case DAYS: return daysUntil(end);\n                case WEEKS: return daysUntil(end) / 7;\n                case MONTHS: return monthsUntil(end);\n                case YEARS: return monthsUntil(end) / 12;\n                case DECADES: return monthsUntil(end) / 120;\n                case CENTURIES: return monthsUntil(end) / 1200;\n                case MILLENNIA: return monthsUntil(end) / 12000;\n                case ERAS: return end.getLong(ERA) - getLong(ERA);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    long daysUntil(LocalDate end) {\n        return end.toEpochDay() - toEpochDay();  // no overflow\n    }\n\n    private long monthsUntil(LocalDate end) {\n        long packed1 \u003d getProlepticMonth() * 32L + getDayOfMonth();  // no overflow\n        long packed2 \u003d end.getProlepticMonth() * 32L + end.getDayOfMonth();  // no overflow\n        return (packed2 - packed1) / 32;\n    }\n\n    /**\n     * Calculates the period between this date and another date as a {@code Period}.\n     * \u003cp\u003e\n     * This calculates the period between two dates in terms of years, months and days.\n     * The start and end points are {@code this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The negative sign will be the same in each of year, month and day.\n     * \u003cp\u003e\n     * The calculation is performed using the ISO calendar system.\n     * If necessary, the input date will be converted to ISO.\n     * \u003cp\u003e\n     * The start date is included, but the end date is not.\n     * The period is calculated by removing complete months, then calculating\n     * the remaining number of days, adjusting to ensure that both have the same sign.\n     * The number of months is then normalized into years and months based on a 12 month year.\n     * A month is considered to be complete if the end day-of-month is greater\n     * than or equal to the start day-of-month.\n     * For example, from {@code 2010-01-15} to {@code 2011-03-18} is \"1 year, 2 months and 3 days\".\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link Period#between(LocalDate, LocalDate)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   period \u003d start.until(end);\n     *   period \u003d Period.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     *\n     * @param endDateExclusive  the end date, exclusive, which may be in any chronology, not null\n     * @return the period between this date and the end date, not null\n     */\n    @Override\n    public Period until(ChronoLocalDate endDateExclusive) {\n        LocalDate end \u003d LocalDate.from(endDateExclusive);\n        long totalMonths \u003d end.getProlepticMonth() - this.getProlepticMonth();  // safe\n        int days \u003d end.day - this.day;\n        if (totalMonths \u003e 0 \u0026\u0026 days \u003c 0) {\n            totalMonths--;\n            LocalDate calcDate \u003d this.plusMonths(totalMonths);\n            days \u003d (int) (end.toEpochDay() - calcDate.toEpochDay());  // safe\n        } else if (totalMonths \u003c 0 \u0026\u0026 days \u003e 0) {\n            totalMonths++;\n            days -\u003d end.lengthOfMonth();\n        }\n        long years \u003d totalMonths / 12;  // safe\n        int months \u003d (int) (totalMonths % 12);  // safe\n        return Period.of(Math.toIntExact(years), months, days);\n    }\n\n    /**\n     * Returns a sequential ordered stream of dates. The returned stream starts from this date\n     * (inclusive) and goes to {@code endExclusive} (exclusive) by an incremental step of 1 day.\n     * \u003cp\u003e\n     * This method is equivalent to {@code datesUntil(endExclusive, Period.ofDays(1))}.\n     *\n     * @param endExclusive  the end date, exclusive, not null\n     * @return a sequential {@code Stream} for the range of {@code LocalDate} values\n     * @throws IllegalArgumentException if end date is before this date\n     * @since 9\n     */\n    public Stream\u003cLocalDate\u003e datesUntil(LocalDate endExclusive) {\n        long end \u003d endExclusive.toEpochDay();\n        long start \u003d toEpochDay();\n        if (end \u003c start) {\n            throw new IllegalArgumentException(endExclusive + \" \u003c \" + this);\n        }\n        return LongStream.range(start, end).mapToObj(LocalDate::ofEpochDay);\n    }\n\n    /**\n     * Returns a sequential ordered stream of dates by given incremental step. The returned stream\n     * starts from this date (inclusive) and goes to {@code endExclusive} (exclusive).\n     * \u003cp\u003e\n     * The n-th date which appears in the stream is equal to {@code this.plus(step.multipliedBy(n))}\n     * (but the result of step multiplication never overflows). For example, if this date is\n     * {@code 2015-01-31}, the end date is {@code 2015-05-01} and the step is 1 month, then the\n     * stream contains {@code 2015-01-31}, {@code 2015-02-28}, {@code 2015-03-31}, and\n     * {@code 2015-04-30}.\n     *\n     * @param endExclusive  the end date, exclusive, not null\n     * @param step  the non-zero, non-negative {@code Period} which represents the step.\n     * @return a sequential {@code Stream} for the range of {@code LocalDate} values\n     * @throws IllegalArgumentException if step is zero, or {@code step.getDays()} and\n     *             {@code step.toTotalMonths()} have opposite sign, or end date is before this date\n     *             and step is positive, or end date is after this date and step is negative\n     * @since 9\n     */\n    public Stream\u003cLocalDate\u003e datesUntil(LocalDate endExclusive, Period step) {\n        if (step.isZero()) {\n            throw new IllegalArgumentException(\"step is zero\");\n        }\n        long end \u003d endExclusive.toEpochDay();\n        long start \u003d toEpochDay();\n        long until \u003d end - start;\n        long months \u003d step.toTotalMonths();\n        long days \u003d step.getDays();\n        if ((months \u003c 0 \u0026\u0026 days \u003e 0) || (months \u003e 0 \u0026\u0026 days \u003c 0)) {\n            throw new IllegalArgumentException(\"period months and days are of opposite sign\");\n        }\n        if (until \u003d\u003d 0) {\n            return Stream.empty();\n        }\n        int sign \u003d months \u003e 0 || days \u003e 0 ? 1 : -1;\n        if (sign \u003c 0 ^ until \u003c 0) {\n            throw new IllegalArgumentException(endExclusive + (sign \u003c 0 ? \" \u003e \" : \" \u003c \") + this);\n        }\n        if (months \u003d\u003d 0) {\n            long steps \u003d (until - sign) / days; // non-negative\n            return LongStream.rangeClosed(0, steps).mapToObj(\n                    n -\u003e LocalDate.ofEpochDay(start + n * days));\n        }\n        // 48699/1600 \u003d 365.2425/12, no overflow, non-negative result\n        long steps \u003d until * 1600 / (months * 48699 + days * 1600) + 1;\n        long addMonths \u003d months * steps;\n        long addDays \u003d days * steps;\n        long maxAddMonths \u003d months \u003e 0 ? MAX.getProlepticMonth() - getProlepticMonth()\n                : getProlepticMonth() - MIN.getProlepticMonth();\n        // adjust steps estimation\n        if (addMonths * sign \u003e maxAddMonths\n                || (plusMonths(addMonths).toEpochDay() + addDays) * sign \u003e\u003d end * sign) {\n            steps--;\n            addMonths -\u003d months;\n            addDays -\u003d days;\n            if (addMonths * sign \u003e maxAddMonths\n                    || (plusMonths(addMonths).toEpochDay() + addDays) * sign \u003e\u003d end * sign) {\n                steps--;\n            }\n        }\n        return LongStream.rangeClosed(0, steps).mapToObj(\n                n -\u003e this.plusMonths(months * n).plusDays(days * n));\n    }\n\n    /**\n     * Formats this date using the specified formatter.\n     * \u003cp\u003e\n     * This date will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    @Override  // override for Javadoc and performance\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param time  the time to combine with, not null\n     * @return the local date-time formed from this date and the specified time, not null\n     */\n    @Override\n    public LocalDateTime atTime(LocalTime time) {\n        return LocalDateTime.of(this, time);\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour and minute.\n     * The seconds and nanosecond fields will be set to zero.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute) {\n        return atTime(LocalTime.of(hour, minute));\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour, minute and second.\n     * The nanosecond field will be set to zero.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute, int second) {\n        return atTime(LocalTime.of(hour, minute, second));\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour, minute, second and nanosecond.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute, int second, int nanoOfSecond) {\n        return atTime(LocalTime.of(hour, minute, second, nanoOfSecond));\n    }\n\n    /**\n     * Combines this date with an offset time to create an {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param time  the time to combine with, not null\n     * @return the offset date-time formed from this date and the specified time, not null\n     */\n    public OffsetDateTime atTime(OffsetTime time) {\n        return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.getOffset());\n    }\n\n    /**\n     * Combines this date with the time of midnight to create a {@code LocalDateTime}\n     * at the start of this date.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the time of\n     * midnight, 00:00, at the start of this date.\n     *\n     * @return the local date-time of midnight at the start of this date, not null\n     */\n    public LocalDateTime atStartOfDay() {\n        return LocalDateTime.of(this, LocalTime.MIDNIGHT);\n    }\n\n    /**\n     * Returns a zoned date-time from this date at the earliest valid time according\n     * to the rules in the time-zone.\n     * \u003cp\u003e\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may not be midnight.\n     * \u003cp\u003e\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, there are two valid offsets, and the earlier one is used,\n     * corresponding to the first occurrence of midnight on the date.\n     * In the case of a gap, the zoned date-time will represent the instant just after the gap.\n     * \u003cp\u003e\n     * If the zone ID is a {@link ZoneOffset}, then the result always has a time of midnight.\n     * \u003cp\u003e\n     * To convert to a specific time in a given time-zone call {@link #atTime(LocalTime)}\n     * followed by {@link LocalDateTime#atZone(ZoneId)}.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atStartOfDay(ZoneId zone) {\n        Objects.requireNonNull(zone, \"zone\");\n        // need to handle case where there is a gap from 11:30 to 00:30\n        // standard ZDT factory would result in 01:00 rather than 00:30\n        LocalDateTime ldt \u003d atTime(LocalTime.MIDNIGHT);\n        if (zone instanceof ZoneOffset \u003d\u003d false) {\n            ZoneRules rules \u003d zone.getRules();\n            ZoneOffsetTransition trans \u003d rules.getTransition(ldt);\n            if (trans !\u003d null \u0026\u0026 trans.isGap()) {\n                ldt \u003d trans.getDateTimeAfter();\n            }\n        }\n        return ZonedDateTime.of(ldt, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public long toEpochDay() {\n        long y \u003d year;\n        long m \u003d month;\n        long total \u003d 0;\n        total +\u003d 365 * y;\n        if (y \u003e\u003d 0) {\n            total +\u003d (y + 3) / 4 - (y + 99) / 100 + (y + 399) / 400;\n        } else {\n            total -\u003d y / -4 - y / -100 + y / -400;\n        }\n        total +\u003d ((367 * m - 362) / 12);\n        total +\u003d day - 1;\n        if (m \u003e 2) {\n            total--;\n            if (isLeapYear() \u003d\u003d false) {\n                total--;\n            }\n        }\n        return total - DAYS_0000_TO_1970;\n    }\n\n    /**\n     * Converts this {@code LocalDate} to the number of seconds since the epoch\n     * of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This combines this local date with the specified time and\n     * offset to calculate the epoch-second value, which is the\n     * number of elapsed seconds from 1970-01-01T00:00:00Z.\n     * Instants on the time-line after the epoch are positive, earlier\n     * are negative.\n     *\n     * @param time the local time, not null\n     * @param offset the zone offset, not null\n     * @return the number of seconds since the epoch of 1970-01-01T00:00:00Z, may be negative\n     * @since 9\n     */\n    public long toEpochSecond(LocalTime time, ZoneOffset offset) {\n        Objects.requireNonNull(time, \"time\");\n        Objects.requireNonNull(offset, \"offset\");\n        long secs \u003d toEpochDay() * SECONDS_PER_DAY + time.toSecondOfDay();\n        secs -\u003d offset.getTotalSeconds();\n        return secs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date to another date.\n     * \u003cp\u003e\n     * The comparison is primarily based on the date, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * If all the dates being compared are instances of {@code LocalDate},\n     * then the comparison will be entirely based on the date.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link java.time.chrono.ChronoLocalDate#compareTo}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override  // override for Javadoc and performance\n    public int compareTo(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other);\n        }\n        return ChronoLocalDate.super.compareTo(other);\n    }\n\n    int compareTo0(LocalDate otherDate) {\n        int cmp \u003d (year - otherDate.year);\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d (month - otherDate.month);\n            if (cmp \u003d\u003d 0) {\n                cmp \u003d (day - otherDate.day);\n            }\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date is after the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents a point on the\n     * local time-line after the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isAfter(b) \u003d\u003d false\n     *   a.isAfter(a) \u003d\u003d false\n     *   b.isAfter(a) \u003d\u003d true\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is after the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isAfter(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003e 0;\n        }\n        return ChronoLocalDate.super.isAfter(other);\n    }\n\n    /**\n     * Checks if this date is before the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents a point on the\n     * local time-line before the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isBefore(b) \u003d\u003d true\n     *   a.isBefore(a) \u003d\u003d false\n     *   b.isBefore(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is before the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isBefore(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003c 0;\n        }\n        return ChronoLocalDate.super.isBefore(other);\n    }\n\n    /**\n     * Checks if this date is equal to the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents the same point on the\n     * local time-line as the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isEqual(b) \u003d\u003d false\n     *   a.isEqual(a) \u003d\u003d true\n     *   b.isEqual(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)}\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is equal to the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isEqual(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003d\u003d 0;\n        }\n        return ChronoLocalDate.super.isEqual(other);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date is equal to another date.\n     * \u003cp\u003e\n     * Compares this {@code LocalDate} with another ensuring that the date is the same.\n     * \u003cp\u003e\n     * Only objects of type {@code LocalDate} are compared, other types return false.\n     * To compare the dates of two {@code TemporalAccessor} instances, including dates\n     * in two different chronologies, use {@link ChronoField#EPOCH_DAY} as a comparator.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof LocalDate) {\n            return compareTo0((LocalDate) obj) \u003d\u003d 0;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        int yearValue \u003d year;\n        int monthValue \u003d month;\n        int dayValue \u003d day;\n        return (yearValue \u0026 0xFFFFF800) ^ ((yearValue \u003c\u003c 11) + (monthValue \u003c\u003c 6) + (dayValue));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date as a {@code String}, such as {@code 2007-12-03}.\n     * \u003cp\u003e\n     * The output will be in the ISO-8601 format {@code uuuu-MM-dd}.\n     *\n     * @return a string representation of this date, not null\n     */\n    @Override\n    public String toString() {\n        int yearValue \u003d year;\n        int monthValue \u003d month;\n        int dayValue \u003d day;\n        int absYear \u003d Math.abs(yearValue);\n        StringBuilder buf \u003d new StringBuilder(10);\n        if (absYear \u003c 1000) {\n            if (yearValue \u003c 0) {\n                buf.append(yearValue - 10000).deleteCharAt(1);\n            } else {\n                buf.append(yearValue + 10000).deleteCharAt(0);\n            }\n        } else {\n            if (yearValue \u003e 9999) {\n                buf.append(\u0027+\u0027);\n            }\n            buf.append(yearValue);\n        }\n        return buf.append(monthValue \u003c 10 ? \"-0\" : \"-\")\n            .append(monthValue)\n            .append(dayValue \u003c 10 ? \"-0\" : \"-\")\n            .append(dayValue)\n            .toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(3);  // identifies a LocalDate\n     *  out.writeInt(year);\n     *  out.writeByte(month);\n     *  out.writeByte(day);\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.LOCAL_DATE_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(DataOutput out) throws IOException {\n        out.writeInt(year);\n        out.writeByte(month);\n        out.writeByte(day);\n    }\n\n    static LocalDate readExternal(DataInput in) throws IOException {\n        int year \u003d in.readInt();\n        int month \u003d in.readByte();\n        int dayOfMonth \u003d in.readByte();\n        return LocalDate.of(year, month, dayOfMonth);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 18, 2024 3:05:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java"
  ]
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.18 15:05:00 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:545)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	jdk.internal.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:05:00 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:443)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	jdk.internal.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:05:00 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

2024.10.18 15:05:00 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.codeLens(WorkspaceLspService.scala:530)
	scala.meta.metals.lsp.DelegatingScalaService.codeLens(DelegatingScalaService.scala:150)
	jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$3(MetalsLspService.scala:1225)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$2(MetalsLspService.scala:1224)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:05:00 INFO  time: code lens generation in 1.97s
2024.10.18 15:05:00 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.documentSymbol(WorkspaceLspService.scala:460)
	scala.meta.metals.lsp.DelegatingScalaService.documentSymbol(DelegatingScalaService.scala:91)
	jdk.internal.reflect.GeneratedMethodAccessor5.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$documentSymbol$1(MetalsLspService.scala:1055)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:05:00 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

oct 18, 2024 3:05:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.18 15:05:04 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/String.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.io.ObjectStreamField;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Native;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Formatter;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Spliterator;\nimport java.util.StringJoiner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\nimport jdk.internal.HotSpotIntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\n\n/**\n * The {@code String} class represents character strings. All\n * string literals in Java programs, such as {@code \"abc\"}, are\n * implemented as instances of this class.\n * \u003cp\u003e\n * Strings are constant; their values cannot be changed after they\n * are created. String buffers support mutable strings.\n * Because String objects are immutable they can be shared. For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     String str \u003d \"abc\";\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * is equivalent to:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     char data[] \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027};\n *     String str \u003d new String(data);\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * Here are some more examples of how strings can be used:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     System.out.println(\"abc\");\n *     String cde \u003d \"cde\";\n *     System.out.println(\"abc\" + cde);\n *     String c \u003d \"abc\".substring(2,3);\n *     String d \u003d cde.substring(1, 2);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * The class {@code String} includes methods for examining\n * individual characters of the sequence, for comparing strings, for\n * searching strings, for extracting substrings, and for creating a\n * copy of a string with all characters translated to uppercase or to\n * lowercase. Case mapping is based on the Unicode Standard version\n * specified by the {@link java.lang.Character Character} class.\n * \u003cp\u003e\n * The Java language provides special support for the string\n * concatenation operator (\u0026nbsp;+\u0026nbsp;), and for conversion of\n * other objects to strings. For additional information on string\n * concatenation and conversion, see \u003ci\u003eThe Java\u0026trade; Language Specification\u003c/i\u003e.\n *\n * \u003cp\u003e Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * \u003cp\u003eA {@code String} represents a string in the UTF-16 format\n * in which \u003cem\u003esupplementary characters\u003c/em\u003e are represented by \u003cem\u003esurrogate\n * pairs\u003c/em\u003e (see the section \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n * Character Representations\u003c/a\u003e in the {@code Character} class for\n * more information).\n * Index values refer to {@code char} code units, so a supplementary\n * character uses two positions in a {@code String}.\n * \u003cp\u003eThe {@code String} class provides methods for dealing with\n * Unicode code points (i.e., characters), in addition to those for\n * dealing with Unicode code units (i.e., {@code char} values).\n *\n * \u003cp\u003eUnless otherwise noted, methods for comparing Strings do not take locale\n * into account.  The {@link java.text.Collator} class provides methods for\n * finer-grain, locale-sensitive String comparison.\n *\n * @implNote The implementation of the string concatenation operator is left to\n * the discretion of a Java compiler, as long as the compiler ultimately conforms\n * to \u003ci\u003eThe Java\u0026trade; Language Specification\u003c/i\u003e. For example, the {@code javac} compiler\n * may implement the operator with {@code StringBuffer}, {@code StringBuilder},\n * or {@code java.lang.invoke.StringConcatFactory} depending on the JDK version. The\n * implementation of string conversion is typically through the method {@code toString},\n * defined by {@code Object} and inherited by all classes in Java.\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Martin Buchholz\n * @author  Ulf Zibis\n * @see     java.lang.Object#toString()\n * @see     java.lang.StringBuffer\n * @see     java.lang.StringBuilder\n * @see     java.nio.charset.Charset\n * @since   1.0\n * @jls     15.18.1 String Concatenation Operator +\n */\n\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n\n    /**\n     * The identifier of the encoding used to encode the bytes in\n     * {@code value}. The supported values in this implementation are\n     *\n     * LATIN1\n     * UTF16\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     */\n    private final byte coder;\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    private static final long serialVersionUID \u003d -6849794470754667710L;\n\n    /**\n     * If String compaction is disabled, the bytes in {@code value} are\n     * always encoded in UTF16.\n     *\n     * For methods with several possible implementation paths, when String\n     * compaction is disabled, only one code path is taken.\n     *\n     * The instance field value is generally opaque to optimizing JIT\n     * compilers. Therefore, in performance-sensitive place, an explicit\n     * check of the static boolean {@code COMPACT_STRINGS} is done first\n     * before checking the {@code coder} field since the static boolean\n     * {@code COMPACT_STRINGS} would be constant folded away by an\n     * optimizing JIT compiler. The idioms for these cases are as follows.\n     *\n     * For code such as:\n     *\n     *    if (coder \u003d\u003d LATIN1) { ... }\n     *\n     * can be written more optimally as\n     *\n     *    if (coder() \u003d\u003d LATIN1) { ... }\n     *\n     * or:\n     *\n     *    if (COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1) { ... }\n     *\n     * An optimizing JIT compiler can fold the above conditional as:\n     *\n     *    COMPACT_STRINGS \u003d\u003d true  \u003d\u003e if (coder \u003d\u003d LATIN1) { ... }\n     *    COMPACT_STRINGS \u003d\u003d false \u003d\u003e if (false)           { ... }\n     *\n     * @implNote\n     * The actual value for this field is injected by JVM. The static\n     * initialization block is used to set the value here to communicate\n     * that this static final field is not statically foldable, and to\n     * avoid any possible circular dependency during vm initialization.\n     */\n    static final boolean COMPACT_STRINGS;\n\n    static {\n        COMPACT_STRINGS \u003d true;\n    }\n\n    /**\n     * Class String is special cased within the Serialization Stream Protocol.\n     *\n     * A String instance is written into an ObjectOutputStream according to\n     * \u003ca href\u003d\"{@docRoot}/../specs/serialization/protocol.html#stream-elements\"\u003e\n     * Object Serialization Specification, Section 6.2, \"Stream Elements\"\u003c/a\u003e\n     */\n    private static final ObjectStreamField[] serialPersistentFields \u003d\n        new ObjectStreamField[0];\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * an empty character sequence.  Note that use of this constructor is\n     * unnecessary since Strings are immutable.\n     */\n    public String() {\n        this.value \u003d \"\".value;\n        this.coder \u003d \"\".coder;\n    }\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * the same sequence of characters as the argument; in other words, the\n     * newly created string is a copy of the argument string. Unless an\n     * explicit copy of {@code original} is needed, use of this constructor is\n     * unnecessary since Strings are immutable.\n     *\n     * @param  original\n     *         A {@code String}\n     */\n    @HotSpotIntrinsicCandidate\n    public String(String original) {\n        this.value \u003d original.value;\n        this.coder \u003d original.coder;\n        this.hash \u003d original.hash;\n    }\n\n    /**\n     * Allocates a new {@code String} so that it represents the sequence of\n     * characters currently contained in the character array argument. The\n     * contents of the character array are copied; subsequent modification of\n     * the character array does not affect the newly created string.\n     *\n     * @param  value\n     *         The initial value of the string\n     */\n    public String(char value[]) {\n        this(value, 0, value.length, null);\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the character array argument. The {@code offset} argument is the\n     * index of the first character of the subarray and the {@code count}\n     * argument specifies the length of the subarray. The contents of the\n     * subarray are copied; subsequent modification of the character array does\n     * not affect the newly created string.\n     *\n     * @param  value\n     *         Array that is the source of characters\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code value.length - count}\n     */\n    public String(char value[], int offset, int count) {\n        this(value, offset, count, rangeCheck(value, offset, count));\n    }\n\n    private static Void rangeCheck(char[] value, int offset, int count) {\n        checkBoundsOffCount(offset, count, value.length);\n        return null;\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode code point\u003c/a\u003e array\n     * argument.  The {@code offset} argument is the index of the first code\n     * point of the subarray and the {@code count} argument specifies the\n     * length of the subarray.  The contents of the subarray are converted to\n     * {@code char}s; subsequent modification of the {@code int} array does not\n     * affect the newly created string.\n     *\n     * @param  codePoints\n     *         Array that is the source of Unicode code points\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IllegalArgumentException\n     *          If any invalid Unicode code point is found in {@code\n     *          codePoints}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code codePoints.length - count}\n     *\n     * @since  1.5\n     */\n    public String(int[] codePoints, int offset, int count) {\n        checkBoundsOffCount(offset, count, codePoints.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringLatin1.toBytes(codePoints, offset, count);\n            if (val !\u003d null) {\n                this.coder \u003d LATIN1;\n                this.value \u003d val;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(codePoints, offset, count);\n    }\n\n    /**\n     * Allocates a new {@code String} constructed from a subarray of an array\n     * of 8-bit integer values.\n     *\n     * \u003cp\u003e The {@code offset} argument is the index of the first byte of the\n     * subarray, and the {@code count} argument specifies the length of the\n     * subarray.\n     *\n     * \u003cp\u003e Each {@code byte} in the subarray is converted to a {@code char} as\n     * specified in the {@link #String(byte[],int) String(byte[],int)} constructor.\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link\n     * java.nio.charset.Charset}, charset name, or that use the platform\u0027s\n     * default charset.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @param  offset\n     *         The initial offset\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code ascii.length - count}\n     *\n     * @see  #String(byte[], int)\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte ascii[], int hibyte, int offset, int count) {\n        checkBoundsOffCount(offset, count, ascii.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS \u0026\u0026 (byte)hibyte \u003d\u003d 0) {\n            this.value \u003d Arrays.copyOfRange(ascii, offset, offset + count);\n            this.coder \u003d LATIN1;\n        } else {\n            hibyte \u003c\u003c\u003d 8;\n            byte[] val \u003d StringUTF16.newBytesFor(count);\n            for (int i \u003d 0; i \u003c count; i++) {\n                StringUTF16.putChar(val, i, hibyte | (ascii[offset++] \u0026 0xff));\n            }\n            this.value \u003d val;\n            this.coder \u003d UTF16;\n        }\n    }\n\n    /**\n     * Allocates a new {@code String} containing characters constructed from\n     * an array of 8-bit integer values. Each character \u003ci\u003ec\u003c/i\u003e in the\n     * resulting string is constructed from the corresponding component\n     * \u003ci\u003eb\u003c/i\u003e in the byte array such that:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     \u003cb\u003e\u003ci\u003ec\u003c/i\u003e\u003c/b\u003e \u003d\u003d (char)(((hibyte \u0026amp; 0xff) \u0026lt;\u0026lt; 8)\n     *                         | (\u003cb\u003e\u003ci\u003eb\u003c/i\u003e\u003c/b\u003e \u0026amp; 0xff))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert bytes into\n     * characters.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link\n     * java.nio.charset.Charset}, charset name, or that use the platform\u0027s\n     * default charset.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte ascii[], int hibyte) {\n        this(ascii, hibyte, 0, ascii.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified charset.  The length of the new {@code String}\n     * is a function of the charset, and hence may not be equal to the length\n     * of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte bytes[], int offset, int length, String charsetName)\n            throws UnsupportedEncodingException {\n        if (charsetName \u003d\u003d null)\n            throw new NullPointerException(\"charsetName\");\n        checkBoundsOffCount(offset, length, bytes.length);\n        StringCoding.Result ret \u003d\n            StringCoding.decode(charsetName, bytes, offset, length);\n        this.value \u003d ret.value;\n        this.coder \u003d ret.coder;\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.6\n     */\n    public String(byte bytes[], int offset, int length, Charset charset) {\n        if (charset \u003d\u003d null)\n            throw new NullPointerException(\"charset\");\n        checkBoundsOffCount(offset, length, bytes.length);\n        StringCoding.Result ret \u003d\n            StringCoding.decode(charset, bytes, offset, length);\n        this.value \u003d ret.value;\n        this.coder \u003d ret.coder;\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the specified {@linkplain java.nio.charset.Charset charset}.  The\n     * length of the new {@code String} is a function of the charset, and hence\n     * may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public String(byte bytes[], String charsetName)\n            throws UnsupportedEncodingException {\n        this(bytes, 0, bytes.length, charsetName);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @since  1.6\n     */\n    public String(byte bytes[], Charset charset) {\n        this(bytes, 0, bytes.length, charset);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the platform\u0027s default charset.  The length of the new\n     * {@code String} is a function of the charset, and hence may not be equal\n     * to the length of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte bytes[], int offset, int length) {\n        checkBoundsOffCount(offset, length, bytes.length);\n        StringCoding.Result ret \u003d StringCoding.decode(bytes, offset, length);\n        this.value \u003d ret.value;\n        this.coder \u003d ret.coder;\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the platform\u0027s default charset.  The length of the new {@code\n     * String} is a function of the charset, and hence may not be equal to the\n     * length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes) {\n        this(bytes, 0, bytes.length);\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string buffer argument. The contents of the\n     * string buffer are copied; subsequent modification of the string buffer\n     * does not affect the newly created string.\n     *\n     * @param  buffer\n     *         A {@code StringBuffer}\n     */\n    public String(StringBuffer buffer) {\n        this(buffer.toString());\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string builder argument. The contents of the\n     * string builder are copied; subsequent modification of the string builder\n     * does not affect the newly created string.\n     *\n     * \u003cp\u003e This constructor is provided to ease migration to {@code\n     * StringBuilder}. Obtaining a string from a string builder via the {@code\n     * toString} method is likely to run faster and is generally preferred.\n     *\n     * @param   builder\n     *          A {@code StringBuilder}\n     *\n     * @since  1.5\n     */\n    public String(StringBuilder builder) {\n        this(builder, null);\n    }\n\n    /**\n     * Returns the length of this string.\n     * The length is equal to the number of \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n     * code units\u003c/a\u003e in the string.\n     *\n     * @return  the length of the sequence of characters represented by this\n     *          object.\n     */\n    public int length() {\n        return value.length \u003e\u003e coder();\n    }\n\n    /**\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\n     *\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\n     * {@code false}\n     *\n     * @since 1.6\n     */\n    public boolean isEmpty() {\n        return value.length \u003d\u003d 0;\n    }\n\n    /**\n     * Returns the {@code char} value at the\n     * specified index. An index ranges from {@code 0} to\n     * {@code length() - 1}. The first {@code char} value of the sequence\n     * is at index {@code 0}, the next at index {@code 1},\n     * and so on, as for array indexing.\n     *\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\n     * \u003ca href\u003d\"Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\n     * value is returned.\n     *\n     * @param      index   the index of the {@code char} value.\n     * @return     the {@code char} value at the specified index of this string.\n     *             The first {@code char} value is at index {@code 0}.\n     * @exception  IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     */\n    public char charAt(int index) {\n        if (isLatin1()) {\n            return StringLatin1.charAt(value, index);\n        } else {\n            return StringUTF16.charAt(value, index);\n        }\n    }\n\n    /**\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * \u003cp\u003e If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this {@code String}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @exception  IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     * @since      1.5\n     */\n    public int codePointAt(int index) {\n        if (isLatin1()) {\n            checkIndex(index, value.length);\n            return value[index] \u0026 0xff;\n        }\n        int length \u003d value.length \u003e\u003e 1;\n        checkIndex(index, length);\n        return StringUTF16.codePointAt(value, index, length);\n    }\n\n    /**\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * CharSequence#length() length}.\n     *\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @exception IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this string.\n     * @since     1.5\n     */\n    public int codePointBefore(int index) {\n        int i \u003d index - 1;\n        if (i \u003c 0 || i \u003e\u003d length()) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        if (isLatin1()) {\n            return (value[i] \u0026 0xff);\n        }\n        return StringUTF16.codePointBefore(value, index);\n    }\n\n    /**\n     * Returns the number of Unicode code points in the specified text\n     * range of this {@code String}. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @exception IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this {@code String}, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     */\n    public int codePointCount(int beginIndex, int endIndex) {\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex ||\n            endIndex \u003e length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (isLatin1()) {\n            return endIndex - beginIndex;\n        }\n        return StringUTF16.codePointCount(value, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this {@code String} that is\n     * offset from the given {@code index} by\n     * {@code codePointOffset} code points. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this {@code String}\n     * @exception IndexOutOfBoundsException if {@code index}\n     *   is negative or larger then the length of this\n     *   {@code String}, or if {@code codePointOffset} is positive\n     *   and the substring starting with {@code index} has fewer\n     *   than {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the substring\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     */\n    public int offsetByCodePoints(int index, int codePointOffset) {\n        if (index \u003c 0 || index \u003e length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        return Character.offsetByCodePoints(this, index, codePointOffset);\n    }\n\n    /**\n     * Copies characters from this string into the destination character\n     * array.\n     * \u003cp\u003e\n     * The first character to be copied is at index {@code srcBegin};\n     * the last character to be copied is at index {@code srcEnd-1}\n     * (thus the total number of characters to be copied is\n     * {@code srcEnd-srcBegin}). The characters are copied into the\n     * subarray of {@code dst} starting at index {@code dstBegin}\n     * and ending at index:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      srcBegin   index of the first character in the string\n     *                        to copy.\n     * @param      srcEnd     index after the last character in the string\n     *                        to copy.\n     * @param      dst        the destination array.\n     * @param      dstBegin   the start offset in the destination array.\n     * @exception IndexOutOfBoundsException If any of the following\n     *            is true:\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\n     *                string\n     *            \u003cli\u003e{@code dstBegin} is negative\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\n     *                {@code dst.length}\u003c/ul\u003e\n     */\n    public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Copies characters from this string into the destination byte array. Each\n     * byte receives the 8 low-order bits of the corresponding character. The\n     * eight high-order bits of each character are not copied and do not\n     * participate in the transfer in any way.\n     *\n     * \u003cp\u003e The first character to be copied is at index {@code srcBegin}; the\n     * last character to be copied is at index {@code srcEnd-1}.  The total\n     * number of characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters, converted to bytes, are copied into the subarray of {@code\n     * dst} starting at index {@code dstBegin} and ending at index:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert characters into\n     * bytes.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@link #getBytes()} method, which uses the platform\u0027s default charset.\n     *\n     * @param  srcBegin\n     *         Index of the first character in the string to copy\n     *\n     * @param  srcEnd\n     *         Index after the last character in the string to copy\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  dstBegin\n     *         The start offset in the destination array\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If any of the following is true:\n     *          \u003cul\u003e\n     *            \u003cli\u003e {@code srcBegin} is negative\n     *            \u003cli\u003e {@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e {@code srcEnd} is greater than the length of this String\n     *            \u003cli\u003e {@code dstBegin} is negative\n     *            \u003cli\u003e {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n     *                 dst.length}\n     *          \u003c/ul\u003e\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public void getBytes(int srcBegin, int srcEnd, byte dst[], int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        Objects.requireNonNull(dst);\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the named\n     * charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @return  The resultant byte array\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public byte[] getBytes(String charsetName)\n            throws UnsupportedEncodingException {\n        if (charsetName \u003d\u003d null) throw new NullPointerException();\n        return StringCoding.encode(charsetName, coder(), value);\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the given\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\n     * new byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement byte array.  The\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n     * control over the encoding process is required.\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\n     *         the {@code String}\n     *\n     * @return  The resultant byte array\n     *\n     * @since  1.6\n     */\n    public byte[] getBytes(Charset charset) {\n        if (charset \u003d\u003d null) throw new NullPointerException();\n        return StringCoding.encode(charset, coder(), value);\n     }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the\n     * platform\u0027s default charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @return  The resultant byte array\n     *\n     * @since      1.1\n     */\n    public byte[] getBytes() {\n        return StringCoding.encode(coder(), value);\n    }\n\n    /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this \u003d\u003d anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String aString \u003d (String)anObject;\n            if (coder() \u003d\u003d aString.coder()) {\n                return isLatin1() ? StringLatin1.equals(value, aString.value)\n                                  : StringUTF16.equals(value, aString.value);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Compares this string to the specified {@code StringBuffer}.  The result\n     * is {@code true} if and only if this {@code String} represents the same\n     * sequence of characters as the specified {@code StringBuffer}. This method\n     * synchronizes on the {@code StringBuffer}.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  sb\n     *         The {@code StringBuffer} to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of characters as the specified {@code StringBuffer},\n     *          {@code false} otherwise\n     *\n     * @since  1.4\n     */\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n\n    private boolean nonSyncContentEquals(AbstractStringBuilder sb) {\n        int len \u003d length();\n        if (len !\u003d sb.length()) {\n            return false;\n        }\n        byte v1[] \u003d value;\n        byte v2[] \u003d sb.getValue();\n        if (coder() \u003d\u003d sb.getCoder()) {\n            int n \u003d v1.length;\n            for (int i \u003d 0; i \u003c n; i++) {\n                if (v1[i] !\u003d v2[i]) {\n                    return false;\n                }\n            }\n        } else {\n            if (!isLatin1()) {  // utf16 str and latin1 abs can never be \"equal\"\n                return false;\n            }\n            return StringUTF16.contentEquals(v1, v2, len);\n        }\n        return true;\n    }\n\n    /**\n     * Compares this string to the specified {@code CharSequence}.  The\n     * result is {@code true} if and only if this {@code String} represents the\n     * same sequence of char values as the specified sequence. Note that if the\n     * {@code CharSequence} is a {@code StringBuffer} then the method\n     * synchronizes on it.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  cs\n     *         The sequence to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of char values as the specified sequence, {@code\n     *          false} otherwise\n     *\n     * @since  1.5\n     */\n    public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {\n            if (cs instanceof StringBuffer) {\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        // Argument is a String\n        if (cs instanceof String) {\n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        int n \u003d cs.length();\n        if (n !\u003d length()) {\n            return false;\n        }\n        byte[] val \u003d this.value;\n        if (isLatin1()) {\n            for (int i \u003d 0; i \u003c n; i++) {\n                if ((val[i] \u0026 0xff) !\u003d cs.charAt(i)) {\n                    return false;\n                }\n            }\n        } else {\n            if (!StringUTF16.contentEquals(val, cs, n)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares this {@code String} to another {@code String}, ignoring case\n     * considerations.  Two strings are considered equal ignoring case if they\n     * are of the same length and corresponding characters in the two strings\n     * are equal ignoring case.\n     *\n     * \u003cp\u003e Two characters {@code c1} and {@code c2} are considered the same\n     * ignoring case if at least one of the following is true:\n     * \u003cul\u003e\n     *   \u003cli\u003e The two characters are the same (as compared by the\n     *        {@code \u003d\u003d} operator)\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(char))}\n     *        on each character produces the same result\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\n     * will result in unsatisfactory results for certain locales.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param  anotherString\n     *         The {@code String} to compare this {@code String} against\n     *\n     * @return  {@code true} if the argument is not {@code null} and it\n     *          represents an equivalent {@code String} ignoring case; {@code\n     *          false} otherwise\n     *\n     * @see  #equals(Object)\n     */\n    public boolean equalsIgnoreCase(String anotherString) {\n        return (this \u003d\u003d anotherString) ? true\n                : (anotherString !\u003d null)\n                \u0026\u0026 (anotherString.length() \u003d\u003d length())\n                \u0026\u0026 regionMatches(true, 0, anotherString, 0, length());\n    }\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * \u003cp\u003e\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let \u003ci\u003ek\u003c/i\u003e be the smallest such index; then the string\n     * whose character at position \u003ci\u003ek\u003c/i\u003e has the smaller value, as\n     * determined by using the {@code \u003c} operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(k)-anotherString.charAt(k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.length()-anotherString.length()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param   anotherString   the {@code String} to be compared.\n     * @return  the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public int compareTo(String anotherString) {\n        byte v1[] \u003d value;\n        byte v2[] \u003d anotherString.value;\n        if (coder() \u003d\u003d anotherString.coder()) {\n            return isLatin1() ? StringLatin1.compareTo(v1, v2)\n                              : StringUTF16.compareTo(v1, v2);\n        }\n        return isLatin1() ? StringLatin1.compareToUTF16(v1, v2)\n                          : StringUTF16.compareToLatin1(v1, v2);\n     }\n\n    /**\n     * A Comparator that orders {@code String} objects as by\n     * {@code compareToIgnoreCase}. This comparator is serializable.\n     * \u003cp\u003e\n     * Note that this Comparator does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public static final Comparator\u003cString\u003e CASE_INSENSITIVE_ORDER\n                                         \u003d new CaseInsensitiveComparator();\n    private static class CaseInsensitiveComparator\n            implements Comparator\u003cString\u003e, java.io.Serializable {\n        // use serialVersionUID from JDK 1.2.2 for interoperability\n        private static final long serialVersionUID \u003d 8575799808933029326L;\n\n        public int compare(String s1, String s2) {\n            byte v1[] \u003d s1.value;\n            byte v2[] \u003d s2.value;\n            if (s1.coder() \u003d\u003d s2.coder()) {\n                return s1.isLatin1() ? StringLatin1.compareToCI(v1, v2)\n                                     : StringUTF16.compareToCI(v1, v2);\n            }\n            return s1.isLatin1() ? StringLatin1.compareToCI_UTF16(v1, v2)\n                                 : StringUTF16.compareToCI_Latin1(v1, v2);\n        }\n\n        /** Replaces the de-serialized object. */\n        private Object readResolve() { return CASE_INSENSITIVE_ORDER; }\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with normalized versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(character))} on\n     * each character.\n     * \u003cp\u003e\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   str   the {@code String} to be compared.\n     * @return  a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument other. The result is true if these substrings\n     * represent identical character sequences. The substring of this\n     * {@code String} object to be compared begins at index {@code toffset}\n     * and has length {@code len}. The substring of other to be compared\n     * begins at index {@code ooffset} and has length {@code len}. The\n     * result is {@code false} if and only if at least one of the following\n     * is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\n     * such that:\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) !\u003d other.charAt(ooffset + }\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   toffset   the starting offset of the subregion in this string.\n     * @param   other     the string argument.\n     * @param   ooffset   the starting offset of the subregion in the string\n     *                    argument.\n     * @param   len       the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          exactly matches the specified subregion of the string argument;\n     *          {@code false} otherwise.\n     */\n    public boolean regionMatches(int toffset, String other, int ooffset, int len) {\n        byte tv[] \u003d value;\n        byte ov[] \u003d other.value;\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0) ||\n             (toffset \u003e (long)length() - len) ||\n             (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        if (coder() \u003d\u003d other.coder()) {\n            if (!isLatin1() \u0026\u0026 (len \u003e 0)) {\n                toffset \u003d toffset \u003c\u003c 1;\n                ooffset \u003d ooffset \u003c\u003c 1;\n                len \u003d len \u003c\u003c 1;\n            }\n            while (len-- \u003e 0) {\n                if (tv[toffset++] !\u003d ov[ooffset++]) {\n                    return false;\n                }\n            }\n        } else {\n            if (coder() \u003d\u003d LATIN1) {\n                while (len-- \u003e 0) {\n                    if (StringLatin1.getChar(tv, toffset++) !\u003d\n                        StringUTF16.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            } else {\n                while (len-- \u003e 0) {\n                    if (StringUTF16.getChar(tv, toffset++) !\u003d\n                        StringLatin1.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument {@code other}. The result is {@code true} if these\n     * substrings represent character sequences that are the same, ignoring\n     * case if and only if {@code ignoreCase} is true. The substring of\n     * this {@code String} object to be compared begins at index\n     * {@code toffset} and has length {@code len}. The substring of\n     * {@code other} to be compared begins at index {@code ooffset} and\n     * has length {@code len}. The result is {@code false} if and only if\n     * at least one of the following is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003e{@code ignoreCase} is {@code false} and there is some nonnegative\n     * integer \u003ci\u003ek\u003c/i\u003e less than {@code len} such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(toffset+k) !\u003d other.charAt(ooffset+k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cli\u003e{@code ignoreCase} is {@code true} and there is some nonnegative\n     * integer \u003ci\u003ek\u003c/i\u003e less than {@code len} such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Character.toLowerCase(Character.toUpperCase(this.charAt(toffset+k))) !\u003d\n     Character.toLowerCase(Character.toUpperCase(other.charAt(ooffset+k)))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in unsatisfactory results for certain locales when\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\n     * provides locale-sensitive comparison.\n     *\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\n     *                       characters.\n     * @param   toffset      the starting offset of the subregion in this\n     *                       string.\n     * @param   other        the string argument.\n     * @param   ooffset      the starting offset of the subregion in the string\n     *                       argument.\n     * @param   len          the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          matches the specified subregion of the string argument;\n     *          {@code false} otherwise. Whether the matching is exact\n     *          or case insensitive depends on the {@code ignoreCase}\n     *          argument.\n     */\n    public boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n        if (!ignoreCase) {\n            return regionMatches(toffset, other, ooffset, len);\n        }\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0)\n                || (toffset \u003e (long)length() - len)\n                || (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte tv[] \u003d value;\n        byte ov[] \u003d other.value;\n        if (coder() \u003d\u003d other.coder()) {\n            return isLatin1()\n              ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);\n        }\n        return isLatin1()\n              ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);\n    }\n\n    /**\n     * Tests if the substring of this string beginning at the\n     * specified index starts with the specified prefix.\n     *\n     * @param   prefix    the prefix.\n     * @param   toffset   where to begin looking in this string.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the substring of this object starting\n     *          at index {@code toffset}; {@code false} otherwise.\n     *          The result is {@code false} if {@code toffset} is\n     *          negative or greater than the length of this\n     *          {@code String} object; otherwise the result is the same\n     *          as the result of the expression\n     *          \u003cpre\u003e\n     *          this.substring(toffset).startsWith(prefix)\n     *          \u003c/pre\u003e\n     */\n    public boolean startsWith(String prefix, int toffset) {\n        // Note: toffset might be near -1\u003e\u003e\u003e1.\n        if (toffset \u003c 0 || toffset \u003e length() - prefix.length()) {\n            return false;\n        }\n        byte ta[] \u003d value;\n        byte pa[] \u003d prefix.value;\n        int po \u003d 0;\n        int pc \u003d pa.length;\n        if (coder() \u003d\u003d prefix.coder()) {\n            int to \u003d isLatin1() ? toffset : toffset \u003c\u003c 1;\n            while (po \u003c pc) {\n                if (ta[to++] !\u003d pa[po++]) {\n                    return false;\n                }\n            }\n        } else {\n            if (isLatin1()) {  // \u0026\u0026 pcoder \u003d\u003d UTF16\n                return false;\n            }\n            // coder \u003d\u003d UTF16 \u0026\u0026 pcoder \u003d\u003d LATIN1)\n            while (po \u003c pc) {\n                if (StringUTF16.getChar(ta, toffset++) !\u003d (pa[po++] \u0026 0xff)) {\n                    return false;\n               }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     *\n     * @param   prefix   the prefix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the character sequence represented by\n     *          this string; {@code false} otherwise.\n     *          Note also that {@code true} will be returned if the\n     *          argument is an empty string or is equal to this\n     *          {@code String} object as determined by the\n     *          {@link #equals(Object)} method.\n     * @since   1.0\n     */\n    public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     *\n     * @param   suffix   the suffix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a suffix of the character sequence represented by\n     *          this object; {@code false} otherwise. Note that the\n     *          result will be {@code true} if the argument is the\n     *          empty string or is equal to this {@code String} object\n     *          as determined by the {@link #equals(Object)} method.\n     */\n    public boolean endsWith(String suffix) {\n        return startsWith(suffix, length() - suffix.length());\n    }\n\n    /**\n     * Returns a hash code for this string. The hash code for a\n     * {@code String} object is computed as\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * using {@code int} arithmetic, where {@code s[i]} is the\n     * \u003ci\u003ei\u003c/i\u003eth character of the string, {@code n} is the length of\n     * the string, and {@code ^} indicates exponentiation.\n     * (The hash value of the empty string is zero.)\n     *\n     * @return  a hash code value for this object.\n     */\n    public int hashCode() {\n        int h \u003d hash;\n        if (h \u003d\u003d 0 \u0026\u0026 value.length \u003e 0) {\n            hash \u003d h \u003d isLatin1() ? StringLatin1.hashCode(value)\n                                  : StringUTF16.hashCode(value);\n        }\n        return h;\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of\n     * the specified character. If a character with value\n     * {@code ch} occurs in the character sequence represented by\n     * this {@code String} object, then the index (in Unicode\n     * code units) of the first such occurrence is returned. For\n     * values of {@code ch} in the range from 0 to 0xFFFF\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int indexOf(int ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at the specified index.\n     * \u003cp\u003e\n     * If a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code fromIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003e\n     * There is no restriction on the value of {@code fromIndex}. If it\n     * is negative, it has the same effect as if it were zero: this entire\n     * string may be searched. If it is greater than the length of this\n     * string, it has the same effect as if it were equal to the length of\n     * this string: {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur.\n     */\n    public int indexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex)\n                          : StringUTF16.indexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character. For values of {@code ch} in the\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true.  In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.  The\n     * {@code String} is searched backwards starting at the last\n     * character.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int lastIndexOf(int ch) {\n        return lastIndexOf(ch, length() - 1);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character, searching backward starting at the\n     * specified index. For values of {@code ch} in the range\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n     * value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or before position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from. There is no\n     *          restriction on the value of {@code fromIndex}. If it is\n     *          greater than or equal to the length of this string, it has\n     *          the same effect as if it were equal to one less than the\n     *          length of this string: this entire string may be searched.\n     *          If it is negative, it has the same effect as if it were -1:\n     *          -1 is returned.\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object that is less\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur before that point.\n     */\n    public int lastIndexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)\n                          : StringUTF16.lastIndexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str) {\n        if (coder() \u003d\u003d str.coder()) {\n            return isLatin1() ? StringLatin1.indexOf(value, str.value)\n                              : StringUTF16.indexOf(value, str.value);\n        }\n        if (coder() \u003d\u003d LATIN1) {  // str.coder \u003d\u003d UTF16\n            return -1;\n        }\n        return StringUTF16.indexOfLatin1(value, str.value);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003e\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str, int fromIndex) {\n        return indexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src       the characters being searched.\n     * @param   srcCoder  the coder of the source string.\n     * @param   srcCount  length of the source string.\n     * @param   tgtStr    the characters being searched for.\n     * @param   fromIndex the index to begin searching from.\n     */\n    static int indexOf(byte[] src, byte srcCoder, int srcCount,\n                       String tgtStr, int fromIndex) {\n        byte[] tgt    \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount  \u003d tgtStr.length();\n\n        if (fromIndex \u003e\u003d srcCount) {\n            return (tgtCount \u003d\u003d 0 ? srcCount : -1);\n        }\n        if (fromIndex \u003c 0) {\n            fromIndex \u003d 0;\n        }\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (tgtCount \u003e srcCount) {\n            return -1;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.indexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.indexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    //  \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1) {\n        return StringUTF16.indexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\"\n     * is considered to occur at the index value {@code this.length()}.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, length());\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003c\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str, int fromIndex) {\n        return lastIndexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src         the characters being searched.\n     * @param   srcCoder    coder handles the mapping between bytes/chars\n     * @param   srcCount    count of the source string.\n     * @param   tgt         the characters being searched for.\n     * @param   fromIndex   the index to begin searching from.\n     */\n    static int lastIndexOf(byte[] src, byte srcCoder, int srcCount,\n                           String tgtStr, int fromIndex) {\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount \u003d tgtStr.length();\n        /*\n         * Check arguments; return immediately where possible. For\n         * consistency, don\u0027t check for null str.\n         */\n        int rightIndex \u003d srcCount - tgtCount;\n        if (fromIndex \u003e rightIndex) {\n            fromIndex \u003d rightIndex;\n        }\n        if (fromIndex \u003c 0) {\n            return -1;\n        }\n        /* Empty string always matches. */\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    // \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1\n        return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins with the character at the specified index and\n     * extends to the end of this string. \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"unhappy\".substring(2) returns \"happy\"\n     * \"Harbison\".substring(3) returns \"bison\"\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @return     the specified substring.\n     * @exception  IndexOutOfBoundsException  if\n     *             {@code beginIndex} is negative or larger than the\n     *             length of this {@code String} object.\n     */\n    public String substring(int beginIndex) {\n        if (beginIndex \u003c 0) {\n            throw new StringIndexOutOfBoundsException(beginIndex);\n        }\n        int subLen \u003d length() - beginIndex;\n        if (subLen \u003c 0) {\n            throw new StringIndexOutOfBoundsException(subLen);\n        }\n        if (beginIndex \u003d\u003d 0) {\n            return this;\n        }\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @exception  IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        int length \u003d length();\n        checkBoundsBeginEnd(beginIndex, endIndex, length);\n        int subLen \u003d endIndex - beginIndex;\n        if (beginIndex \u003d\u003d 0 \u0026\u0026 endIndex \u003d\u003d length) {\n            return this;\n        }\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a character sequence that is a subsequence of this sequence.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method is defined so that the {@code String} class can implement\n     * the {@link CharSequence} interface.\n     *\n     * @param   beginIndex   the begin index, inclusive.\n     * @param   endIndex     the end index, exclusive.\n     * @return  the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code beginIndex} or {@code endIndex} is negative,\n     *          if {@code endIndex} is greater than {@code length()},\n     *          or if {@code beginIndex} is greater than {@code endIndex}\n     *\n     * @since 1.4\n     * @spec JSR-51\n     */\n    public CharSequence subSequence(int beginIndex, int endIndex) {\n        return this.substring(beginIndex, endIndex);\n    }\n\n    /**\n     * Concatenates the specified string to the end of this string.\n     * \u003cp\u003e\n     * If the length of the argument string is {@code 0}, then this\n     * {@code String} object is returned. Otherwise, a\n     * {@code String} object is returned that represents a character\n     * sequence that is the concatenation of the character sequence\n     * represented by this {@code String} object and the character\n     * sequence represented by the argument string.\u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"cares\".concat(\"s\") returns \"caress\"\n     * \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   str   the {@code String} that is concatenated to the end\n     *                of this {@code String}.\n     * @return  a string that represents the concatenation of this object\u0027s\n     *          characters followed by the string argument\u0027s characters.\n     */\n    public String concat(String str) {\n        if (str.isEmpty()) {\n            return this;\n        }\n        if (coder() \u003d\u003d str.coder()) {\n            byte[] val \u003d this.value;\n            byte[] oval \u003d str.value;\n            int len \u003d val.length + oval.length;\n            byte[] buf \u003d Arrays.copyOf(val, len);\n            System.arraycopy(oval, 0, buf, val.length, oval.length);\n            return new String(buf, coder);\n        }\n        int len \u003d length();\n        int olen \u003d str.length();\n        byte[] buf \u003d StringUTF16.newBytesFor(len + olen);\n        getBytes(buf, 0, UTF16);\n        str.getBytes(buf, len, UTF16);\n        return new String(buf, UTF16);\n    }\n\n    /**\n     * Returns a string resulting from replacing all occurrences of\n     * {@code oldChar} in this string with {@code newChar}.\n     * \u003cp\u003e\n     * If the character {@code oldChar} does not occur in the\n     * character sequence represented by this {@code String} object,\n     * then a reference to this {@code String} object is returned.\n     * Otherwise, a {@code String} object is returned that\n     * represents a character sequence identical to the character sequence\n     * represented by this {@code String} object, except that every\n     * occurrence of {@code oldChar} is replaced by an occurrence\n     * of {@code newChar}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"mesquite in your cellar\".replace(\u0027e\u0027, \u0027o\u0027)\n     *         returns \"mosquito in your collar\"\n     * \"the war of baronets\".replace(\u0027r\u0027, \u0027y\u0027)\n     *         returns \"the way of bayonets\"\n     * \"sparring with a purple porpoise\".replace(\u0027p\u0027, \u0027t\u0027)\n     *         returns \"starring with a turtle tortoise\"\n     * \"JonL\".replace(\u0027q\u0027, \u0027x\u0027) returns \"JonL\" (no change)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   oldChar   the old character.\n     * @param   newChar   the new character.\n     * @return  a string derived from this string by replacing every\n     *          occurrence of {@code oldChar} with {@code newChar}.\n     */\n    public String replace(char oldChar, char newChar) {\n        if (oldChar !\u003d newChar) {\n            String ret \u003d isLatin1() ? StringLatin1.replace(value, oldChar, newChar)\n                                    : StringUTF16.replace(value, oldChar, newChar);\n            if (ret !\u003d null) {\n                return ret;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Tells whether or not this string matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\n     * same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     *\n     * @return  {@code true} if, and only if, this string matches the\n     *          given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     * @spec JSR-51\n     */\n    public boolean matches(String regex) {\n        return Pattern.matches(regex, this);\n    }\n\n    /**\n     * Returns true if and only if this string contains the specified\n     * sequence of char values.\n     *\n     * @param s the sequence to search for\n     * @return true if this string contains {@code s}, false otherwise\n     * @since 1.5\n     */\n    public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) \u003e\u003d 0;\n    }\n\n    /**\n     * Replaces the first substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceFirst replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceFirst}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for the first match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     * @spec JSR-51\n     */\n    public String replaceFirst(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceAll replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for each match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     * @spec JSR-51\n     */\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the literal target\n     * sequence with the specified literal replacement sequence. The\n     * replacement proceeds from the beginning of the string to the end, for\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n     * \"ba\" rather than \"ab\".\n     *\n     * @param  target The sequence of char values to be replaced\n     * @param  replacement The replacement sequence of char values\n     * @return  The resulting string\n     * @since 1.5\n     */\n    public String replace(CharSequence target, CharSequence replacement) {\n        String tgtStr \u003d target.toString();\n        String replStr \u003d replacement.toString();\n        int j \u003d indexOf(tgtStr);\n        if (j \u003c 0) {\n            return this;\n        }\n        int tgtLen \u003d tgtStr.length();\n        int tgtLen1 \u003d Math.max(tgtLen, 1);\n        int thisLen \u003d length();\n\n        int newLenHint \u003d thisLen - tgtLen + replStr.length();\n        if (newLenHint \u003c 0) {\n            throw new OutOfMemoryError();\n        }\n        StringBuilder sb \u003d new StringBuilder(newLenHint);\n        int i \u003d 0;\n        do {\n            sb.append(this, i, j).append(replStr);\n            i \u003d j + tgtLen;\n        } while (j \u003c thisLen \u0026\u0026 (j \u003d indexOf(tgtStr, j + tgtLen1)) \u003e 0);\n        return sb.append(this, i, thisLen).toString();\n    }\n\n    /**\n     * Splits this string around matches of the given\n     * \u003ca href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.  The substrings in\n     * the array are in the order in which they occur in this string.  If the\n     * expression does not match any part of the input then the resulting array\n     * has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\u0027s last entry will contain\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\n     * following results with these parameters:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     * @spec JSR-51\n     */\n    public String[] split(String regex, int limit) {\n        /* fastpath if the regex is a\n         (1)one-char String and this character is not one of the\n            RegEx\u0027s meta characters \".$|()[{^?*+\\\\\", or\n         (2)two-char String and the first char is the backslash and\n            the second is not the ascii digit or ascii letter.\n         */\n        char ch \u003d 0;\n        if (((regex.length() \u003d\u003d 1 \u0026\u0026\n             \".$|()[{^?*+\\\\\".indexOf(ch \u003d regex.charAt(0)) \u003d\u003d -1) ||\n             (regex.length() \u003d\u003d 2 \u0026\u0026\n              regex.charAt(0) \u003d\u003d \u0027\\\\\u0027 \u0026\u0026\n              (((ch \u003d regex.charAt(1))-\u00270\u0027)|(\u00279\u0027-ch)) \u003c 0 \u0026\u0026\n              ((ch-\u0027a\u0027)|(\u0027z\u0027-ch)) \u003c 0 \u0026\u0026\n              ((ch-\u0027A\u0027)|(\u0027Z\u0027-ch)) \u003c 0)) \u0026\u0026\n            (ch \u003c Character.MIN_HIGH_SURROGATE ||\n             ch \u003e Character.MAX_LOW_SURROGATE))\n        {\n            int off \u003d 0;\n            int next \u003d 0;\n            boolean limited \u003d limit \u003e 0;\n            ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n            while ((next \u003d indexOf(ch, off)) !\u003d -1) {\n                if (!limited || list.size() \u003c limit - 1) {\n                    list.add(substring(off, next));\n                    off \u003d next + 1;\n                } else {    // last one\n                    //assert (list.size() \u003d\u003d limit - 1);\n                    int last \u003d length();\n                    list.add(substring(off, last));\n                    off \u003d last;\n                    break;\n                }\n            }\n            // If no match was found, return this\n            if (off \u003d\u003d 0)\n                return new String[]{this};\n\n            // Add remaining segment\n            if (!limited || list.size() \u003c limit)\n                list.add(substring(off, length()));\n\n            // Construct result\n            int resultSize \u003d list.size();\n            if (limit \u003d\u003d 0) {\n                while (resultSize \u003e 0 \u0026\u0026 list.get(resultSize - 1).isEmpty()) {\n                    resultSize--;\n                }\n            }\n            String[] result \u003d new String[resultSize];\n            return list.subList(0, resultSize).toArray(result);\n        }\n        return Pattern.compile(regex).split(this, limit);\n    }\n\n    /**\n     * Splits this string around matches of the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\n     * #split(String, int) split} method with the given expression and a limit\n     * argument of zero.  Trailing empty strings are therefore not included in\n     * the resulting array.\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\n     * results with these expressions:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *  \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     * @spec JSR-51\n     */\n    public String[] split(String regex) {\n        return split(regex, 0);\n    }\n\n    /**\n     * Returns a new String composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of\n     * the specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     String message \u003d String.join(\"-\", \"Java\", \"is\", \"cool\");\n     *     // message returned is: \"Java-is-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an element is null, then {@code \"null\"} is added.\n     *\n     * @param  delimiter the delimiter that separates each element\n     * @param  elements the elements to join together.\n     *\n     * @return a new {@code String} that is composed of the {@code elements}\n     *         separated by the {@code delimiter}\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter, CharSequence... elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        // Number of elements not likely worth Arrays.stream overhead.\n        StringJoiner joiner \u003d new StringJoiner(delimiter);\n        for (CharSequence cs: elements) {\n            joiner.add(cs);\n        }\n        return joiner.toString();\n    }\n\n    /**\n     * Returns a new {@code String} composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of the\n     * specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     List\u003cString\u003e strings \u003d List.of(\"Java\", \"is\", \"cool\");\n     *     String message \u003d String.join(\" \", strings);\n     *     //message returned is: \"Java is cool\"\n     *\n     *     Set\u003cString\u003e strings \u003d\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     *     String message \u003d String.join(\"-\", strings);\n     *     //message returned is: \"Java-is-very-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\n     *\n     * @param  delimiter a sequence of characters that is used to separate each\n     *         of the {@code elements} in the resulting {@code String}\n     * @param  elements an {@code Iterable} that will have its {@code elements}\n     *         joined together.\n     *\n     * @return a new {@code String} that is composed from the {@code elements}\n     *         argument\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see    #join(CharSequence,CharSequence...)\n     * @see    java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter,\n            Iterable\u003c? extends CharSequence\u003e elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        StringJoiner joiner \u003d new StringJoiner(delimiter);\n        for (CharSequence cs: elements) {\n            joiner.add(cs);\n        }\n        return joiner.toString();\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the given {@code Locale}.  Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting\n     * {@code String} may be a different length than the original {@code String}.\n     * \u003cp\u003e\n     * Examples of lowercase  mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toUpperCase(Locale)\n     * @since   1.1\n     */\n    public String toLowerCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toLowerCase(this, value, locale)\n                          : StringUTF16.toLowerCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the default locale. This is equivalent to calling\n     * {@code toLowerCase(Locale.getDefault())}.\n     * \u003cp\u003e\n     * \u003cb\u003eNote:\u003c/b\u003e This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\n     * returns {@code \"t\\u005Cu0131tle\"}, where \u0027\\u005Cu0131\u0027 is the\n     * LATIN SMALL LETTER DOTLESS I character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toLowerCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase(Locale)\n     */\n    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the given {@code Locale}. Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting\n     * {@code String} may be a different length than the original {@code String}.\n     * \u003cp\u003e\n     * Examples of locale-sensitive and 1:M case mappings are in the following table.\n     *\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\n     *   \u003ctd\u003e\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toLowerCase(Locale)\n     * @since   1.1\n     */\n    public String toUpperCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toUpperCase(this, value, locale)\n                          : StringUTF16.toUpperCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toUpperCase(Locale.getDefault())}.\n     * \u003cp\u003e\n     * \u003cb\u003eNote:\u003c/b\u003e This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\n     * returns {@code \"T\\u005Cu0130TLE\"}, where \u0027\\u005Cu0130\u0027 is the\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toUpperCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase(Locale)\n     */\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing space removed, where space is defined\n     * as any character whose codepoint is less than or equal to\n     * {@code \u0027U+0020\u0027} (the space character).\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty character\n     * sequence, or the first and last characters of character sequence\n     * represented by this {@code String} object both have codes\n     * that are not space (as defined above), then a\n     * reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * Otherwise, if all characters in this string are space (as\n     * defined above), then a  {@code String} object representing an\n     * empty string is returned.\n     * \u003cp\u003e\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\n     * string whose code is not a space (as defined above) and let\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\n     * is not a space (as defined above). A {@code String}\n     * object is returned, representing the substring of this string that\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\n     * {@code this.substring(k, m + 1)}.\n     * \u003cp\u003e\n     * This method may be used to trim space (as defined above) from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing space removed, or this string if it\n     *          has no leading or trailing space.\n     */\n    public String trim() {\n        String ret \u003d isLatin1() ? StringLatin1.trim(value)\n                                : StringUTF16.trim(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing {@link Character#isWhitespace(int) white space}\n     * removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@link Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@link Character#isWhitespace(int) white space}\n     * up to and including the last code point that is not a\n     * {@link Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to strip\n     * {@link Character#isWhitespace(int) white space} from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing white space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String strip() {\n        String ret \u003d isLatin1() ? StringLatin1.strip(value)\n                                : StringUTF16.strip(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * {@link Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@link Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@link Character#isWhitespace(int) white space}\n     * up to to and including the last code point of this string.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@link Character#isWhitespace(int) white space} from\n     * the beginning of a string.\n     *\n     * @return  a string whose value is this string, with all leading white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripLeading() {\n        String ret \u003d isLatin1() ? StringLatin1.stripLeading(value)\n                                : StringUTF16.stripLeading(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all trailing\n     * {@link Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all characters in this string are\n     * {@link Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point of this string up to and including the last code point\n     * that is not a {@link Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@link Character#isWhitespace(int) white space} from\n     * the end of a string.\n     *\n     * @return  a string whose value is this string, with all trailing white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripTrailing() {\n        String ret \u003d isLatin1() ? StringLatin1.stripTrailing(value)\n                                : StringUTF16.stripTrailing(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns {@code true} if the string is empty or contains only\n     * {@link Character#isWhitespace(int) white space} codepoints,\n     * otherwise {@code false}.\n     *\n     * @return {@code true} if the string is empty or contains only\n     *         {@link Character#isWhitespace(int) white space} codepoints,\n     *         otherwise {@code false}\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public boolean isBlank() {\n        return indexOfNonWhitespace() \u003d\u003d length();\n    }\n\n    private int indexOfNonWhitespace() {\n        if (isLatin1()) {\n            return StringLatin1.indexOfNonWhitespace(value);\n        } else {\n            return StringUTF16.indexOfNonWhitespace(value);\n        }\n    }\n\n    /**\n     * Returns a stream of lines extracted from this string,\n     * separated by line terminators.\n     * \u003cp\u003e\n     * A \u003ci\u003eline terminator\u003c/i\u003e is one of the following:\n     * a line feed character {@code \"\\n\"} (U+000A),\n     * a carriage return character {@code \"\\r\"} (U+000D),\n     * or a carriage return followed immediately by a line feed\n     * {@code \"\\r\\n\"} (U+000D U+000A).\n     * \u003cp\u003e\n     * A \u003ci\u003eline\u003c/i\u003e is either a sequence of zero or more characters\n     * followed by a line terminator, or it is a sequence of one or\n     * more characters followed by the end of the string. A\n     * line does not include the line terminator.\n     * \u003cp\u003e\n     * The stream returned by this method contains the lines from\n     * this string in the order in which they occur.\n     *\n     * @apiNote This definition of \u003ci\u003eline\u003c/i\u003e implies that an empty\n     *          string has zero lines and that there is no empty line\n     *          following a line terminator at the end of a string.\n     *\n     * @implNote This method provides better performance than\n     *           split(\"\\R\") by supplying elements lazily and\n     *           by faster search of new line terminators.\n     *\n     * @return  the stream of lines extracted from this string\n     *\n     * @since 11\n     */\n    public Stream\u003cString\u003e lines() {\n        return isLatin1() ? StringLatin1.lines(value)\n                          : StringUTF16.lines(value);\n    }\n\n    /**\n     * This object (which is already a string!) is itself returned.\n     *\n     * @return  the string itself.\n     */\n    public String toString() {\n        return this;\n    }\n\n    /**\n     * Returns a stream of {@code int} zero-extending the {@code char} values\n     * from this sequence.  Any char which maps to a \u003ca\n     * href\u003d\"{@docRoot}/java.base/java/lang/Character.html#unicode\"\u003esurrogate code\n     * point\u003c/a\u003e is passed through uninterpreted.\n     *\n     * @return an IntStream of char values from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream chars() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CharsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n\n    /**\n     * Returns a stream of code point values from this sequence.  Any surrogate\n     * pairs encountered in the sequence are combined as if by {@linkplain\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\n     * to the stream. Any other code units, including ordinary BMP characters,\n     * unpaired surrogates, and undefined code units, are zero-extended to\n     * {@code int} values which are then passed to the stream.\n     *\n     * @return an IntStream of Unicode code points from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream codePoints() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CodePointsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n    /**\n     * Converts this string to a new character array.\n     *\n     * @return  a newly allocated character array whose length is the length\n     *          of this string and whose contents are initialized to contain\n     *          the character sequence represented by this string.\n     */\n    public char[] toCharArray() {\n        return isLatin1() ? StringLatin1.toChars(value)\n                          : StringUTF16.toChars(value);\n    }\n\n    /**\n     * Returns a formatted string using the specified format string and\n     * arguments.\n     *\n     * \u003cp\u003e The locale always used is the one returned by {@link\n     * java.util.Locale#getDefault(java.util.Locale.Category)\n     * Locale.getDefault(Locale.Category)} with\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the \u003ca\n     *         href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n\n    /**\n     * Returns a formatted string using the specified locale, format string,\n     * and arguments.\n     *\n     * @param  l\n     *         The {@linkplain java.util.Locale locale} to apply during\n     *         formatting.  If {@code l} is {@code null} then no localization\n     *         is applied.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the\n     *         \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(Locale l, String format, Object... args) {\n        return new Formatter(l).format(format, args).toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code Object} argument.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  if the argument is {@code null}, then a string equal to\n     *          {@code \"null\"}; otherwise, the value of\n     *          {@code obj.toString()} is returned.\n     * @see     java.lang.Object#toString()\n     */\n    public static String valueOf(Object obj) {\n        return (obj \u003d\u003d null) ? \"null\" : obj.toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code char} array\n     * argument. The contents of the character array are copied; subsequent\n     * modification of the character array does not affect the returned\n     * string.\n     *\n     * @param   data     the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String valueOf(char data[]) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of a specific subarray of the\n     * {@code char} array argument.\n     * \u003cp\u003e\n     * The {@code offset} argument is the index of the first\n     * character of the subarray. The {@code count} argument\n     * specifies the length of the subarray. The contents of the subarray\n     * are copied; subsequent modification of the character array does not\n     * affect the returned string.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @exception IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String valueOf(char data[], int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[], int, int)}.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @exception IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String copyValueOf(char data[], int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[])}.\n     *\n     * @param   data   the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String copyValueOf(char data[]) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of the {@code boolean} argument.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  if the argument is {@code true}, a string equal to\n     *          {@code \"true\"} is returned; otherwise, a string equal to\n     *          {@code \"false\"} is returned.\n     */\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n\n    /**\n     * Returns the string representation of the {@code char}\n     * argument.\n     *\n     * @param   c   a {@code char}.\n     * @return  a string of length {@code 1} containing\n     *          as its single character the argument {@code c}.\n     */\n    public static String valueOf(char c) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(c)) {\n            return new String(StringLatin1.toBytes(c), LATIN1);\n        }\n        return new String(StringUTF16.toBytes(c), UTF16);\n    }\n\n    /**\n     * Returns the string representation of the {@code int} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Integer.toString} method of one argument.\n     *\n     * @param   i   an {@code int}.\n     * @return  a string representation of the {@code int} argument.\n     * @see     java.lang.Integer#toString(int, int)\n     */\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n\n    /**\n     * Returns the string representation of the {@code long} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Long.toString} method of one argument.\n     *\n     * @param   l   a {@code long}.\n     * @return  a string representation of the {@code long} argument.\n     * @see     java.lang.Long#toString(long)\n     */\n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n\n    /**\n     * Returns the string representation of the {@code float} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Float.toString} method of one argument.\n     *\n     * @param   f   a {@code float}.\n     * @return  a string representation of the {@code float} argument.\n     * @see     java.lang.Float#toString(float)\n     */\n    public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n\n    /**\n     * Returns the string representation of the {@code double} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Double.toString} method of one argument.\n     *\n     * @param   d   a {@code double}.\n     * @return  a  string representation of the {@code double} argument.\n     * @see     java.lang.Double#toString(double)\n     */\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n\n    /**\n     * Returns a canonical representation for the string object.\n     * \u003cp\u003e\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * \u003cp\u003e\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() \u003d\u003d t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * \u003cp\u003e\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section 3.10.5 of the\n     * \u003ccite\u003eThe Java\u0026trade; Language Specification\u003c/cite\u003e.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     * @jls 3.10.5 String Literals\n     */\n    public native String intern();\n\n    /**\n     * Returns a string whose value is the concatenation of this\n     * string repeated {@code count} times.\n     * \u003cp\u003e\n     * If this string is empty or count is zero then the empty\n     * string is returned.\n     *\n     * @param   count number of times to repeat\n     *\n     * @return  A string composed of this string repeated\n     *          {@code count} times or the empty string if this\n     *          string is empty or count is zero\n     *\n     * @throws  IllegalArgumentException if the {@code count} is\n     *          negative.\n     *\n     * @since 11\n     */\n    public String repeat(int count) {\n        if (count \u003c 0) {\n            throw new IllegalArgumentException(\"count is negative: \" + count);\n        }\n        if (count \u003d\u003d 1) {\n            return this;\n        }\n        final int len \u003d value.length;\n        if (len \u003d\u003d 0 || count \u003d\u003d 0) {\n            return \"\";\n        }\n        if (len \u003d\u003d 1) {\n            final byte[] single \u003d new byte[count];\n            Arrays.fill(single, value[0]);\n            return new String(single, coder);\n        }\n        if (Integer.MAX_VALUE / count \u003c len) {\n            throw new OutOfMemoryError(\"Repeating \" + len + \" bytes String \" + count +\n                    \" times will produce a String exceeding maximum size.\");\n        }\n        final int limit \u003d len * count;\n        final byte[] multiple \u003d new byte[limit];\n        System.arraycopy(value, 0, multiple, 0, len);\n        int copied \u003d len;\n        for (; copied \u003c limit - copied; copied \u003c\u003c\u003d 1) {\n            System.arraycopy(multiple, 0, multiple, copied, copied);\n        }\n        System.arraycopy(multiple, 0, multiple, copied, limit - copied);\n        return new String(multiple, coder);\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     */\n    void getBytes(byte dst[], int dstBegin, byte coder) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, 0, dst, dstBegin \u003c\u003c coder, value.length);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, 0, dst, dstBegin, value.length);\n        }\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     *\n     * Stores the char[] value into a byte[] that each byte represents\n     * the8 low-order bits of the corresponding character, if the char[]\n     * contains only latin1 character. Or a byte[] that stores all\n     * characters in their byte sequences defined by the {@code StringUTF16}.\n     */\n    String(char[] value, int off, int len, Void sig) {\n        if (len \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringUTF16.compress(value, off, len);\n            if (val !\u003d null) {\n                this.value \u003d val;\n                this.coder \u003d LATIN1;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(value, off, len);\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     */\n    String(AbstractStringBuilder asb, Void sig) {\n        byte[] val \u003d asb.getValue();\n        int length \u003d asb.length();\n        if (asb.isLatin1()) {\n            this.coder \u003d LATIN1;\n            this.value \u003d Arrays.copyOfRange(val, 0, length);\n        } else {\n            if (COMPACT_STRINGS) {\n                byte[] buf \u003d StringUTF16.compress(val, 0, length);\n                if (buf !\u003d null) {\n                    this.coder \u003d LATIN1;\n                    this.value \u003d buf;\n                    return;\n                }\n            }\n            this.coder \u003d UTF16;\n            this.value \u003d Arrays.copyOfRange(val, 0, length \u003c\u003c 1);\n        }\n    }\n\n   /*\n    * Package private constructor which shares value array for speed.\n    */\n    String(byte[] value, byte coder) {\n        this.value \u003d value;\n        this.coder \u003d coder;\n    }\n\n    byte coder() {\n        return COMPACT_STRINGS ? coder : UTF16;\n    }\n\n    byte[] value() {\n        return value;\n    }\n\n    private boolean isLatin1() {\n        return COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1;\n    }\n\n    @Native static final byte LATIN1 \u003d 0;\n    @Native static final byte UTF16  \u003d 1;\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code index} is\n     * negative or greater than or equal to {@code length}.\n     */\n    static void checkIndex(int index, int length) {\n        if (index \u003c 0 || index \u003e\u003d length) {\n            throw new StringIndexOutOfBoundsException(\"index \" + index +\n                                                      \",length \" + length);\n        }\n    }\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code offset}\n     * is negative or greater than {@code length}.\n     */\n    static void checkOffset(int offset, int length) {\n        if (offset \u003c 0 || offset \u003e length) {\n            throw new StringIndexOutOfBoundsException(\"offset \" + offset +\n                                                      \",length \" + length);\n        }\n    }\n\n    /*\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative,\n     *          or {@code offset} is greater than {@code length - count}\n     */\n    static void checkBoundsOffCount(int offset, int count, int length) {\n        if (offset \u003c 0 || count \u003c 0 || offset \u003e length - count) {\n            throw new StringIndexOutOfBoundsException(\n                \"offset \" + offset + \", count \" + count + \", length \" + length);\n        }\n    }\n\n    /*\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code begin} is negative, {@code begin} is greater than\n     *          {@code end}, or {@code end} is greater than {@code length}.\n     */\n    static void checkBoundsBeginEnd(int begin, int end, int length) {\n        if (begin \u003c 0 || begin \u003e end || end \u003e length) {\n            throw new StringIndexOutOfBoundsException(\n                \"begin \" + begin + \", end \" + end + \", length \" + length);\n        }\n    }\n\n    /**\n     * Returns the string representation of the {@code codePoint}\n     * argument.\n     *\n     * @param   codePoint a {@code codePoint}.\n     * @return  a string of length {@code 1} or {@code 2} containing\n     *          as its single character the argument {@code codePoint}.\n     * @throws IllegalArgumentException if the specified\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\n     *          valid Unicode code point}.\n     */\n    static String valueOfCodePoint(int codePoint) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(codePoint)) {\n            return new String(StringLatin1.toBytes((char)codePoint), LATIN1);\n        } else if (Character.isBmpCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytes((char)codePoint), UTF16);\n        } else if (Character.isSupplementaryCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytesSupplementary(codePoint), UTF16);\n        }\n\n        throw new IllegalArgumentException(\n            format(\"Not a valid Unicode code point: 0x%X\", codePoint));\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 18, 2024 3:05:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/String.java"
  ]
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.18 15:05:04 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:545)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	jdk.internal.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:05:04 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:443)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	jdk.internal.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:05:04 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

2024.10.18 15:05:04 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.codeLens(WorkspaceLspService.scala:530)
	scala.meta.metals.lsp.DelegatingScalaService.codeLens(DelegatingScalaService.scala:150)
	jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$3(MetalsLspService.scala:1225)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$2(MetalsLspService.scala:1224)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:05:04 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.documentSymbol(WorkspaceLspService.scala:460)
	scala.meta.metals.lsp.DelegatingScalaService.documentSymbol(DelegatingScalaService.scala:91)
	jdk.internal.reflect.GeneratedMethodAccessor5.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$documentSymbol$1(MetalsLspService.scala:1055)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:05:04 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:04 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

2024.10.18 15:05:05 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/String.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:443)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	jdk.internal.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/String.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.18 15:05:07 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.LocalTime.SECONDS_PER_DAY;\nimport static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH;\nimport static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR;\nimport static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_MONTH;\nimport static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_YEAR;\nimport static java.time.temporal.ChronoField.DAY_OF_MONTH;\nimport static java.time.temporal.ChronoField.DAY_OF_YEAR;\nimport static java.time.temporal.ChronoField.EPOCH_DAY;\nimport static java.time.temporal.ChronoField.ERA;\nimport static java.time.temporal.ChronoField.MONTH_OF_YEAR;\nimport static java.time.temporal.ChronoField.PROLEPTIC_MONTH;\nimport static java.time.temporal.ChronoField.YEAR;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.ChronoLocalDate;\nimport java.time.chrono.IsoEra;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneOffsetTransition;\nimport java.time.zone.ZoneRules;\nimport java.util.Objects;\nimport java.util.stream.LongStream;\nimport java.util.stream.Stream;\n\n/**\n * A date without a time-zone in the ISO-8601 calendar system,\n * such as {@code 2007-12-03}.\n * \u003cp\u003e\n * {@code LocalDate} is an immutable date-time object that represents a date,\n * often viewed as year-month-day. Other date fields, such as day-of-year,\n * day-of-week and week-of-year, can also be accessed.\n * For example, the value \"2nd October 2007\" can be stored in a {@code LocalDate}.\n * \u003cp\u003e\n * This class does not store or represent a time or time-zone.\n * Instead, it is a description of the date, as used for birthdays.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n * \u003cp\u003e\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today\u0027s rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code LocalDate} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class LocalDate\n        implements Temporal, TemporalAdjuster, ChronoLocalDate, Serializable {\n\n    /**\n     * The minimum supported {@code LocalDate}, \u0027-999999999-01-01\u0027.\n     * This could be used by an application as a \"far past\" date.\n     */\n    public static final LocalDate MIN \u003d LocalDate.of(Year.MIN_VALUE, 1, 1);\n    /**\n     * The maximum supported {@code LocalDate}, \u0027+999999999-12-31\u0027.\n     * This could be used by an application as a \"far future\" date.\n     */\n    public static final LocalDate MAX \u003d LocalDate.of(Year.MAX_VALUE, 12, 31);\n    /**\n     * The epoch year {@code LocalDate}, \u00271970-01-01\u0027.\n     */\n    public static final LocalDate EPOCH \u003d LocalDate.of(1970, 1, 1);\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 2942565459149668126L;\n    /**\n     * The number of days in a 400 year cycle.\n     */\n    private static final int DAYS_PER_CYCLE \u003d 146097;\n    /**\n     * The number of days from year zero to year 1970.\n     * There are five 400 year cycles from year zero to 2000.\n     * There are 7 leap years from 1970 to 2000.\n     */\n    static final long DAYS_0000_TO_1970 \u003d (DAYS_PER_CYCLE * 5L) - (30L * 365L + 7L);\n\n    /**\n     * The year.\n     */\n    private final int year;\n    /**\n     * The month-of-year.\n     */\n    private final short month;\n    /**\n     * The day-of-month.\n     */\n    private final short day;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date using the system clock and default time-zone, not null\n     */\n    public static LocalDate now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date using the system clock, not null\n     */\n    public static LocalDate now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date - today.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date, not null\n     */\n    public static LocalDate now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        return ofInstant(now, clock.getZone());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a year, month and day.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDate of(int year, Month month, int dayOfMonth) {\n        YEAR.checkValidValue(year);\n        Objects.requireNonNull(month, \"month\");\n        DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        return create(year, month.getValue(), dayOfMonth);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDate} from a year, month and day.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDate of(int year, int month, int dayOfMonth) {\n        YEAR.checkValidValue(year);\n        MONTH_OF_YEAR.checkValidValue(month);\n        DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        return create(year, month, dayOfMonth);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a year and day-of-year.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year and day-of-year.\n     * The day-of-year must be valid for the year, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param dayOfYear  the day-of-year to represent, from 1 to 366\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-year is invalid for the year\n     */\n    public static LocalDate ofYearDay(int year, int dayOfYear) {\n        YEAR.checkValidValue(year);\n        DAY_OF_YEAR.checkValidValue(dayOfYear);\n        boolean leap \u003d IsoChronology.INSTANCE.isLeapYear(year);\n        if (dayOfYear \u003d\u003d 366 \u0026\u0026 leap \u003d\u003d false) {\n            throw new DateTimeException(\"Invalid date \u0027DayOfYear 366\u0027 as \u0027\" + year + \"\u0027 is not a leap year\");\n        }\n        Month moy \u003d Month.of((dayOfYear - 1) / 31 + 1);\n        int monthEnd \u003d moy.firstDayOfYear(leap) + moy.length(leap) - 1;\n        if (dayOfYear \u003e monthEnd) {\n            moy \u003d moy.plus(1);\n        }\n        int dom \u003d dayOfYear - moy.firstDayOfYear(leap) + 1;\n        return new LocalDate(year, moy.getValue(), dom);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates a local date based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date.\n     *\n     * @param instant  the instant to create the date from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the local date, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     * @since 9\n     */\n    public static LocalDate ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        long localSecond \u003d instant.getEpochSecond() + offset.getTotalSeconds();\n        long localEpochDay \u003d Math.floorDiv(localSecond, SECONDS_PER_DAY);\n        return ofEpochDay(localEpochDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from the epoch day count.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified epoch-day.\n     * The {@link ChronoField#EPOCH_DAY EPOCH_DAY} is a simple incrementing count\n     * of days where day 0 is 1970-01-01. Negative numbers represent earlier days.\n     *\n     * @param epochDay  the Epoch Day to convert, based on the epoch 1970-01-01\n     * @return the local date, not null\n     * @throws DateTimeException if the epoch day exceeds the supported date range\n     */\n    public static LocalDate ofEpochDay(long epochDay) {\n        EPOCH_DAY.checkValidValue(epochDay);\n        long zeroDay \u003d epochDay + DAYS_0000_TO_1970;\n        // find the march-based year\n        zeroDay -\u003d 60;  // adjust to 0000-03-01 so leap day is at end of four year cycle\n        long adjust \u003d 0;\n        if (zeroDay \u003c 0) {\n            // adjust negative years to positive for calculation\n            long adjustCycles \u003d (zeroDay + 1) / DAYS_PER_CYCLE - 1;\n            adjust \u003d adjustCycles * 400;\n            zeroDay +\u003d -adjustCycles * DAYS_PER_CYCLE;\n        }\n        long yearEst \u003d (400 * zeroDay + 591) / DAYS_PER_CYCLE;\n        long doyEst \u003d zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);\n        if (doyEst \u003c 0) {\n            // fix estimate\n            yearEst--;\n            doyEst \u003d zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);\n        }\n        yearEst +\u003d adjust;  // reset any negative year\n        int marchDoy0 \u003d (int) doyEst;\n\n        // convert march-based values back to january-based\n        int marchMonth0 \u003d (marchDoy0 * 5 + 2) / 153;\n        int month \u003d (marchMonth0 + 2) % 12 + 1;\n        int dom \u003d marchDoy0 - (marchMonth0 * 306 + 5) / 10 + 1;\n        yearEst +\u003d marchMonth0 / 10;\n\n        // check year now we are certain it is correct\n        int year \u003d YEAR.checkValidIntValue(yearEst);\n        return new LocalDate(year, month, dom);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a temporal object.\n     * \u003cp\u003e\n     * This obtains a local date based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code LocalDate}.\n     * \u003cp\u003e\n     * The conversion uses the {@link TemporalQueries#localDate()} query, which relies\n     * on extracting the {@link ChronoField#EPOCH_DAY EPOCH_DAY} field.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code LocalDate::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the local date, not null\n     * @throws DateTimeException if unable to convert to a {@code LocalDate}\n     */\n    public static LocalDate from(TemporalAccessor temporal) {\n        Objects.requireNonNull(temporal, \"temporal\");\n        LocalDate date \u003d temporal.query(TemporalQueries.localDate());\n        if (date \u003d\u003d null) {\n            throw new DateTimeException(\"Unable to obtain LocalDate from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName());\n        }\n        return date;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a text string such as {@code 2007-12-03}.\n     * \u003cp\u003e\n     * The string must represent a valid date and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_DATE}.\n     *\n     * @param text  the text to parse such as \"2007-12-03\", not null\n     * @return the parsed local date, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDate parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_LOCAL_DATE);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDate} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed local date, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDate parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, LocalDate::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a local date from the year, month and day fields.\n     *\n     * @param year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 to 12, validated\n     * @param dayOfMonth  the day-of-month to represent, validated from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the day-of-month is invalid for the month-year\n     */\n    private static LocalDate create(int year, int month, int dayOfMonth) {\n        if (dayOfMonth \u003e 28) {\n            int dom \u003d 31;\n            switch (month) {\n                case 2:\n                    dom \u003d (IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n                    break;\n                case 4:\n                case 6:\n                case 9:\n                case 11:\n                    dom \u003d 30;\n                    break;\n            }\n            if (dayOfMonth \u003e dom) {\n                if (dayOfMonth \u003d\u003d 29) {\n                    throw new DateTimeException(\"Invalid date \u0027February 29\u0027 as \u0027\" + year + \"\u0027 is not a leap year\");\n                } else {\n                    throw new DateTimeException(\"Invalid date \u0027\" + Month.of(month).name() + \" \" + dayOfMonth + \"\u0027\");\n                }\n            }\n        }\n        return new LocalDate(year, month, dayOfMonth);\n    }\n\n    /**\n     * Resolves the date, resolving days past the end of month.\n     *\n     * @param year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, validated from 1 to 12\n     * @param day  the day-of-month to represent, validated from 1 to 31\n     * @return the resolved date, not null\n     */\n    private static LocalDate resolvePreviousValid(int year, int month, int day) {\n        switch (month) {\n            case 2:\n                day \u003d Math.min(day, IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n                break;\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                day \u003d Math.min(day, 30);\n                break;\n        }\n        return new LocalDate(year, month, day);\n    }\n\n    /**\n     * Constructor, previously validated.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, valid for year-month, from 1 to 31\n     */\n    private LocalDate(int year, int month, int dayOfMonth) {\n        this.year \u003d year;\n        this.month \u003d (short) month;\n        this.day \u003d (short) dayOfMonth;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalField field) {\n        return ChronoLocalDate.super.isSupported(field);\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        return ChronoLocalDate.super.isSupported(unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            if (f.isDateBased()) {\n                switch (f) {\n                    case DAY_OF_MONTH: return ValueRange.of(1, lengthOfMonth());\n                    case DAY_OF_YEAR: return ValueRange.of(1, lengthOfYear());\n                    case ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, getMonth() \u003d\u003d Month.FEBRUARY \u0026\u0026 isLeapYear() \u003d\u003d false ? 4 : 5);\n                    case YEAR_OF_ERA:\n                        return (getYear() \u003c\u003d 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n                }\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date, except {@code EPOCH_DAY} and {@code PROLEPTIC_MONTH}\n     * which are too large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc and performance\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            return get0(field);\n        }\n        return ChronoLocalDate.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            if (field \u003d\u003d EPOCH_DAY) {\n                return toEpochDay();\n            }\n            if (field \u003d\u003d PROLEPTIC_MONTH) {\n                return getProlepticMonth();\n            }\n            return get0(field);\n        }\n        return field.getFrom(this);\n    }\n\n    private int get0(TemporalField field) {\n        switch ((ChronoField) field) {\n            case DAY_OF_WEEK: return getDayOfWeek().getValue();\n            case ALIGNED_DAY_OF_WEEK_IN_MONTH: return ((day - 1) % 7) + 1;\n            case ALIGNED_DAY_OF_WEEK_IN_YEAR: return ((getDayOfYear() - 1) % 7) + 1;\n            case DAY_OF_MONTH: return day;\n            case DAY_OF_YEAR: return getDayOfYear();\n            case EPOCH_DAY: throw new UnsupportedTemporalTypeException(\"Invalid field \u0027EpochDay\u0027 for get() method, use getLong() instead\");\n            case ALIGNED_WEEK_OF_MONTH: return ((day - 1) / 7) + 1;\n            case ALIGNED_WEEK_OF_YEAR: return ((getDayOfYear() - 1) / 7) + 1;\n            case MONTH_OF_YEAR: return month;\n            case PROLEPTIC_MONTH: throw new UnsupportedTemporalTypeException(\"Invalid field \u0027ProlepticMonth\u0027 for get() method, use getLong() instead\");\n            case YEAR_OF_ERA: return (year \u003e\u003d 1 ? year : 1 - year);\n            case YEAR: return year;\n            case ERA: return (year \u003e\u003d 1 ? 1 : 0);\n        }\n        throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n    }\n\n    private long getProlepticMonth() {\n        return (year * 12L + month - 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology of this date, which is the ISO calendar system.\n     * \u003cp\u003e\n     * The {@code Chronology} represents the calendar system in use.\n     * The ISO-8601 calendar system is the modern civil calendar system used today\n     * in most of the world. It is equivalent to the proleptic Gregorian calendar\n     * system, in which today\u0027s rules for leap years are applied for all time.\n     *\n     * @return the ISO chronology, not null\n     */\n    @Override\n    public IsoChronology getChronology() {\n        return IsoChronology.INSTANCE;\n    }\n\n    /**\n     * Gets the era applicable at this date.\n     * \u003cp\u003e\n     * The official ISO-8601 standard does not define eras, however {@code IsoChronology} does.\n     * It defines two eras, \u0027CE\u0027 from year one onwards and \u0027BCE\u0027 from year zero backwards.\n     * Since dates before the Julian-Gregorian cutover are not in line with history,\n     * the cutover between \u0027BCE\u0027 and \u0027CE\u0027 is also not aligned with the commonly used\n     * eras, often referred to using \u0027BC\u0027 and \u0027AD\u0027.\n     * \u003cp\u003e\n     * Users of this class should typically ignore this method as it exists primarily\n     * to fulfill the {@link ChronoLocalDate} contract where it is necessary to support\n     * the Japanese calendar system.\n     *\n     * @return the IsoEra applicable at this date, not null\n     */\n    @Override // override for Javadoc\n    public IsoEra getEra() {\n        return (getYear() \u003e\u003d 1 ? IsoEra.CE : IsoEra.BCE);\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return year;\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return month;\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return Month.of(month);\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return day;\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return getMonth().firstDayOfYear(isLeapYear()) + day - 1;\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        int dow0 \u003d Math.floorMod(toEpochDay() + 3, 7);\n        return DayOfWeek.of(dow0 + 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     * \u003cp\u003e\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     * \u003cp\u003e\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     * \u003cp\u003e\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return true if the year is leap, false otherwise\n     */\n    @Override // override for Javadoc and performance\n    public boolean isLeapYear() {\n        return IsoChronology.INSTANCE.isLeapYear(year);\n    }\n\n    /**\n     * Returns the length of the month represented by this date.\n     * \u003cp\u003e\n     * This returns the length of the month in days.\n     * For example, a date in January would return 31.\n     *\n     * @return the length of the month in days\n     */\n    @Override\n    public int lengthOfMonth() {\n        switch (month) {\n            case 2:\n                return (isLeapYear() ? 29 : 28);\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Returns the length of the year represented by this date.\n     * \u003cp\u003e\n     * This returns the length of the year in days, either 365 or 366.\n     *\n     * @return 366 if the year is leap, 365 otherwise\n     */\n    @Override // override for Javadoc and performance\n    public int lengthOfYear() {\n        return (isLeapYear() ? 366 : 365);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the date adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * \u003cp\u003e\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d localDate.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return a {@code LocalDate} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return (LocalDate) adjuster;\n        }\n        return (LocalDate) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAY_OF_WEEK} -\n     *  Returns a {@code LocalDate} with the specified day-of-week.\n     *  The date is adjusted up to 6 days forward or backward within the boundary\n     *  of a Monday to Sunday week.\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH} -\n     *  Returns a {@code LocalDate} with the specified aligned-day-of-week.\n     *  The date is adjusted to the specified month-based aligned-day-of-week.\n     *  Aligned weeks are counted such that the first week of a given month starts\n     *  on the first day of that month.\n     *  This may cause the date to be moved up to 6 days into the following month.\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR} -\n     *  Returns a {@code LocalDate} with the specified aligned-day-of-week.\n     *  The date is adjusted to the specified year-based aligned-day-of-week.\n     *  Aligned weeks are counted such that the first week of a given year starts\n     *  on the first day of that year.\n     *  This may cause the date to be moved up to 6 days into the following year.\n     * \u003cli\u003e{@code DAY_OF_MONTH} -\n     *  Returns a {@code LocalDate} with the specified day-of-month.\n     *  The month and year will be unchanged. If the day-of-month is invalid for the\n     *  year and month, then a {@code DateTimeException} is thrown.\n     * \u003cli\u003e{@code DAY_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified day-of-year.\n     *  The year will be unchanged. If the day-of-year is invalid for the\n     *  year, then a {@code DateTimeException} is thrown.\n     * \u003cli\u003e{@code EPOCH_DAY} -\n     *  Returns a {@code LocalDate} with the specified epoch-day.\n     *  This completely replaces the date and is equivalent to {@link #ofEpochDay(long)}.\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH} -\n     *  Returns a {@code LocalDate} with the specified aligned-week-of-month.\n     *  Aligned weeks are counted such that the first week of a given month starts\n     *  on the first day of that month.\n     *  This adjustment moves the date in whole week chunks to match the specified week.\n     *  The result will have the same day-of-week as this date.\n     *  This may cause the date to be moved into the following month.\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified aligned-week-of-year.\n     *  Aligned weeks are counted such that the first week of a given year starts\n     *  on the first day of that year.\n     *  This adjustment moves the date in whole week chunks to match the specified week.\n     *  The result will have the same day-of-week as this date.\n     *  This may cause the date to be moved into the following year.\n     * \u003cli\u003e{@code MONTH_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified month-of-year.\n     *  The year will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code PROLEPTIC_MONTH} -\n     *  Returns a {@code LocalDate} with the specified proleptic-month.\n     *  The day-of-month will be unchanged, unless it would be invalid for the new month\n     *  and year. In that case, the day-of-month is adjusted to the maximum valid value\n     *  for the new month and year.\n     * \u003cli\u003e{@code YEAR_OF_ERA} -\n     *  Returns a {@code LocalDate} with the specified year-of-era.\n     *  The era and month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code YEAR} -\n     *  Returns a {@code LocalDate} with the specified year.\n     *  The month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code ERA} -\n     *  Returns a {@code LocalDate} with the specified era.\n     *  The year-of-era and month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return a {@code LocalDate} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            f.checkValidValue(newValue);\n            switch (f) {\n                case DAY_OF_WEEK: return plusDays(newValue - getDayOfWeek().getValue());\n                case ALIGNED_DAY_OF_WEEK_IN_MONTH: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n                case ALIGNED_DAY_OF_WEEK_IN_YEAR: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                case DAY_OF_MONTH: return withDayOfMonth((int) newValue);\n                case DAY_OF_YEAR: return withDayOfYear((int) newValue);\n                case EPOCH_DAY: return LocalDate.ofEpochDay(newValue);\n                case ALIGNED_WEEK_OF_MONTH: return plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_MONTH));\n                case ALIGNED_WEEK_OF_YEAR: return plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_YEAR));\n                case MONTH_OF_YEAR: return withMonth((int) newValue);\n                case PROLEPTIC_MONTH: return plusMonths(newValue - getProlepticMonth());\n                case YEAR_OF_ERA: return withYear((int) (year \u003e\u003d 1 ? newValue : 1 - newValue));\n                case YEAR: return withYear((int) newValue);\n                case ERA: return (getLong(ERA) \u003d\u003d newValue ? this : withYear(1 - year));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the year altered.\n     * \u003cp\u003e\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return a {@code LocalDate} based on this date with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public LocalDate withYear(int year) {\n        if (this.year \u003d\u003d year) {\n            return this;\n        }\n        YEAR.checkValidValue(year);\n        return resolvePreviousValid(year, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the month-of-year altered.\n     * \u003cp\u003e\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return a {@code LocalDate} based on this date with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public LocalDate withMonth(int month) {\n        if (this.month \u003d\u003d month) {\n            return this;\n        }\n        MONTH_OF_YEAR.checkValidValue(month);\n        return resolvePreviousValid(year, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting date is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return a {@code LocalDate} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public LocalDate withDayOfMonth(int dayOfMonth) {\n        if (this.day \u003d\u003d dayOfMonth) {\n            return this;\n        }\n        return of(year, month, dayOfMonth);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the day-of-year altered.\n     * \u003cp\u003e\n     * If the resulting date is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return a {@code LocalDate} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public LocalDate withDayOfYear(int dayOfYear) {\n        if (this.getDayOfYear() \u003d\u003d dayOfYear) {\n            return this;\n        }\n        return ofYearDay(year, dayOfYear);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return a {@code LocalDate} based on this date with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate plus(TemporalAmount amountToAdd) {\n        if (amountToAdd instanceof Period) {\n            Period periodToAdd \u003d (Period) amountToAdd;\n            return plusMonths(periodToAdd.toTotalMonths()).plusDays(periodToAdd.getDays());\n        }\n        Objects.requireNonNull(amountToAdd, \"amountToAdd\");\n        return (LocalDate) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, adding the amount can cause the resulting date to become invalid.\n     * For example, adding one month to 31st January would result in 31st February.\n     * In cases like this, the unit is responsible for resolving the date.\n     * Typically it will choose the previous valid date, which would be the last valid\n     * day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented here.\n     * The supported fields behave as follows:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAYS} -\n     *  Returns a {@code LocalDate} with the specified number of days added.\n     *  This is equivalent to {@link #plusDays(long)}.\n     * \u003cli\u003e{@code WEEKS} -\n     *  Returns a {@code LocalDate} with the specified number of weeks added.\n     *  This is equivalent to {@link #plusWeeks(long)} and uses a 7 day week.\n     * \u003cli\u003e{@code MONTHS} -\n     *  Returns a {@code LocalDate} with the specified number of months added.\n     *  This is equivalent to {@link #plusMonths(long)}.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code YEARS} -\n     *  Returns a {@code LocalDate} with the specified number of years added.\n     *  This is equivalent to {@link #plusYears(long)}.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code DECADES} -\n     *  Returns a {@code LocalDate} with the specified number of decades added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 10.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code CENTURIES} -\n     *  Returns a {@code LocalDate} with the specified number of centuries added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 100.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code MILLENNIA} -\n     *  Returns a {@code LocalDate} with the specified number of millennia added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 1,000.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code ERAS} -\n     *  Returns a {@code LocalDate} with the specified number of eras added.\n     *  Only two eras are supported so the amount must be one, zero or minus one.\n     *  If the amount is non-zero then the year is changed such that the year-of-era\n     *  is unchanged.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * All other {@code ChronoUnit} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return a {@code LocalDate} based on this date with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            ChronoUnit f \u003d (ChronoUnit) unit;\n            switch (f) {\n                case DAYS: return plusDays(amountToAdd);\n                case WEEKS: return plusWeeks(amountToAdd);\n                case MONTHS: return plusMonths(amountToAdd);\n                case YEARS: return plusYears(amountToAdd);\n                case DECADES: return plusYears(Math.multiplyExact(amountToAdd, 10));\n                case CENTURIES: return plusYears(Math.multiplyExact(amountToAdd, 100));\n                case MILLENNIA: return plusYears(Math.multiplyExact(amountToAdd, 1000));\n                case ERAS: return with(ERA, Math.addExact(getLong(ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param yearsToAdd  the years to add, may be negative\n     * @return a {@code LocalDate} based on this date with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusYears(long yearsToAdd) {\n        if (yearsToAdd \u003d\u003d 0) {\n            return this;\n        }\n        int newYear \u003d YEAR.checkValidIntValue(year + yearsToAdd);  // safe overflow\n        return resolvePreviousValid(newYear, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param monthsToAdd  the months to add, may be negative\n     * @return a {@code LocalDate} based on this date with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusMonths(long monthsToAdd) {\n        if (monthsToAdd \u003d\u003d 0) {\n            return this;\n        }\n        long monthCount \u003d year * 12L + (month - 1);\n        long calcMonths \u003d monthCount + monthsToAdd;  // safe overflow\n        int newYear \u003d YEAR.checkValidIntValue(Math.floorDiv(calcMonths, 12));\n        int newMonth \u003d Math.floorMod(calcMonths, 12) + 1;\n        return resolvePreviousValid(newYear, newMonth, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeksToAdd  the weeks to add, may be negative\n     * @return a {@code LocalDate} based on this date with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusWeeks(long weeksToAdd) {\n        return plusDays(Math.multiplyExact(weeksToAdd, 7));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param daysToAdd  the days to add, may be negative\n     * @return a {@code LocalDate} based on this date with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusDays(long daysToAdd) {\n        if (daysToAdd \u003d\u003d 0) {\n            return this;\n        }\n        long dom \u003d day + daysToAdd;\n        if (dom \u003e 0) {\n            if (dom \u003c\u003d 28) {\n                return new LocalDate(year, month, (int) dom);\n            } else if (dom \u003c\u003d 59) { // 59th Jan is 28th Feb, 59th Feb is 31st Mar\n                long monthLen \u003d lengthOfMonth();\n                if (dom \u003c\u003d monthLen) {\n                    return new LocalDate(year, month, (int) dom);\n                } else if (month \u003c 12) {\n                    return new LocalDate(year, month + 1, (int) (dom - monthLen));\n                } else {\n                    YEAR.checkValidValue(year + 1);\n                    return new LocalDate(year + 1, 1, (int) (dom - monthLen));\n                }\n            }\n        }\n\n        long mjDay \u003d Math.addExact(toEpochDay(), daysToAdd);\n        return LocalDate.ofEpochDay(mjDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return a {@code LocalDate} based on this date with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate minus(TemporalAmount amountToSubtract) {\n        if (amountToSubtract instanceof Period) {\n            Period periodToSubtract \u003d (Period) amountToSubtract;\n            return minusMonths(periodToSubtract.toTotalMonths()).minusDays(periodToSubtract.getDays());\n        }\n        Objects.requireNonNull(amountToSubtract, \"amountToSubtract\");\n        return (LocalDate) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return a {@code LocalDate} based on this date with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param yearsToSubtract  the years to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusYears(long yearsToSubtract) {\n        return (yearsToSubtract \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-yearsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param monthsToSubtract  the months to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusMonths(long monthsToSubtract) {\n        return (monthsToSubtract \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-monthsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeksToSubtract  the weeks to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusWeeks(long weeksToSubtract) {\n        return (weeksToSubtract \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeksToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param daysToSubtract  the days to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusDays(long daysToSubtract) {\n        return (daysToSubtract \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-daysToSubtract));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date using the specified query.\n     * \u003cp\u003e\n     * This queries this date using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) this;\n        }\n        return ChronoLocalDate.super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the date changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * passing {@link ChronoField#EPOCH_DAY} as the field.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisLocalDate.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisLocalDate);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc\n    public Temporal adjustInto(Temporal temporal) {\n        return ChronoLocalDate.super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the amount of time until another date in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code LocalDate}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code LocalDate} using {@link #from(TemporalAccessor)}.\n     * For example, the amount in days between two dates can be calculated\n     * using {@code startDate.until(endDate, DAYS)}.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two dates.\n     * For example, the amount in months between 2012-06-15 and 2012-08-14\n     * will only be one month as it is one day short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code DAYS}, {@code WEEKS}, {@code MONTHS}, {@code YEARS},\n     * {@code DECADES}, {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS}\n     * are supported. Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to a {@code LocalDate}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date and the end date\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to a {@code LocalDate}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        LocalDate end \u003d LocalDate.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch ((ChronoUnit) unit) {\n                case DAYS: return daysUntil(end);\n                case WEEKS: return daysUntil(end) / 7;\n                case MONTHS: return monthsUntil(end);\n                case YEARS: return monthsUntil(end) / 12;\n                case DECADES: return monthsUntil(end) / 120;\n                case CENTURIES: return monthsUntil(end) / 1200;\n                case MILLENNIA: return monthsUntil(end) / 12000;\n                case ERAS: return end.getLong(ERA) - getLong(ERA);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    long daysUntil(LocalDate end) {\n        return end.toEpochDay() - toEpochDay();  // no overflow\n    }\n\n    private long monthsUntil(LocalDate end) {\n        long packed1 \u003d getProlepticMonth() * 32L + getDayOfMonth();  // no overflow\n        long packed2 \u003d end.getProlepticMonth() * 32L + end.getDayOfMonth();  // no overflow\n        return (packed2 - packed1) / 32;\n    }\n\n    /**\n     * Calculates the period between this date and another date as a {@code Period}.\n     * \u003cp\u003e\n     * This calculates the period between two dates in terms of years, months and days.\n     * The start and end points are {@code this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The negative sign will be the same in each of year, month and day.\n     * \u003cp\u003e\n     * The calculation is performed using the ISO calendar system.\n     * If necessary, the input date will be converted to ISO.\n     * \u003cp\u003e\n     * The start date is included, but the end date is not.\n     * The period is calculated by removing complete months, then calculating\n     * the remaining number of days, adjusting to ensure that both have the same sign.\n     * The number of months is then normalized into years and months based on a 12 month year.\n     * A month is considered to be complete if the end day-of-month is greater\n     * than or equal to the start day-of-month.\n     * For example, from {@code 2010-01-15} to {@code 2011-03-18} is \"1 year, 2 months and 3 days\".\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link Period#between(LocalDate, LocalDate)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   period \u003d start.until(end);\n     *   period \u003d Period.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     *\n     * @param endDateExclusive  the end date, exclusive, which may be in any chronology, not null\n     * @return the period between this date and the end date, not null\n     */\n    @Override\n    public Period until(ChronoLocalDate endDateExclusive) {\n        LocalDate end \u003d LocalDate.from(endDateExclusive);\n        long totalMonths \u003d end.getProlepticMonth() - this.getProlepticMonth();  // safe\n        int days \u003d end.day - this.day;\n        if (totalMonths \u003e 0 \u0026\u0026 days \u003c 0) {\n            totalMonths--;\n            LocalDate calcDate \u003d this.plusMonths(totalMonths);\n            days \u003d (int) (end.toEpochDay() - calcDate.toEpochDay());  // safe\n        } else if (totalMonths \u003c 0 \u0026\u0026 days \u003e 0) {\n            totalMonths++;\n            days -\u003d end.lengthOfMonth();\n        }\n        long years \u003d totalMonths / 12;  // safe\n        int months \u003d (int) (totalMonths % 12);  // safe\n        return Period.of(Math.toIntExact(years), months, days);\n    }\n\n    /**\n     * Returns a sequential ordered stream of dates. The returned stream starts from this date\n     * (inclusive) and goes to {@code endExclusive} (exclusive) by an incremental step of 1 day.\n     * \u003cp\u003e\n     * This method is equivalent to {@code datesUntil(endExclusive, Period.ofDays(1))}.\n     *\n     * @param endExclusive  the end date, exclusive, not null\n     * @return a sequential {@code Stream} for the range of {@code LocalDate} values\n     * @throws IllegalArgumentException if end date is before this date\n     * @since 9\n     */\n    public Stream\u003cLocalDate\u003e datesUntil(LocalDate endExclusive) {\n        long end \u003d endExclusive.toEpochDay();\n        long start \u003d toEpochDay();\n        if (end \u003c start) {\n            throw new IllegalArgumentException(endExclusive + \" \u003c \" + this);\n        }\n        return LongStream.range(start, end).mapToObj(LocalDate::ofEpochDay);\n    }\n\n    /**\n     * Returns a sequential ordered stream of dates by given incremental step. The returned stream\n     * starts from this date (inclusive) and goes to {@code endExclusive} (exclusive).\n     * \u003cp\u003e\n     * The n-th date which appears in the stream is equal to {@code this.plus(step.multipliedBy(n))}\n     * (but the result of step multiplication never overflows). For example, if this date is\n     * {@code 2015-01-31}, the end date is {@code 2015-05-01} and the step is 1 month, then the\n     * stream contains {@code 2015-01-31}, {@code 2015-02-28}, {@code 2015-03-31}, and\n     * {@code 2015-04-30}.\n     *\n     * @param endExclusive  the end date, exclusive, not null\n     * @param step  the non-zero, non-negative {@code Period} which represents the step.\n     * @return a sequential {@code Stream} for the range of {@code LocalDate} values\n     * @throws IllegalArgumentException if step is zero, or {@code step.getDays()} and\n     *             {@code step.toTotalMonths()} have opposite sign, or end date is before this date\n     *             and step is positive, or end date is after this date and step is negative\n     * @since 9\n     */\n    public Stream\u003cLocalDate\u003e datesUntil(LocalDate endExclusive, Period step) {\n        if (step.isZero()) {\n            throw new IllegalArgumentException(\"step is zero\");\n        }\n        long end \u003d endExclusive.toEpochDay();\n        long start \u003d toEpochDay();\n        long until \u003d end - start;\n        long months \u003d step.toTotalMonths();\n        long days \u003d step.getDays();\n        if ((months \u003c 0 \u0026\u0026 days \u003e 0) || (months \u003e 0 \u0026\u0026 days \u003c 0)) {\n            throw new IllegalArgumentException(\"period months and days are of opposite sign\");\n        }\n        if (until \u003d\u003d 0) {\n            return Stream.empty();\n        }\n        int sign \u003d months \u003e 0 || days \u003e 0 ? 1 : -1;\n        if (sign \u003c 0 ^ until \u003c 0) {\n            throw new IllegalArgumentException(endExclusive + (sign \u003c 0 ? \" \u003e \" : \" \u003c \") + this);\n        }\n        if (months \u003d\u003d 0) {\n            long steps \u003d (until - sign) / days; // non-negative\n            return LongStream.rangeClosed(0, steps).mapToObj(\n                    n -\u003e LocalDate.ofEpochDay(start + n * days));\n        }\n        // 48699/1600 \u003d 365.2425/12, no overflow, non-negative result\n        long steps \u003d until * 1600 / (months * 48699 + days * 1600) + 1;\n        long addMonths \u003d months * steps;\n        long addDays \u003d days * steps;\n        long maxAddMonths \u003d months \u003e 0 ? MAX.getProlepticMonth() - getProlepticMonth()\n                : getProlepticMonth() - MIN.getProlepticMonth();\n        // adjust steps estimation\n        if (addMonths * sign \u003e maxAddMonths\n                || (plusMonths(addMonths).toEpochDay() + addDays) * sign \u003e\u003d end * sign) {\n            steps--;\n            addMonths -\u003d months;\n            addDays -\u003d days;\n            if (addMonths * sign \u003e maxAddMonths\n                    || (plusMonths(addMonths).toEpochDay() + addDays) * sign \u003e\u003d end * sign) {\n                steps--;\n            }\n        }\n        return LongStream.rangeClosed(0, steps).mapToObj(\n                n -\u003e this.plusMonths(months * n).plusDays(days * n));\n    }\n\n    /**\n     * Formats this date using the specified formatter.\n     * \u003cp\u003e\n     * This date will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    @Override  // override for Javadoc and performance\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param time  the time to combine with, not null\n     * @return the local date-time formed from this date and the specified time, not null\n     */\n    @Override\n    public LocalDateTime atTime(LocalTime time) {\n        return LocalDateTime.of(this, time);\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour and minute.\n     * The seconds and nanosecond fields will be set to zero.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute) {\n        return atTime(LocalTime.of(hour, minute));\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour, minute and second.\n     * The nanosecond field will be set to zero.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute, int second) {\n        return atTime(LocalTime.of(hour, minute, second));\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour, minute, second and nanosecond.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute, int second, int nanoOfSecond) {\n        return atTime(LocalTime.of(hour, minute, second, nanoOfSecond));\n    }\n\n    /**\n     * Combines this date with an offset time to create an {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param time  the time to combine with, not null\n     * @return the offset date-time formed from this date and the specified time, not null\n     */\n    public OffsetDateTime atTime(OffsetTime time) {\n        return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.getOffset());\n    }\n\n    /**\n     * Combines this date with the time of midnight to create a {@code LocalDateTime}\n     * at the start of this date.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the time of\n     * midnight, 00:00, at the start of this date.\n     *\n     * @return the local date-time of midnight at the start of this date, not null\n     */\n    public LocalDateTime atStartOfDay() {\n        return LocalDateTime.of(this, LocalTime.MIDNIGHT);\n    }\n\n    /**\n     * Returns a zoned date-time from this date at the earliest valid time according\n     * to the rules in the time-zone.\n     * \u003cp\u003e\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may not be midnight.\n     * \u003cp\u003e\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, there are two valid offsets, and the earlier one is used,\n     * corresponding to the first occurrence of midnight on the date.\n     * In the case of a gap, the zoned date-time will represent the instant just after the gap.\n     * \u003cp\u003e\n     * If the zone ID is a {@link ZoneOffset}, then the result always has a time of midnight.\n     * \u003cp\u003e\n     * To convert to a specific time in a given time-zone call {@link #atTime(LocalTime)}\n     * followed by {@link LocalDateTime#atZone(ZoneId)}.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atStartOfDay(ZoneId zone) {\n        Objects.requireNonNull(zone, \"zone\");\n        // need to handle case where there is a gap from 11:30 to 00:30\n        // standard ZDT factory would result in 01:00 rather than 00:30\n        LocalDateTime ldt \u003d atTime(LocalTime.MIDNIGHT);\n        if (zone instanceof ZoneOffset \u003d\u003d false) {\n            ZoneRules rules \u003d zone.getRules();\n            ZoneOffsetTransition trans \u003d rules.getTransition(ldt);\n            if (trans !\u003d null \u0026\u0026 trans.isGap()) {\n                ldt \u003d trans.getDateTimeAfter();\n            }\n        }\n        return ZonedDateTime.of(ldt, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public long toEpochDay() {\n        long y \u003d year;\n        long m \u003d month;\n        long total \u003d 0;\n        total +\u003d 365 * y;\n        if (y \u003e\u003d 0) {\n            total +\u003d (y + 3) / 4 - (y + 99) / 100 + (y + 399) / 400;\n        } else {\n            total -\u003d y / -4 - y / -100 + y / -400;\n        }\n        total +\u003d ((367 * m - 362) / 12);\n        total +\u003d day - 1;\n        if (m \u003e 2) {\n            total--;\n            if (isLeapYear() \u003d\u003d false) {\n                total--;\n            }\n        }\n        return total - DAYS_0000_TO_1970;\n    }\n\n    /**\n     * Converts this {@code LocalDate} to the number of seconds since the epoch\n     * of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This combines this local date with the specified time and\n     * offset to calculate the epoch-second value, which is the\n     * number of elapsed seconds from 1970-01-01T00:00:00Z.\n     * Instants on the time-line after the epoch are positive, earlier\n     * are negative.\n     *\n     * @param time the local time, not null\n     * @param offset the zone offset, not null\n     * @return the number of seconds since the epoch of 1970-01-01T00:00:00Z, may be negative\n     * @since 9\n     */\n    public long toEpochSecond(LocalTime time, ZoneOffset offset) {\n        Objects.requireNonNull(time, \"time\");\n        Objects.requireNonNull(offset, \"offset\");\n        long secs \u003d toEpochDay() * SECONDS_PER_DAY + time.toSecondOfDay();\n        secs -\u003d offset.getTotalSeconds();\n        return secs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date to another date.\n     * \u003cp\u003e\n     * The comparison is primarily based on the date, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * If all the dates being compared are instances of {@code LocalDate},\n     * then the comparison will be entirely based on the date.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link java.time.chrono.ChronoLocalDate#compareTo}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override  // override for Javadoc and performance\n    public int compareTo(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other);\n        }\n        return ChronoLocalDate.super.compareTo(other);\n    }\n\n    int compareTo0(LocalDate otherDate) {\n        int cmp \u003d (year - otherDate.year);\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d (month - otherDate.month);\n            if (cmp \u003d\u003d 0) {\n                cmp \u003d (day - otherDate.day);\n            }\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date is after the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents a point on the\n     * local time-line after the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isAfter(b) \u003d\u003d false\n     *   a.isAfter(a) \u003d\u003d false\n     *   b.isAfter(a) \u003d\u003d true\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is after the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isAfter(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003e 0;\n        }\n        return ChronoLocalDate.super.isAfter(other);\n    }\n\n    /**\n     * Checks if this date is before the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents a point on the\n     * local time-line before the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isBefore(b) \u003d\u003d true\n     *   a.isBefore(a) \u003d\u003d false\n     *   b.isBefore(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is before the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isBefore(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003c 0;\n        }\n        return ChronoLocalDate.super.isBefore(other);\n    }\n\n    /**\n     * Checks if this date is equal to the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents the same point on the\n     * local time-line as the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isEqual(b) \u003d\u003d false\n     *   a.isEqual(a) \u003d\u003d true\n     *   b.isEqual(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)}\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is equal to the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isEqual(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003d\u003d 0;\n        }\n        return ChronoLocalDate.super.isEqual(other);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date is equal to another date.\n     * \u003cp\u003e\n     * Compares this {@code LocalDate} with another ensuring that the date is the same.\n     * \u003cp\u003e\n     * Only objects of type {@code LocalDate} are compared, other types return false.\n     * To compare the dates of two {@code TemporalAccessor} instances, including dates\n     * in two different chronologies, use {@link ChronoField#EPOCH_DAY} as a comparator.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof LocalDate) {\n            return compareTo0((LocalDate) obj) \u003d\u003d 0;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        int yearValue \u003d year;\n        int monthValue \u003d month;\n        int dayValue \u003d day;\n        return (yearValue \u0026 0xFFFFF800) ^ ((yearValue \u003c\u003c 11) + (monthValue \u003c\u003c 6) + (dayValue));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date as a {@code String}, such as {@code 2007-12-03}.\n     * \u003cp\u003e\n     * The output will be in the ISO-8601 format {@code uuuu-MM-dd}.\n     *\n     * @return a string representation of this date, not null\n     */\n    @Override\n    public String toString() {\n        int yearValue \u003d year;\n        int monthValue \u003d month;\n        int dayValue \u003d day;\n        int absYear \u003d Math.abs(yearValue);\n        StringBuilder buf \u003d new StringBuilder(10);\n        if (absYear \u003c 1000) {\n            if (yearValue \u003c 0) {\n                buf.append(yearValue - 10000).deleteCharAt(1);\n            } else {\n                buf.append(yearValue + 10000).deleteCharAt(0);\n            }\n        } else {\n            if (yearValue \u003e 9999) {\n                buf.append(\u0027+\u0027);\n            }\n            buf.append(yearValue);\n        }\n        return buf.append(monthValue \u003c 10 ? \"-0\" : \"-\")\n            .append(monthValue)\n            .append(dayValue \u003c 10 ? \"-0\" : \"-\")\n            .append(dayValue)\n            .toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(3);  // identifies a LocalDate\n     *  out.writeInt(year);\n     *  out.writeByte(month);\n     *  out.writeByte(day);\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.LOCAL_DATE_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(DataOutput out) throws IOException {\n        out.writeInt(year);\n        out.writeByte(month);\n        out.writeByte(day);\n    }\n\n    static LocalDate readExternal(DataInput in) throws IOException {\n        int year \u003d in.readInt();\n        int month \u003d in.readByte();\n        int dayOfMonth \u003d in.readByte();\n        return LocalDate.of(year, month, dayOfMonth);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 18, 2024 3:05:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java"
  ]
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor27.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.10.18 15:05:07 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:545)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	jdk.internal.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:05:07 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:443)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	jdk.internal.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:05:07 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

2024.10.18 15:05:07 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.codeLens(WorkspaceLspService.scala:530)
	scala.meta.metals.lsp.DelegatingScalaService.codeLens(DelegatingScalaService.scala:150)
	jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$3(MetalsLspService.scala:1225)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$2(MetalsLspService.scala:1224)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:05:07 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.documentSymbol(WorkspaceLspService.scala:460)
	scala.meta.metals.lsp.DelegatingScalaService.documentSymbol(DelegatingScalaService.scala:91)
	jdk.internal.reflect.GeneratedMethodAccessor5.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$documentSymbol$1(MetalsLspService.scala:1055)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:05:07 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:07 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

oct 18, 2024 3:05:10 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.18 15:05:10 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:10 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/ClassLoader.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.\n * Copyright (c) 2019, Azul Systems, Inc. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.File;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.URL;\nimport java.security.AccessController;\nimport java.security.AccessControlContext;\nimport java.security.CodeSource;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.security.cert.Certificate;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.Vector;\nimport java.util.WeakHashMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.loader.BuiltinClassLoader;\nimport jdk.internal.perf.PerfCounter;\nimport jdk.internal.loader.BootLoader;\nimport jdk.internal.loader.ClassLoaders;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.misc.VM;\nimport jdk.internal.ref.CleanerFactory;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport sun.reflect.misc.ReflectUtil;\nimport sun.security.util.SecurityConstants;\n\n/**\n * A class loader is an object that is responsible for loading classes. The\n * class {@code ClassLoader} is an abstract class.  Given the \u003ca\n * href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e of a class, a class loader should attempt to\n * locate or generate data that constitutes a definition for the class.  A\n * typical strategy is to transform the name into a file name and then read a\n * \"class file\" of that name from a file system.\n *\n * \u003cp\u003e Every {@link java.lang.Class Class} object contains a {@link\n * Class#getClassLoader() reference} to the {@code ClassLoader} that defined\n * it.\n *\n * \u003cp\u003e {@code Class} objects for array classes are not created by class\n * loaders, but are created automatically as required by the Java runtime.\n * The class loader for an array class, as returned by {@link\n * Class#getClassLoader()} is the same as the class loader for its element\n * type; if the element type is a primitive type, then the array class has no\n * class loader.\n *\n * \u003cp\u003e Applications implement subclasses of {@code ClassLoader} in order to\n * extend the manner in which the Java virtual machine dynamically loads\n * classes.\n *\n * \u003cp\u003e Class loaders may typically be used by security managers to indicate\n * security domains.\n *\n * \u003cp\u003e In addition to loading classes, a class loader is also responsible for\n * locating resources. A resource is some data (a \"{@code .class}\" file,\n * configuration data, or an image for example) that is identified with an\n * abstract \u0027/\u0027-separated path name. Resources are typically packaged with an\n * application or library so that they can be located by code in the\n * application or library. In some cases, the resources are included so that\n * they can be located by other libraries.\n *\n * \u003cp\u003e The {@code ClassLoader} class uses a delegation model to search for\n * classes and resources.  Each instance of {@code ClassLoader} has an\n * associated parent class loader. When requested to find a class or\n * resource, a {@code ClassLoader} instance will usually delegate the search\n * for the class or resource to its parent class loader before attempting to\n * find the class or resource itself.\n *\n * \u003cp\u003e Class loaders that support concurrent loading of classes are known as\n * \u003cem\u003e{@linkplain #isRegisteredAsParallelCapable() parallel capable}\u003c/em\u003e class\n * loaders and are required to register themselves at their class initialization\n * time by invoking the {@link\n * #registerAsParallelCapable ClassLoader.registerAsParallelCapable}\n * method. Note that the {@code ClassLoader} class is registered as parallel\n * capable by default. However, its subclasses still need to register themselves\n * if they are parallel capable.\n * In environments in which the delegation model is not strictly\n * hierarchical, class loaders need to be parallel capable, otherwise class\n * loading can lead to deadlocks because the loader lock is held for the\n * duration of the class loading process (see {@link #loadClass\n * loadClass} methods).\n *\n * \u003ch3\u003e \u003ca id\u003d\"builtinLoaders\"\u003eRun-time Built-in Class Loaders\u003c/a\u003e\u003c/h3\u003e\n *\n * The Java run-time has the following built-in class loaders:\n *\n * \u003cul\u003e\n * \u003cli\u003e\u003cp\u003eBootstrap class loader.\n *     It is the virtual machine\u0027s built-in class loader, typically represented\n *     as {@code null}, and does not have a parent.\u003c/li\u003e\n * \u003cli\u003e\u003cp\u003e{@linkplain #getPlatformClassLoader() Platform class loader}.\n *     All \u003cem\u003eplatform classes\u003c/em\u003e are visible to the platform class loader\n *     that can be used as the parent of a {@code ClassLoader} instance.\n *     Platform classes include Java SE platform APIs, their implementation\n *     classes and JDK-specific run-time classes that are defined by the\n *     platform class loader or its ancestors.\n *     \u003cp\u003e To allow for upgrading/overriding of modules defined to the platform\n *     class loader, and where upgraded modules read modules defined to class\n *     loaders other than the platform class loader and its ancestors, then\n *     the platform class loader may have to delegate to other class loaders,\n *     the application class loader for example.\n *     In other words, classes in named modules defined to class loaders\n *     other than the platform class loader and its ancestors may be visible\n *     to the platform class loader. \u003c/li\u003e\n * \u003cli\u003e\u003cp\u003e{@linkplain #getSystemClassLoader() System class loader}.\n *     It is also known as \u003cem\u003eapplication class loader\u003c/em\u003e and is distinct\n *     from the platform class loader.\n *     The system class loader is typically used to define classes on the\n *     application class path, module path, and JDK-specific tools.\n *     The platform class loader is a parent or an ancestor of the system class\n *     loader that all platform classes are visible to it.\u003c/li\u003e\n * \u003c/ul\u003e\n *\n * \u003cp\u003e Normally, the Java virtual machine loads classes from the local file\n * system in a platform-dependent manner.\n * However, some classes may not originate from a file; they may originate\n * from other sources, such as the network, or they could be constructed by an\n * application.  The method {@link #defineClass(String, byte[], int, int)\n * defineClass} converts an array of bytes into an instance of class\n * {@code Class}. Instances of this newly defined class can be created using\n * {@link Class#newInstance Class.newInstance}.\n *\n * \u003cp\u003e The methods and constructors of objects created by a class loader may\n * reference other classes.  To determine the class(es) referred to, the Java\n * virtual machine invokes the {@link #loadClass loadClass} method of\n * the class loader that originally created the class.\n *\n * \u003cp\u003e For example, an application could create a network class loader to\n * download class files from a server.  Sample code might look like:\n *\n * \u003cblockquote\u003e\u003cpre\u003e\n *   ClassLoader loader\u0026nbsp;\u003d new NetworkClassLoader(host,\u0026nbsp;port);\n *   Object main\u0026nbsp;\u003d loader.loadClass(\"Main\", true).newInstance();\n *       \u0026nbsp;.\u0026nbsp;.\u0026nbsp;.\n * \u003c/pre\u003e\u003c/blockquote\u003e\n *\n * \u003cp\u003e The network class loader subclass must define the methods {@link\n * #findClass findClass} and {@code loadClassData} to load a class\n * from the network.  Once it has downloaded the bytes that make up the class,\n * it should use the method {@link #defineClass defineClass} to\n * create a class instance.  A sample implementation is:\n *\n * \u003cblockquote\u003e\u003cpre\u003e\n *     class NetworkClassLoader extends ClassLoader {\n *         String host;\n *         int port;\n *\n *         public Class findClass(String name) {\n *             byte[] b \u003d loadClassData(name);\n *             return defineClass(name, b, 0, b.length);\n *         }\n *\n *         private byte[] loadClassData(String name) {\n *             // load the class data from the connection\n *             \u0026nbsp;.\u0026nbsp;.\u0026nbsp;.\n *         }\n *     }\n * \u003c/pre\u003e\u003c/blockquote\u003e\n *\n * \u003ch3\u003e \u003ca id\u003d\"binary-name\"\u003eBinary names\u003c/a\u003e \u003c/h3\u003e\n *\n * \u003cp\u003e Any class name provided as a {@code String} parameter to methods in\n * {@code ClassLoader} must be a binary name as defined by\n * \u003ccite\u003eThe Java\u0026trade; Language Specification\u003c/cite\u003e.\n *\n * \u003cp\u003e Examples of valid class names include:\n * \u003cblockquote\u003e\u003cpre\u003e\n *   \"java.lang.String\"\n *   \"javax.swing.JSpinner$DefaultEditor\"\n *   \"java.security.KeyStore$Builder$FileBuilder$1\"\n *   \"java.net.URLClassLoader$3$1\"\n * \u003c/pre\u003e\u003c/blockquote\u003e\n *\n * \u003cp\u003e Any package name provided as a {@code String} parameter to methods in\n * {@code ClassLoader} must be either the empty string (denoting an unnamed package)\n * or a fully qualified name as defined by\n * \u003ccite\u003eThe Java\u0026trade; Language Specification\u003c/cite\u003e.\n *\n * @jls 6.7  Fully Qualified Names\n * @jls 13.1 The Form of a Binary\n * @see      #resolveClass(Class)\n * @since 1.0\n * @revised 9\n * @spec JPMS\n */\npublic abstract class ClassLoader {\n\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    // The parent class loader for delegation\n    // Note: VM hardcoded the offset of this field, thus all new fields\n    // must be added *after* it.\n    private final ClassLoader parent;\n\n    // class loader name\n    private final String name;\n\n    // the unnamed module for this ClassLoader\n    private final Module unnamedModule;\n\n    // a string for exception message printing\n    private final String nameAndId;\n\n    /**\n     * Encapsulates the set of parallel capable loader types.\n     */\n    private static class ParallelLoaders {\n        private ParallelLoaders() {}\n\n        // the set of parallel capable loader types\n        private static final Set\u003cClass\u003c? extends ClassLoader\u003e\u003e loaderTypes \u003d\n            Collections.newSetFromMap(new WeakHashMap\u003c\u003e());\n        static {\n            synchronized (loaderTypes) { loaderTypes.add(ClassLoader.class); }\n        }\n\n        /**\n         * Registers the given class loader type as parallel capable.\n         * Returns {@code true} is successfully registered; {@code false} if\n         * loader\u0027s super class is not registered.\n         */\n        static boolean register(Class\u003c? extends ClassLoader\u003e c) {\n            synchronized (loaderTypes) {\n                if (loaderTypes.contains(c.getSuperclass())) {\n                    // register the class loader as parallel capable\n                    // if and only if all of its super classes are.\n                    // Note: given current classloading sequence, if\n                    // the immediate super class is parallel capable,\n                    // all the super classes higher up must be too.\n                    loaderTypes.add(c);\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        }\n\n        /**\n         * Returns {@code true} if the given class loader type is\n         * registered as parallel capable.\n         */\n        static boolean isRegistered(Class\u003c? extends ClassLoader\u003e c) {\n            synchronized (loaderTypes) {\n                return loaderTypes.contains(c);\n            }\n        }\n    }\n\n    // Maps class name to the corresponding lock object when the current\n    // class loader is parallel capable.\n    // Note: VM also uses this field to decide if the current class loader\n    // is parallel capable and the appropriate lock object for class loading.\n    private final ConcurrentHashMap\u003cString, Object\u003e parallelLockMap;\n\n    // Maps packages to certs\n    private final Map \u003cString, Certificate[]\u003e package2certs;\n\n    // Shared among all packages with unsigned classes\n    private static final Certificate[] nocerts \u003d new Certificate[0];\n\n    // The classes loaded by this class loader. The only purpose of this table\n    // is to keep the classes from being GC\u0027ed until the loader is GC\u0027ed.\n    private final Vector\u003cClass\u003c?\u003e\u003e classes \u003d new Vector\u003c\u003e();\n\n    // The \"default\" domain. Set as the default ProtectionDomain on newly\n    // created classes.\n    private final ProtectionDomain defaultDomain \u003d\n        new ProtectionDomain(new CodeSource(null, (Certificate[]) null),\n                             null, this, null);\n\n    // Invoked by the VM to record every loaded class with this loader.\n    void addClass(Class\u003c?\u003e c) {\n        classes.addElement(c);\n    }\n\n    // The packages defined in this class loader.  Each package name is\n    // mapped to its corresponding NamedPackage object.\n    //\n    // The value is a Package object if ClassLoader::definePackage,\n    // Class::getPackage, ClassLoader::getDefinePackage(s) or\n    // Package::getPackage(s) method is called to define it.\n    // Otherwise, the value is a NamedPackage object.\n    private final ConcurrentHashMap\u003cString, NamedPackage\u003e packages\n            \u003d new ConcurrentHashMap\u003c\u003e();\n\n    /*\n     * Returns a named package for the given module.\n     */\n    private NamedPackage getNamedPackage(String pn, Module m) {\n        NamedPackage p \u003d packages.get(pn);\n        if (p \u003d\u003d null) {\n            p \u003d new NamedPackage(pn, m);\n\n            NamedPackage value \u003d packages.putIfAbsent(pn, p);\n            if (value !\u003d null) {\n                // Package object already be defined for the named package\n                p \u003d value;\n                // if definePackage is called by this class loader to define\n                // a package in a named module, this will return Package\n                // object of the same name.  Package object may contain\n                // unexpected information but it does not impact the runtime.\n                // this assertion may be helpful for troubleshooting\n                assert value.module() \u003d\u003d m;\n            }\n        }\n        return p;\n    }\n\n    private static Void checkCreateClassLoader() {\n        return checkCreateClassLoader(null);\n    }\n\n    private static Void checkCreateClassLoader(String name) {\n        if (name !\u003d null \u0026\u0026 name.isEmpty()) {\n            throw new IllegalArgumentException(\"name must be non-empty or null\");\n        }\n\n        SecurityManager security \u003d System.getSecurityManager();\n        if (security !\u003d null) {\n            security.checkCreateClassLoader();\n        }\n        return null;\n    }\n\n    private ClassLoader(Void unused, String name, ClassLoader parent) {\n        this.name \u003d name;\n        this.parent \u003d parent;\n        this.unnamedModule \u003d new Module(this);\n        if (ParallelLoaders.isRegistered(this.getClass())) {\n            parallelLockMap \u003d new ConcurrentHashMap\u003c\u003e();\n            package2certs \u003d new ConcurrentHashMap\u003c\u003e();\n            assertionLock \u003d new Object();\n        } else {\n            // no finer-grained lock; lock on the classloader instance\n            parallelLockMap \u003d null;\n            package2certs \u003d new Hashtable\u003c\u003e();\n            assertionLock \u003d this;\n        }\n        this.nameAndId \u003d nameAndId(this);\n    }\n\n    /**\n     * If the defining loader has a name explicitly set then\n     *       \u0027\u003cloader-name\u003e\u0027 @\u003cid\u003e\n     * If the defining loader has no name then\n     *       \u003cqualified-class-name\u003e @\u003cid\u003e\n     * If it\u0027s built-in loader then omit `@\u003cid\u003e` as there is only one instance.\n     */\n    private static String nameAndId(ClassLoader ld) {\n        String nid \u003d ld.getName() !\u003d null ? \"\\\u0027\" + ld.getName() + \"\\\u0027\"\n                                          : ld.getClass().getName();\n        if (!(ld instanceof BuiltinClassLoader)) {\n            String id \u003d Integer.toHexString(System.identityHashCode(ld));\n            nid \u003d nid + \" @\" + id;\n        }\n        return nid;\n    }\n\n    // Returns nameAndId string for exception message printing\n    String nameAndId() {\n        return nameAndId;\n    }\n\n    /**\n     * Creates a new class loader of the specified name and using the\n     * specified parent class loader for delegation.\n     *\n     * @apiNote If the parent is specified as {@code null} (for the\n     * bootstrap class loader) then there is no guarantee that all platform\n     * classes are visible.\n     *\n     * @param  name   class loader name; or {@code null} if not named\n     * @param  parent the parent class loader\n     *\n     * @throws IllegalArgumentException if the given name is empty.\n     *\n     * @throws SecurityException\n     *         If a security manager exists and its\n     *         {@link SecurityManager#checkCreateClassLoader()}\n     *         method doesn\u0027t allow creation of a new class loader.\n     *\n     * @since  9\n     * @spec JPMS\n     */\n    protected ClassLoader(String name, ClassLoader parent) {\n        this(checkCreateClassLoader(name), name, parent);\n    }\n\n    /**\n     * Creates a new class loader using the specified parent class loader for\n     * delegation.\n     *\n     * \u003cp\u003e If there is a security manager, its {@link\n     * SecurityManager#checkCreateClassLoader() checkCreateClassLoader} method\n     * is invoked.  This may result in a security exception.  \u003c/p\u003e\n     *\n     * @apiNote If the parent is specified as {@code null} (for the\n     * bootstrap class loader) then there is no guarantee that all platform\n     * classes are visible.\n     *\n     * @param  parent\n     *         The parent class loader\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its\n     *          {@code checkCreateClassLoader} method doesn\u0027t allow creation\n     *          of a new class loader.\n     *\n     * @since  1.2\n     */\n    protected ClassLoader(ClassLoader parent) {\n        this(checkCreateClassLoader(), null, parent);\n    }\n\n    /**\n     * Creates a new class loader using the {@code ClassLoader} returned by\n     * the method {@link #getSystemClassLoader()\n     * getSystemClassLoader()} as the parent class loader.\n     *\n     * \u003cp\u003e If there is a security manager, its {@link\n     * SecurityManager#checkCreateClassLoader()\n     * checkCreateClassLoader} method is invoked.  This may result in\n     * a security exception.  \u003c/p\u003e\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its\n     *          {@code checkCreateClassLoader} method doesn\u0027t allow creation\n     *          of a new class loader.\n     */\n    protected ClassLoader() {\n        this(checkCreateClassLoader(), null, getSystemClassLoader());\n    }\n\n    /**\n     * Returns the name of this class loader or {@code null} if\n     * this class loader is not named.\n     *\n     * @apiNote This method is non-final for compatibility.  If this\n     * method is overridden, this method must return the same name\n     * as specified when this class loader was instantiated.\n     *\n     * @return name of this class loader; or {@code null} if\n     * this class loader is not named.\n     *\n     * @since 9\n     * @spec JPMS\n     */\n    public String getName() {\n        return name;\n    }\n\n    // package-private used by StackTraceElement to avoid\n    // calling the overrideable getName method\n    final String name() {\n        return name;\n    }\n\n    // -- Class --\n\n    /**\n     * Loads the class with the specified \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e.\n     * This method searches for classes in the same manner as the {@link\n     * #loadClass(String, boolean)} method.  It is invoked by the Java virtual\n     * machine to resolve class references.  Invoking this method is equivalent\n     * to invoking {@link #loadClass(String, boolean) loadClass(name,\n     * false)}.\n     *\n     * @param  name\n     *         The \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e of the class\n     *\n     * @return  The resulting {@code Class} object\n     *\n     * @throws  ClassNotFoundException\n     *          If the class was not found\n     */\n    public Class\u003c?\u003e loadClass(String name) throws ClassNotFoundException {\n        return loadClass(name, false);\n    }\n\n    /**\n     * Loads the class with the specified \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e.  The\n     * default implementation of this method searches for classes in the\n     * following order:\n     *\n     * \u003col\u003e\n     *\n     *   \u003cli\u003e\u003cp\u003e Invoke {@link #findLoadedClass(String)} to check if the class\n     *   has already been loaded.  \u003c/p\u003e\u003c/li\u003e\n     *\n     *   \u003cli\u003e\u003cp\u003e Invoke the {@link #loadClass(String) loadClass} method\n     *   on the parent class loader.  If the parent is {@code null} the class\n     *   loader built into the virtual machine is used, instead.  \u003c/p\u003e\u003c/li\u003e\n     *\n     *   \u003cli\u003e\u003cp\u003e Invoke the {@link #findClass(String)} method to find the\n     *   class.  \u003c/p\u003e\u003c/li\u003e\n     *\n     * \u003c/ol\u003e\n     *\n     * \u003cp\u003e If the class was found using the above steps, and the\n     * {@code resolve} flag is true, this method will then invoke the {@link\n     * #resolveClass(Class)} method on the resulting {@code Class} object.\n     *\n     * \u003cp\u003e Subclasses of {@code ClassLoader} are encouraged to override {@link\n     * #findClass(String)}, rather than this method.  \u003c/p\u003e\n     *\n     * \u003cp\u003e Unless overridden, this method synchronizes on the result of\n     * {@link #getClassLoadingLock getClassLoadingLock} method\n     * during the entire class loading process.\n     *\n     * @param  name\n     *         The \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e of the class\n     *\n     * @param  resolve\n     *         If {@code true} then resolve the class\n     *\n     * @return  The resulting {@code Class} object\n     *\n     * @throws  ClassNotFoundException\n     *          If the class could not be found\n     */\n    protected Class\u003c?\u003e loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            Class\u003c?\u003e c \u003d findLoadedClass(name);\n            if (c \u003d\u003d null) {\n                long t0 \u003d System.nanoTime();\n                try {\n                    if (parent !\u003d null) {\n                        c \u003d parent.loadClass(name, false);\n                    } else {\n                        c \u003d findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n\n                if (c \u003d\u003d null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    long t1 \u003d System.nanoTime();\n                    c \u003d findClass(name);\n\n                    // this is the defining class loader; record the stats\n                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                    PerfCounter.getFindClasses().increment();\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n\n    /**\n     * Loads the class with the specified \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e\n     * in a module defined to this class loader.  This method returns {@code null}\n     * if the class could not be found.\n     *\n     * @apiNote This method does not delegate to the parent class loader.\n     *\n     * @implSpec The default implementation of this method searches for classes\n     * in the following order:\n     *\n     * \u003col\u003e\n     *   \u003cli\u003eInvoke {@link #findLoadedClass(String)} to check if the class\n     *   has already been loaded.\u003c/li\u003e\n     *   \u003cli\u003eInvoke the {@link #findClass(String, String)} method to find the\n     *   class in the given module.\u003c/li\u003e\n     * \u003c/ol\u003e\n     *\n     * @param  module\n     *         The module\n     * @param  name\n     *         The \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e of the class\n     *\n     * @return The resulting {@code Class} object in a module defined by\n     *         this class loader, or {@code null} if the class could not be found.\n     */\n    final Class\u003c?\u003e loadClass(Module module, String name) {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            Class\u003c?\u003e c \u003d findLoadedClass(name);\n            if (c \u003d\u003d null) {\n                c \u003d findClass(module.getName(), name);\n            }\n            if (c !\u003d null \u0026\u0026 c.getModule() \u003d\u003d module) {\n                return c;\n            } else {\n                return null;\n            }\n        }\n    }\n\n    /**\n     * Returns the lock object for class loading operations.\n     * For backward compatibility, the default implementation of this method\n     * behaves as follows. If this ClassLoader object is registered as\n     * parallel capable, the method returns a dedicated object associated\n     * with the specified class name. Otherwise, the method returns this\n     * ClassLoader object.\n     *\n     * @param  className\n     *         The name of the to-be-loaded class\n     *\n     * @return the lock for class loading operations\n     *\n     * @throws NullPointerException\n     *         If registered as parallel capable and {@code className} is null\n     *\n     * @see #loadClass(String, boolean)\n     *\n     * @since  1.7\n     */\n    protected Object getClassLoadingLock(String className) {\n        Object lock \u003d this;\n        if (parallelLockMap !\u003d null) {\n            Object newLock \u003d new Object();\n            lock \u003d parallelLockMap.putIfAbsent(className, newLock);\n            if (lock \u003d\u003d null) {\n                lock \u003d newLock;\n            }\n        }\n        return lock;\n    }\n\n    // Invoked by the VM after loading class with this loader.\n    private void checkPackageAccess(Class\u003c?\u003e cls, ProtectionDomain pd) {\n        final SecurityManager sm \u003d System.getSecurityManager();\n        if (sm !\u003d null) {\n            if (ReflectUtil.isNonPublicProxyClass(cls)) {\n                for (Class\u003c?\u003e intf: cls.getInterfaces()) {\n                    checkPackageAccess(intf, pd);\n                }\n                return;\n            }\n\n            final String packageName \u003d cls.getPackageName();\n            if (!packageName.isEmpty()) {\n                AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    public Void run() {\n                        sm.checkPackageAccess(packageName);\n                        return null;\n                    }\n                }, new AccessControlContext(new ProtectionDomain[] {pd}));\n            }\n        }\n    }\n\n    /**\n     * Finds the class with the specified \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e.\n     * This method should be overridden by class loader implementations that\n     * follow the delegation model for loading classes, and will be invoked by\n     * the {@link #loadClass loadClass} method after checking the\n     * parent class loader for the requested class.\n     *\n     * @implSpec The default implementation throws {@code ClassNotFoundException}.\n     *\n     * @param  name\n     *         The \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e of the class\n     *\n     * @return  The resulting {@code Class} object\n     *\n     * @throws  ClassNotFoundException\n     *          If the class could not be found\n     *\n     * @since  1.2\n     */\n    protected Class\u003c?\u003e findClass(String name) throws ClassNotFoundException {\n        throw new ClassNotFoundException(name);\n    }\n\n    /**\n     * Finds the class with the given \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e\n     * in a module defined to this class loader.\n     * Class loader implementations that support loading from modules\n     * should override this method.\n     *\n     * @apiNote This method returns {@code null} rather than throwing\n     *          {@code ClassNotFoundException} if the class could not be found.\n     *\n     * @implSpec The default implementation attempts to find the class by\n     * invoking {@link #findClass(String)} when the {@code moduleName} is\n     * {@code null}. It otherwise returns {@code null}.\n     *\n     * @param  moduleName\n     *         The module name; or {@code null} to find the class in the\n     *         {@linkplain #getUnnamedModule() unnamed module} for this\n     *         class loader\n\n     * @param  name\n     *         The \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e of the class\n     *\n     * @return The resulting {@code Class} object, or {@code null}\n     *         if the class could not be found.\n     *\n     * @since 9\n     * @spec JPMS\n     */\n    protected Class\u003c?\u003e findClass(String moduleName, String name) {\n        if (moduleName \u003d\u003d null) {\n            try {\n                return findClass(name);\n            } catch (ClassNotFoundException ignore) { }\n        }\n        return null;\n    }\n\n\n    /**\n     * Converts an array of bytes into an instance of class {@code Class}.\n     * Before the {@code Class} can be used it must be resolved.  This method\n     * is deprecated in favor of the version that takes a \u003ca\n     * href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e as its first argument, and is more secure.\n     *\n     * @param  b\n     *         The bytes that make up the class data.  The bytes in positions\n     *         {@code off} through {@code off+len-1} should have the format\n     *         of a valid class file as defined by\n     *         \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e.\n     *\n     * @param  off\n     *         The start offset in {@code b} of the class data\n     *\n     * @param  len\n     *         The length of the class data\n     *\n     * @return  The {@code Class} object that was created from the specified\n     *          class data\n     *\n     * @throws  ClassFormatError\n     *          If the data did not contain a valid class\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If either {@code off} or {@code len} is negative, or if\n     *          {@code off+len} is greater than {@code b.length}.\n     *\n     * @throws  SecurityException\n     *          If an attempt is made to add this class to a package that\n     *          contains classes that were signed by a different set of\n     *          certificates than this class, or if an attempt is made\n     *          to define a class in a package with a fully-qualified name\n     *          that starts with \"{@code java.}\".\n     *\n     * @see  #loadClass(String, boolean)\n     * @see  #resolveClass(Class)\n     *\n     * @deprecated  Replaced by {@link #defineClass(String, byte[], int, int)\n     * defineClass(String, byte[], int, int)}\n     */\n    @Deprecated(since\u003d\"1.1\")\n    protected final Class\u003c?\u003e defineClass(byte[] b, int off, int len)\n        throws ClassFormatError\n    {\n        return defineClass(null, b, off, len, null);\n    }\n\n    /**\n     * Converts an array of bytes into an instance of class {@code Class}.\n     * Before the {@code Class} can be used it must be resolved.\n     *\n     * \u003cp\u003e This method assigns a default {@link java.security.ProtectionDomain\n     * ProtectionDomain} to the newly defined class.  The\n     * {@code ProtectionDomain} is effectively granted the same set of\n     * permissions returned when {@link\n     * java.security.Policy#getPermissions(java.security.CodeSource)\n     * Policy.getPolicy().getPermissions(new CodeSource(null, null))}\n     * is invoked.  The default protection domain is created on the first invocation\n     * of {@link #defineClass(String, byte[], int, int) defineClass},\n     * and re-used on subsequent invocations.\n     *\n     * \u003cp\u003e To assign a specific {@code ProtectionDomain} to the class, use\n     * the {@link #defineClass(String, byte[], int, int,\n     * java.security.ProtectionDomain) defineClass} method that takes a\n     * {@code ProtectionDomain} as one of its arguments.  \u003c/p\u003e\n     *\n     * \u003cp\u003e\n     * This method defines a package in this class loader corresponding to the\n     * package of the {@code Class} (if such a package has not already been defined\n     * in this class loader). The name of the defined package is derived from\n     * the \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e of the class specified by\n     * the byte array {@code b}.\n     * Other properties of the defined package are as specified by {@link Package}.\n     *\n     * @param  name\n     *         The expected \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e of the class, or\n     *         {@code null} if not known\n     *\n     * @param  b\n     *         The bytes that make up the class data.  The bytes in positions\n     *         {@code off} through {@code off+len-1} should have the format\n     *         of a valid class file as defined by\n     *         \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e.\n     *\n     * @param  off\n     *         The start offset in {@code b} of the class data\n     *\n     * @param  len\n     *         The length of the class data\n     *\n     * @return  The {@code Class} object that was created from the specified\n     *          class data.\n     *\n     * @throws  ClassFormatError\n     *          If the data did not contain a valid class\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If either {@code off} or {@code len} is negative, or if\n     *          {@code off+len} is greater than {@code b.length}.\n     *\n     * @throws  SecurityException\n     *          If an attempt is made to add this class to a package that\n     *          contains classes that were signed by a different set of\n     *          certificates than this class (which is unsigned), or if\n     *          {@code name} begins with \"{@code java.}\".\n     *\n     * @see  #loadClass(String, boolean)\n     * @see  #resolveClass(Class)\n     * @see  java.security.CodeSource\n     * @see  java.security.SecureClassLoader\n     *\n     * @since  1.1\n     * @revised 9\n     * @spec JPMS\n     */\n    protected final Class\u003c?\u003e defineClass(String name, byte[] b, int off, int len)\n        throws ClassFormatError\n    {\n        return defineClass(name, b, off, len, null);\n    }\n\n    /* Determine protection domain, and check that:\n        - not define java.* class,\n        - signer of this class matches signers for the rest of the classes in\n          package.\n    */\n    private ProtectionDomain preDefineClass(String name,\n                                            ProtectionDomain pd)\n    {\n        if (!checkName(name))\n            throw new NoClassDefFoundError(\"IllegalName: \" + name);\n\n        // Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias\n        // relies on the fact that spoofing is impossible if a class has a name\n        // of the form \"java.*\"\n        if ((name !\u003d null) \u0026\u0026 name.startsWith(\"java.\")\n                \u0026\u0026 this !\u003d getBuiltinPlatformClassLoader()) {\n            throw new SecurityException\n                (\"Prohibited package name: \" +\n                 name.substring(0, name.lastIndexOf(\u0027.\u0027)));\n        }\n        if (pd \u003d\u003d null) {\n            pd \u003d defaultDomain;\n        }\n\n        if (name !\u003d null) {\n            checkCerts(name, pd.getCodeSource());\n        }\n\n        return pd;\n    }\n\n    private String defineClassSourceLocation(ProtectionDomain pd) {\n        CodeSource cs \u003d pd.getCodeSource();\n        String source \u003d null;\n        if (cs !\u003d null \u0026\u0026 cs.getLocation() !\u003d null) {\n            source \u003d cs.getLocation().toString();\n        }\n        return source;\n    }\n\n    private void postDefineClass(Class\u003c?\u003e c, ProtectionDomain pd) {\n        // define a named package, if not present\n        getNamedPackage(c.getPackageName(), c.getModule());\n\n        if (pd.getCodeSource() !\u003d null) {\n            Certificate certs[] \u003d pd.getCodeSource().getCertificates();\n            if (certs !\u003d null)\n                setSigners(c, certs);\n        }\n    }\n\n    /**\n     * Converts an array of bytes into an instance of class {@code Class},\n     * with a given {@code ProtectionDomain}.\n     *\n     * \u003cp\u003e If the given {@code ProtectionDomain} is {@code null},\n     * then a default protection domain will be assigned to the class as specified\n     * in the documentation for {@link #defineClass(String, byte[], int, int)}.\n     * Before the class can be used it must be resolved.\n     *\n     * \u003cp\u003e The first class defined in a package determines the exact set of\n     * certificates that all subsequent classes defined in that package must\n     * contain.  The set of certificates for a class is obtained from the\n     * {@link java.security.CodeSource CodeSource} within the\n     * {@code ProtectionDomain} of the class.  Any classes added to that\n     * package must contain the same set of certificates or a\n     * {@code SecurityException} will be thrown.  Note that if\n     * {@code name} is {@code null}, this check is not performed.\n     * You should always pass in the \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e of the\n     * class you are defining as well as the bytes.  This ensures that the\n     * class you are defining is indeed the class you think it is.\n     *\n     * \u003cp\u003e If the specified {@code name} begins with \"{@code java.}\", it can\n     * only be defined by the {@linkplain #getPlatformClassLoader()\n     * platform class loader} or its ancestors; otherwise {@code SecurityException}\n     * will be thrown.  If {@code name} is not {@code null}, it must be equal to\n     * the \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e of the class\n     * specified by the byte array {@code b}, otherwise a {@link\n     * NoClassDefFoundError NoClassDefFoundError} will be thrown.\n     *\n     * \u003cp\u003e This method defines a package in this class loader corresponding to the\n     * package of the {@code Class} (if such a package has not already been defined\n     * in this class loader). The name of the defined package is derived from\n     * the \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e of the class specified by\n     * the byte array {@code b}.\n     * Other properties of the defined package are as specified by {@link Package}.\n     *\n     * @param  name\n     *         The expected \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e of the class, or\n     *         {@code null} if not known\n     *\n     * @param  b\n     *         The bytes that make up the class data. The bytes in positions\n     *         {@code off} through {@code off+len-1} should have the format\n     *         of a valid class file as defined by\n     *         \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e.\n     *\n     * @param  off\n     *         The start offset in {@code b} of the class data\n     *\n     * @param  len\n     *         The length of the class data\n     *\n     * @param  protectionDomain\n     *         The {@code ProtectionDomain} of the class\n     *\n     * @return  The {@code Class} object created from the data,\n     *          and {@code ProtectionDomain}.\n     *\n     * @throws  ClassFormatError\n     *          If the data did not contain a valid class\n     *\n     * @throws  NoClassDefFoundError\n     *          If {@code name} is not {@code null} and not equal to the\n     *          \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e of the class specified by {@code b}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If either {@code off} or {@code len} is negative, or if\n     *          {@code off+len} is greater than {@code b.length}.\n     *\n     * @throws  SecurityException\n     *          If an attempt is made to add this class to a package that\n     *          contains classes that were signed by a different set of\n     *          certificates than this class, or if {@code name} begins with\n     *          \"{@code java.}\" and this class loader is not the platform\n     *          class loader or its ancestor.\n     *\n     * @revised 9\n     * @spec JPMS\n     */\n    protected final Class\u003c?\u003e defineClass(String name, byte[] b, int off, int len,\n                                         ProtectionDomain protectionDomain)\n        throws ClassFormatError\n    {\n        protectionDomain \u003d preDefineClass(name, protectionDomain);\n        String source \u003d defineClassSourceLocation(protectionDomain);\n        Class\u003c?\u003e c \u003d defineClass1(this, name, b, off, len, protectionDomain, source);\n        postDefineClass(c, protectionDomain);\n        return c;\n    }\n\n    /**\n     * Converts a {@link java.nio.ByteBuffer ByteBuffer} into an instance\n     * of class {@code Class}, with the given {@code ProtectionDomain}.\n     * If the given {@code ProtectionDomain} is {@code null}, then a default\n     * protection domain will be assigned to the class as\n     * specified in the documentation for {@link #defineClass(String, byte[],\n     * int, int)}.  Before the class can be used it must be resolved.\n     *\n     * \u003cp\u003eThe rules about the first class defined in a package determining the\n     * set of certificates for the package, the restrictions on class names,\n     * and the defined package of the class\n     * are identical to those specified in the documentation for {@link\n     * #defineClass(String, byte[], int, int, ProtectionDomain)}.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003ecl\u003c/i\u003e{@code .defineClass(}\u003ci\u003ename\u003c/i\u003e{@code ,}\n     * \u003ci\u003ebBuffer\u003c/i\u003e{@code ,} \u003ci\u003epd\u003c/i\u003e{@code )} yields exactly the same\n     * result as the statements\n     *\n     *\u003cp\u003e \u003ccode\u003e\n     * ...\u003cbr\u003e\n     * byte[] temp \u003d new byte[bBuffer.{@link\n     * java.nio.ByteBuffer#remaining remaining}()];\u003cbr\u003e\n     *     bBuffer.{@link java.nio.ByteBuffer#get(byte[])\n     * get}(temp);\u003cbr\u003e\n     *     return {@link #defineClass(String, byte[], int, int, ProtectionDomain)\n     * cl.defineClass}(name, temp, 0,\n     * temp.length, pd);\u003cbr\u003e\n     * \u003c/code\u003e\u003c/p\u003e\n     *\n     * @param  name\n     *         The expected \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e. of the class, or\n     *         {@code null} if not known\n     *\n     * @param  b\n     *         The bytes that make up the class data. The bytes from positions\n     *         {@code b.position()} through {@code b.position() + b.limit() -1\n     *         } should have the format of a valid class file as defined by\n     *         \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e.\n     *\n     * @param  protectionDomain\n     *         The {@code ProtectionDomain} of the class, or {@code null}.\n     *\n     * @return  The {@code Class} object created from the data,\n     *          and {@code ProtectionDomain}.\n     *\n     * @throws  ClassFormatError\n     *          If the data did not contain a valid class.\n     *\n     * @throws  NoClassDefFoundError\n     *          If {@code name} is not {@code null} and not equal to the\n     *          \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e of the class specified by {@code b}\n     *\n     * @throws  SecurityException\n     *          If an attempt is made to add this class to a package that\n     *          contains classes that were signed by a different set of\n     *          certificates than this class, or if {@code name} begins with\n     *          \"{@code java.}\".\n     *\n     * @see      #defineClass(String, byte[], int, int, ProtectionDomain)\n     *\n     * @since  1.5\n     * @revised 9\n     * @spec JPMS\n     */\n    protected final Class\u003c?\u003e defineClass(String name, java.nio.ByteBuffer b,\n                                         ProtectionDomain protectionDomain)\n        throws ClassFormatError\n    {\n        int len \u003d b.remaining();\n\n        // Use byte[] if not a direct ByteBuffer:\n        if (!b.isDirect()) {\n            if (b.hasArray()) {\n                return defineClass(name, b.array(),\n                                   b.position() + b.arrayOffset(), len,\n                                   protectionDomain);\n            } else {\n                // no array, or read-only array\n                byte[] tb \u003d new byte[len];\n                b.get(tb);  // get bytes out of byte buffer.\n                return defineClass(name, tb, 0, len, protectionDomain);\n            }\n        }\n\n        protectionDomain \u003d preDefineClass(name, protectionDomain);\n        String source \u003d defineClassSourceLocation(protectionDomain);\n        Class\u003c?\u003e c \u003d defineClass2(this, name, b, b.position(), len, protectionDomain, source);\n        postDefineClass(c, protectionDomain);\n        return c;\n    }\n\n    static native Class\u003c?\u003e defineClass1(ClassLoader loader, String name, byte[] b, int off, int len,\n                                        ProtectionDomain pd, String source);\n\n    static native Class\u003c?\u003e defineClass2(ClassLoader loader, String name, java.nio.ByteBuffer b,\n                                        int off, int len, ProtectionDomain pd,\n                                        String source);\n\n    // true if the name is null or has the potential to be a valid binary name\n    private boolean checkName(String name) {\n        if ((name \u003d\u003d null) || (name.isEmpty()))\n            return true;\n        if ((name.indexOf(\u0027/\u0027) !\u003d -1) || (name.charAt(0) \u003d\u003d \u0027[\u0027))\n            return false;\n        return true;\n    }\n\n    private void checkCerts(String name, CodeSource cs) {\n        int i \u003d name.lastIndexOf(\u0027.\u0027);\n        String pname \u003d (i \u003d\u003d -1) ? \"\" : name.substring(0, i);\n\n        Certificate[] certs \u003d null;\n        if (cs !\u003d null) {\n            certs \u003d cs.getCertificates();\n        }\n        Certificate[] pcerts \u003d null;\n        if (parallelLockMap \u003d\u003d null) {\n            synchronized (this) {\n                pcerts \u003d package2certs.get(pname);\n                if (pcerts \u003d\u003d null) {\n                    package2certs.put(pname, (certs \u003d\u003d null? nocerts:certs));\n                }\n            }\n        } else {\n            pcerts \u003d ((ConcurrentHashMap\u003cString, Certificate[]\u003e)package2certs).\n                putIfAbsent(pname, (certs \u003d\u003d null? nocerts:certs));\n        }\n        if (pcerts !\u003d null \u0026\u0026 !compareCerts(pcerts, certs)) {\n            throw new SecurityException(\"class \\\"\" + name\n                + \"\\\"\u0027s signer information does not match signer information\"\n                + \" of other classes in the same package\");\n        }\n    }\n\n    /**\n     * check to make sure the certs for the new class (certs) are the same as\n     * the certs for the first class inserted in the package (pcerts)\n     */\n    private boolean compareCerts(Certificate[] pcerts,\n                                 Certificate[] certs)\n    {\n        // certs can be null, indicating no certs.\n        if ((certs \u003d\u003d null) || (certs.length \u003d\u003d 0)) {\n            return pcerts.length \u003d\u003d 0;\n        }\n\n        // the length must be the same at this point\n        if (certs.length !\u003d pcerts.length)\n            return false;\n\n        // go through and make sure all the certs in one array\n        // are in the other and vice-versa.\n        boolean match;\n        for (Certificate cert : certs) {\n            match \u003d false;\n            for (Certificate pcert : pcerts) {\n                if (cert.equals(pcert)) {\n                    match \u003d true;\n                    break;\n                }\n            }\n            if (!match) return false;\n        }\n\n        // now do the same for pcerts\n        for (Certificate pcert : pcerts) {\n            match \u003d false;\n            for (Certificate cert : certs) {\n                if (pcert.equals(cert)) {\n                    match \u003d true;\n                    break;\n                }\n            }\n            if (!match) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Links the specified class.  This (misleadingly named) method may be\n     * used by a class loader to link a class.  If the class {@code c} has\n     * already been linked, then this method simply returns. Otherwise, the\n     * class is linked as described in the \"Execution\" chapter of\n     * \u003ccite\u003eThe Java\u0026trade; Language Specification\u003c/cite\u003e.\n     *\n     * @param  c\n     *         The class to link\n     *\n     * @throws  NullPointerException\n     *          If {@code c} is {@code null}.\n     *\n     * @see  #defineClass(String, byte[], int, int)\n     */\n    protected final void resolveClass(Class\u003c?\u003e c) {\n        if (c \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n    }\n\n    /**\n     * Finds a class with the specified \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e,\n     * loading it if necessary.\n     *\n     * \u003cp\u003e This method loads the class through the system class loader (see\n     * {@link #getSystemClassLoader()}).  The {@code Class} object returned\n     * might have more than one {@code ClassLoader} associated with it.\n     * Subclasses of {@code ClassLoader} need not usually invoke this method,\n     * because most class loaders need to override just {@link\n     * #findClass(String)}.  \u003c/p\u003e\n     *\n     * @param  name\n     *         The \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e of the class\n     *\n     * @return  The {@code Class} object for the specified {@code name}\n     *\n     * @throws  ClassNotFoundException\n     *          If the class could not be found\n     *\n     * @see  #ClassLoader(ClassLoader)\n     * @see  #getParent()\n     */\n    protected final Class\u003c?\u003e findSystemClass(String name)\n        throws ClassNotFoundException\n    {\n        return getSystemClassLoader().loadClass(name);\n    }\n\n    /**\n     * Returns a class loaded by the bootstrap class loader;\n     * or return null if not found.\n     */\n    Class\u003c?\u003e findBootstrapClassOrNull(String name) {\n        if (!checkName(name)) return null;\n\n        return findBootstrapClass(name);\n    }\n\n    // return null if not found\n    private native Class\u003c?\u003e findBootstrapClass(String name);\n\n    /**\n     * Returns the class with the given \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e if this\n     * loader has been recorded by the Java virtual machine as an initiating\n     * loader of a class with that \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e.  Otherwise\n     * {@code null} is returned.\n     *\n     * @param  name\n     *         The \u003ca href\u003d\"#binary-name\"\u003ebinary name\u003c/a\u003e of the class\n     *\n     * @return  The {@code Class} object, or {@code null} if the class has\n     *          not been loaded\n     *\n     * @since  1.1\n     */\n    protected final Class\u003c?\u003e findLoadedClass(String name) {\n        if (!checkName(name))\n            return null;\n        return findLoadedClass0(name);\n    }\n\n    private final native Class\u003c?\u003e findLoadedClass0(String name);\n\n    /**\n     * Sets the signers of a class.  This should be invoked after defining a\n     * class.\n     *\n     * @param  c\n     *         The {@code Class} object\n     *\n     * @param  signers\n     *         The signers for the class\n     *\n     * @since  1.1\n     */\n    protected final void setSigners(Class\u003c?\u003e c, Object[] signers) {\n        c.setSigners(signers);\n    }\n\n\n    // -- Resources --\n\n    /**\n     * Returns a URL to a resource in a module defined to this class loader.\n     * Class loader implementations that support loading from modules\n     * should override this method.\n     *\n     * @apiNote This method is the basis for the {@link\n     * Class#getResource Class.getResource}, {@link Class#getResourceAsStream\n     * Class.getResourceAsStream}, and {@link Module#getResourceAsStream\n     * Module.getResourceAsStream} methods. It is not subject to the rules for\n     * encapsulation specified by {@code Module.getResourceAsStream}.\n     *\n     * @implSpec The default implementation attempts to find the resource by\n     * invoking {@link #findResource(String)} when the {@code moduleName} is\n     * {@code null}. It otherwise returns {@code null}.\n     *\n     * @param  moduleName\n     *         The module name; or {@code null} to find a resource in the\n     *         {@linkplain #getUnnamedModule() unnamed module} for this\n     *         class loader\n     * @param  name\n     *         The resource name\n     *\n     * @return A URL to the resource; {@code null} if the resource could not be\n     *         found, a URL could not be constructed to locate the resource,\n     *         access to the resource is denied by the security manager, or\n     *         there isn\u0027t a module of the given name defined to the class\n     *         loader.\n     *\n     * @throws IOException\n     *         If I/O errors occur\n     *\n     * @see java.lang.module.ModuleReader#find(String)\n     * @since 9\n     * @spec JPMS\n     */\n    protected URL findResource(String moduleName, String name) throws IOException {\n        if (moduleName \u003d\u003d null) {\n            return findResource(name);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Finds the resource with the given name.  A resource is some data\n     * (images, audio, text, etc) that can be accessed by class code in a way\n     * that is independent of the location of the code.\n     *\n     * \u003cp\u003e The name of a resource is a \u0027{@code /}\u0027-separated path name that\n     * identifies the resource. \u003c/p\u003e\n     *\n     * \u003cp\u003e Resources in named modules are subject to the encapsulation rules\n     * specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.\n     * Additionally, and except for the special case where the resource has a\n     * name ending with \"{@code .class}\", this method will only find resources in\n     * packages of named modules when the package is {@link Module#isOpen(String)\n     * opened} unconditionally (even if the caller of this method is in the\n     * same module as the resource). \u003c/p\u003e\n     *\n     * @implSpec The default implementation will first search the parent class\n     * loader for the resource; if the parent is {@code null} the path of the\n     * class loader built into the virtual machine is searched. If not found,\n     * this method will invoke {@link #findResource(String)} to find the resource.\n     *\n     * @apiNote Where several modules are defined to the same class loader,\n     * and where more than one module contains a resource with the given name,\n     * then the ordering that modules are searched is not specified and may be\n     * very unpredictable.\n     * When overriding this method it is recommended that an implementation\n     * ensures that any delegation is consistent with the {@link\n     * #getResources(java.lang.String) getResources(String)} method.\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  {@code URL} object for reading the resource; {@code null} if\n     *          the resource could not be found, a {@code URL} could not be\n     *          constructed to locate the resource, the resource is in a package\n     *          that is not opened unconditionally, or access to the resource is\n     *          denied by the security manager.\n     *\n     * @throws  NullPointerException If {@code name} is {@code null}\n     *\n     * @since  1.1\n     * @revised 9\n     * @spec JPMS\n     */\n    public URL getResource(String name) {\n        Objects.requireNonNull(name);\n        URL url;\n        if (parent !\u003d null) {\n            url \u003d parent.getResource(name);\n        } else {\n            url \u003d BootLoader.findResource(name);\n        }\n        if (url \u003d\u003d null) {\n            url \u003d findResource(name);\n        }\n        return url;\n    }\n\n    /**\n     * Finds all the resources with the given name. A resource is some data\n     * (images, audio, text, etc) that can be accessed by class code in a way\n     * that is independent of the location of the code.\n     *\n     * \u003cp\u003e The name of a resource is a {@code /}-separated path name that\n     * identifies the resource. \u003c/p\u003e\n     *\n     * \u003cp\u003e Resources in named modules are subject to the encapsulation rules\n     * specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.\n     * Additionally, and except for the special case where the resource has a\n     * name ending with \"{@code .class}\", this method will only find resources in\n     * packages of named modules when the package is {@link Module#isOpen(String)\n     * opened} unconditionally (even if the caller of this method is in the\n     * same module as the resource). \u003c/p\u003e\n     *\n     * @implSpec The default implementation will first search the parent class\n     * loader for the resource; if the parent is {@code null} the path of the\n     * class loader built into the virtual machine is searched. It then\n     * invokes {@link #findResources(String)} to find the resources with the\n     * name in this class loader. It returns an enumeration whose elements\n     * are the URLs found by searching the parent class loader followed by\n     * the elements found with {@code findResources}.\n     *\n     * @apiNote Where several modules are defined to the same class loader,\n     * and where more than one module contains a resource with the given name,\n     * then the ordering is not specified and may be very unpredictable.\n     * When overriding this method it is recommended that an\n     * implementation ensures that any delegation is consistent with the {@link\n     * #getResource(java.lang.String) getResource(String)} method. This should\n     * ensure that the first element returned by the Enumeration\u0027s\n     * {@code nextElement} method is the same resource that the\n     * {@code getResource(String)} method would return.\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  An enumeration of {@link java.net.URL URL} objects for the\n     *          resource. If no resources could be found, the enumeration will\n     *          be empty. Resources for which a {@code URL} cannot be\n     *          constructed, are in a package that is not opened\n     *          unconditionally, or access to the resource is denied by the\n     *          security manager, are not returned in the enumeration.\n     *\n     * @throws  IOException\n     *          If I/O errors occur\n     * @throws  NullPointerException If {@code name} is {@code null}\n     *\n     * @since  1.2\n     * @revised 9\n     * @spec JPMS\n     */\n    public Enumeration\u003cURL\u003e getResources(String name) throws IOException {\n        Objects.requireNonNull(name);\n        @SuppressWarnings(\"unchecked\")\n        Enumeration\u003cURL\u003e[] tmp \u003d (Enumeration\u003cURL\u003e[]) new Enumeration\u003c?\u003e[2];\n        if (parent !\u003d null) {\n            tmp[0] \u003d parent.getResources(name);\n        } else {\n            tmp[0] \u003d BootLoader.findResources(name);\n        }\n        tmp[1] \u003d findResources(name);\n\n        return new CompoundEnumeration\u003c\u003e(tmp);\n    }\n\n    /**\n     * Returns a stream whose elements are the URLs of all the resources with\n     * the given name. A resource is some data (images, audio, text, etc) that\n     * can be accessed by class code in a way that is independent of the\n     * location of the code.\n     *\n     * \u003cp\u003e The name of a resource is a {@code /}-separated path name that\n     * identifies the resource.\n     *\n     * \u003cp\u003e The resources will be located when the returned stream is evaluated.\n     * If the evaluation results in an {@code IOException} then the I/O\n     * exception is wrapped in an {@link UncheckedIOException} that is then\n     * thrown.\n     *\n     * \u003cp\u003e Resources in named modules are subject to the encapsulation rules\n     * specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.\n     * Additionally, and except for the special case where the resource has a\n     * name ending with \"{@code .class}\", this method will only find resources in\n     * packages of named modules when the package is {@link Module#isOpen(String)\n     * opened} unconditionally (even if the caller of this method is in the\n     * same module as the resource). \u003c/p\u003e\n     *\n     * @implSpec The default implementation invokes {@link #getResources(String)\n     * getResources} to find all the resources with the given name and returns\n     * a stream with the elements in the enumeration as the source.\n     *\n     * @apiNote When overriding this method it is recommended that an\n     * implementation ensures that any delegation is consistent with the {@link\n     * #getResource(java.lang.String) getResource(String)} method. This should\n     * ensure that the first element returned by the stream is the same\n     * resource that the {@code getResource(String)} method would return.\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  A stream of resource {@link java.net.URL URL} objects. If no\n     *          resources could  be found, the stream will be empty. Resources\n     *          for which a {@code URL} cannot be constructed, are in a package\n     *          that is not opened unconditionally, or access to the resource\n     *          is denied by the security manager, will not be in the stream.\n     *\n     * @throws  NullPointerException If {@code name} is {@code null}\n     *\n     * @since  9\n     */\n    public Stream\u003cURL\u003e resources(String name) {\n        Objects.requireNonNull(name);\n        int characteristics \u003d Spliterator.NONNULL | Spliterator.IMMUTABLE;\n        Supplier\u003cSpliterator\u003cURL\u003e\u003e si \u003d () -\u003e {\n            try {\n                return Spliterators.spliteratorUnknownSize(\n                    getResources(name).asIterator(), characteristics);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n        return StreamSupport.stream(si, characteristics, false);\n    }\n\n    /**\n     * Finds the resource with the given name. Class loader implementations\n     * should override this method.\n     *\n     * \u003cp\u003e For resources in named modules then the method must implement the\n     * rules for encapsulation specified in the {@code Module} {@link\n     * Module#getResourceAsStream getResourceAsStream} method. Additionally,\n     * it must not find non-\"{@code .class}\" resources in packages of named\n     * modules unless the package is {@link Module#isOpen(String) opened}\n     * unconditionally. \u003c/p\u003e\n     *\n     * @implSpec The default implementation returns {@code null}.\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  {@code URL} object for reading the resource; {@code null} if\n     *          the resource could not be found, a {@code URL} could not be\n     *          constructed to locate the resource, the resource is in a package\n     *          that is not opened unconditionally, or access to the resource is\n     *          denied by the security manager.\n     *\n     * @since  1.2\n     * @revised 9\n     * @spec JPMS\n     */\n    protected URL findResource(String name) {\n        return null;\n    }\n\n    /**\n     * Returns an enumeration of {@link java.net.URL URL} objects\n     * representing all the resources with the given name. Class loader\n     * implementations should override this method.\n     *\n     * \u003cp\u003e For resources in named modules then the method must implement the\n     * rules for encapsulation specified in the {@code Module} {@link\n     * Module#getResourceAsStream getResourceAsStream} method. Additionally,\n     * it must not find non-\"{@code .class}\" resources in packages of named\n     * modules unless the package is {@link Module#isOpen(String) opened}\n     * unconditionally. \u003c/p\u003e\n     *\n     * @implSpec The default implementation returns an enumeration that\n     * contains no elements.\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  An enumeration of {@link java.net.URL URL} objects for\n     *          the resource. If no resources could  be found, the enumeration\n     *          will be empty. Resources for which a {@code URL} cannot be\n     *          constructed, are in a package that is not opened unconditionally,\n     *          or access to the resource is denied by the security manager,\n     *          are not returned in the enumeration.\n     *\n     * @throws  IOException\n     *          If I/O errors occur\n     *\n     * @since  1.2\n     * @revised 9\n     * @spec JPMS\n     */\n    protected Enumeration\u003cURL\u003e findResources(String name) throws IOException {\n        return Collections.emptyEnumeration();\n    }\n\n    /**\n     * Registers the caller as\n     * {@linkplain #isRegisteredAsParallelCapable() parallel capable}.\n     * The registration succeeds if and only if all of the following\n     * conditions are met:\n     * \u003col\u003e\n     * \u003cli\u003e no instance of the caller has been created\u003c/li\u003e\n     * \u003cli\u003e all of the super classes (except class Object) of the caller are\n     * registered as parallel capable\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003eNote that once a class loader is registered as parallel capable, there\n     * is no way to change it back.\u003c/p\u003e\n     *\n     * @return  {@code true} if the caller is successfully registered as\n     *          parallel capable and {@code false} if otherwise.\n     *\n     * @see #isRegisteredAsParallelCapable()\n     *\n     * @since   1.7\n     */\n    @CallerSensitive\n    protected static boolean registerAsParallelCapable() {\n        Class\u003c? extends ClassLoader\u003e callerClass \u003d\n            Reflection.getCallerClass().asSubclass(ClassLoader.class);\n        return ParallelLoaders.register(callerClass);\n    }\n\n    /**\n     * Returns {@code true} if this class loader is registered as\n     * {@linkplain #registerAsParallelCapable parallel capable}, otherwise\n     * {@code false}.\n     *\n     * @return  {@code true} if this class loader is parallel capable,\n     *          otherwise {@code false}.\n     *\n     * @see #registerAsParallelCapable()\n     *\n     * @since   9\n     */\n    public final boolean isRegisteredAsParallelCapable() {\n        return ParallelLoaders.isRegistered(this.getClass());\n    }\n\n    /**\n     * Find a resource of the specified name from the search path used to load\n     * classes.  This method locates the resource through the system class\n     * loader (see {@link #getSystemClassLoader()}).\n     *\n     * \u003cp\u003e Resources in named modules are subject to the encapsulation rules\n     * specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.\n     * Additionally, and except for the special case where the resource has a\n     * name ending with \"{@code .class}\", this method will only find resources in\n     * packages of named modules when the package is {@link Module#isOpen(String)\n     * opened} unconditionally. \u003c/p\u003e\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  A {@link java.net.URL URL} to the resource; {@code\n     *          null} if the resource could not be found, a URL could not be\n     *          constructed to locate the resource, the resource is in a package\n     *          that is not opened unconditionally or access to the resource is\n     *          denied by the security manager.\n     *\n     * @since  1.1\n     * @revised 9\n     * @spec JPMS\n     */\n    public static URL getSystemResource(String name) {\n        return getSystemClassLoader().getResource(name);\n    }\n\n    /**\n     * Finds all resources of the specified name from the search path used to\n     * load classes.  The resources thus found are returned as an\n     * {@link java.util.Enumeration Enumeration} of {@link\n     * java.net.URL URL} objects.\n     *\n     * \u003cp\u003e The search order is described in the documentation for {@link\n     * #getSystemResource(String)}.  \u003c/p\u003e\n     *\n     * \u003cp\u003e Resources in named modules are subject to the encapsulation rules\n     * specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.\n     * Additionally, and except for the special case where the resource has a\n     * name ending with \"{@code .class}\", this method will only find resources in\n     * packages of named modules when the package is {@link Module#isOpen(String)\n     * opened} unconditionally. \u003c/p\u003e\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  An enumeration of {@link java.net.URL URL} objects for\n     *          the resource. If no resources could  be found, the enumeration\n     *          will be empty. Resources for which a {@code URL} cannot be\n     *          constructed, are in a package that is not opened unconditionally,\n     *          or access to the resource is denied by the security manager,\n     *          are not returned in the enumeration.\n     *\n     * @throws  IOException\n     *          If I/O errors occur\n     *\n     * @since  1.2\n     * @revised 9\n     * @spec JPMS\n     */\n    public static Enumeration\u003cURL\u003e getSystemResources(String name)\n        throws IOException\n    {\n        return getSystemClassLoader().getResources(name);\n    }\n\n    /**\n     * Returns an input stream for reading the specified resource.\n     *\n     * \u003cp\u003e The search order is described in the documentation for {@link\n     * #getResource(String)}.  \u003c/p\u003e\n     *\n     * \u003cp\u003e Resources in named modules are subject to the encapsulation rules\n     * specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.\n     * Additionally, and except for the special case where the resource has a\n     * name ending with \"{@code .class}\", this method will only find resources in\n     * packages of named modules when the package is {@link Module#isOpen(String)\n     * opened} unconditionally. \u003c/p\u003e\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  An input stream for reading the resource; {@code null} if the\n     *          resource could not be found, the resource is in a package that\n     *          is not opened unconditionally, or access to the resource is\n     *          denied by the security manager.\n     *\n     * @throws  NullPointerException If {@code name} is {@code null}\n     *\n     * @since  1.1\n     * @revised 9\n     * @spec JPMS\n     */\n    public InputStream getResourceAsStream(String name) {\n        Objects.requireNonNull(name);\n        URL url \u003d getResource(name);\n        try {\n            return url !\u003d null ? url.openStream() : null;\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    /**\n     * Open for reading, a resource of the specified name from the search path\n     * used to load classes.  This method locates the resource through the\n     * system class loader (see {@link #getSystemClassLoader()}).\n     *\n     * \u003cp\u003e Resources in named modules are subject to the encapsulation rules\n     * specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.\n     * Additionally, and except for the special case where the resource has a\n     * name ending with \"{@code .class}\", this method will only find resources in\n     * packages of named modules when the package is {@link Module#isOpen(String)\n     * opened} unconditionally. \u003c/p\u003e\n     *\n     * @param  name\n     *         The resource name\n     *\n     * @return  An input stream for reading the resource; {@code null} if the\n     *          resource could not be found, the resource is in a package that\n     *          is not opened unconditionally, or access to the resource is\n     *          denied by the security manager.\n     *\n     * @since  1.1\n     * @revised 9\n     * @spec JPMS\n     */\n    public static InputStream getSystemResourceAsStream(String name) {\n        URL url \u003d getSystemResource(name);\n        try {\n            return url !\u003d null ? url.openStream() : null;\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n\n    // -- Hierarchy --\n\n    /**\n     * Returns the parent class loader for delegation. Some implementations may\n     * use {@code null} to represent the bootstrap class loader. This method\n     * will return {@code null} in such implementations if this class loader\u0027s\n     * parent is the bootstrap class loader.\n     *\n     * @return  The parent {@code ClassLoader}\n     *\n     * @throws  SecurityException\n     *          If a security manager is present, and the caller\u0027s class loader\n     *          is not {@code null} and is not an ancestor of this class loader,\n     *          and the caller does not have the\n     *          {@link RuntimePermission}{@code (\"getClassLoader\")}\n     *\n     * @since  1.2\n     */\n    @CallerSensitive\n    public final ClassLoader getParent() {\n        if (parent \u003d\u003d null)\n            return null;\n        SecurityManager sm \u003d System.getSecurityManager();\n        if (sm !\u003d null) {\n            // Check access to the parent class loader\n            // If the caller\u0027s class loader is same as this class loader,\n            // permission check is performed.\n            checkClassLoaderPermission(parent, Reflection.getCallerClass());\n        }\n        return parent;\n    }\n\n    /**\n     * Returns the unnamed {@code Module} for this class loader.\n     *\n     * @return The unnamed Module for this class loader\n     *\n     * @see Module#isNamed()\n     * @since 9\n     * @spec JPMS\n     */\n    public final Module getUnnamedModule() {\n        return unnamedModule;\n    }\n\n    /**\n     * Returns the platform class loader.  All\n     * \u003ca href\u003d\"#builtinLoaders\"\u003eplatform classes\u003c/a\u003e are visible to\n     * the platform class loader.\n     *\n     * @implNote The name of the builtin platform class loader is\n     * {@code \"platform\"}.\n     *\n     * @return  The platform {@code ClassLoader}.\n     *\n     * @throws  SecurityException\n     *          If a security manager is present, and the caller\u0027s class loader is\n     *          not {@code null}, and the caller\u0027s class loader is not the same\n     *          as or an ancestor of the platform class loader,\n     *          and the caller does not have the\n     *          {@link RuntimePermission}{@code (\"getClassLoader\")}\n     *\n     * @since 9\n     * @spec JPMS\n     */\n    @CallerSensitive\n    public static ClassLoader getPlatformClassLoader() {\n        SecurityManager sm \u003d System.getSecurityManager();\n        ClassLoader loader \u003d getBuiltinPlatformClassLoader();\n        if (sm !\u003d null) {\n            checkClassLoaderPermission(loader, Reflection.getCallerClass());\n        }\n        return loader;\n    }\n\n    /**\n     * Returns the system class loader.  This is the default\n     * delegation parent for new {@code ClassLoader} instances, and is\n     * typically the class loader used to start the application.\n     *\n     * \u003cp\u003e This method is first invoked early in the runtime\u0027s startup\n     * sequence, at which point it creates the system class loader. This\n     * class loader will be the context class loader for the main application\n     * thread (for example, the thread that invokes the {@code main} method of\n     * the main class).\n     *\n     * \u003cp\u003e The default system class loader is an implementation-dependent\n     * instance of this class.\n     *\n     * \u003cp\u003e If the system property \"{@code java.system.class.loader}\" is defined\n     * when this method is first invoked then the value of that property is\n     * taken to be the name of a class that will be returned as the system\n     * class loader.  The class is loaded using the default system class loader\n     * and must define a public constructor that takes a single parameter of\n     * type {@code ClassLoader} which is used as the delegation parent.  An\n     * instance is then created using this constructor with the default system\n     * class loader as the parameter.  The resulting class loader is defined\n     * to be the system class loader. During construction, the class loader\n     * should take great care to avoid calling {@code getSystemClassLoader()}.\n     * If circular initialization of the system class loader is detected then\n     * an {@code IllegalStateException} is thrown.\n     *\n     * @implNote The system property to override the system class loader is not\n     * examined until the VM is almost fully initialized. Code that executes\n     * this method during startup should take care not to cache the return\n     * value until the system is fully initialized.\n     *\n     * \u003cp\u003e The name of the built-in system class loader is {@code \"app\"}.\n     * The system property \"{@code java.class.path}\" is read during early\n     * initialization of the VM to determine the class path.\n     * An empty value of \"{@code java.class.path}\" property is interpreted\n     * differently depending on whether the initial module (the module\n     * containing the main class) is named or unnamed:\n     * If named, the built-in system class loader will have no class path and\n     * will search for classes and resources using the application module path;\n     * otherwise, if unnamed, it will set the class path to the current\n     * working directory.\n     *\n     * @return  The system {@code ClassLoader}\n     *\n     * @throws  SecurityException\n     *          If a security manager is present, and the caller\u0027s class loader\n     *          is not {@code null} and is not the same as or an ancestor of the\n     *          system class loader, and the caller does not have the\n     *          {@link RuntimePermission}{@code (\"getClassLoader\")}\n     *\n     * @throws  IllegalStateException\n     *          If invoked recursively during the construction of the class\n     *          loader specified by the \"{@code java.system.class.loader}\"\n     *          property.\n     *\n     * @throws  Error\n     *          If the system property \"{@code java.system.class.loader}\"\n     *          is defined but the named class could not be loaded, the\n     *          provider class does not define the required constructor, or an\n     *          exception is thrown by that constructor when it is invoked. The\n     *          underlying cause of the error can be retrieved via the\n     *          {@link Throwable#getCause()} method.\n     *\n     * @revised  1.4\n     * @revised 9\n     * @spec JPMS\n     */\n    @CallerSensitive\n    public static ClassLoader getSystemClassLoader() {\n        switch (VM.initLevel()) {\n            case 0:\n            case 1:\n            case 2:\n                // the system class loader is the built-in app class loader during startup\n                return getBuiltinAppClassLoader();\n            case 3:\n                String msg \u003d \"getSystemClassLoader cannot be called during the system class loader instantiation\";\n                throw new IllegalStateException(msg);\n            default:\n                // system fully initialized\n                assert VM.isBooted() \u0026\u0026 scl !\u003d null;\n                SecurityManager sm \u003d System.getSecurityManager();\n                if (sm !\u003d null) {\n                    checkClassLoaderPermission(scl, Reflection.getCallerClass());\n                }\n                return scl;\n        }\n    }\n\n    static ClassLoader getBuiltinPlatformClassLoader() {\n        return ClassLoaders.platformClassLoader();\n    }\n\n    static ClassLoader getBuiltinAppClassLoader() {\n        return ClassLoaders.appClassLoader();\n    }\n\n    /*\n     * Initialize the system class loader that may be a custom class on the\n     * application class path or application module path.\n     *\n     * @see java.lang.System#initPhase3\n     */\n    static synchronized ClassLoader initSystemClassLoader() {\n        if (VM.initLevel() !\u003d 3) {\n            throw new InternalError(\"system class loader cannot be set at initLevel \" +\n                                    VM.initLevel());\n        }\n\n        // detect recursive initialization\n        if (scl !\u003d null) {\n            throw new IllegalStateException(\"recursive invocation\");\n        }\n\n        ClassLoader builtinLoader \u003d getBuiltinAppClassLoader();\n\n        // All are privileged frames.  No need to call doPrivileged.\n        String cn \u003d System.getProperty(\"java.system.class.loader\");\n        if (cn !\u003d null) {\n            try {\n                // custom class loader is only supported to be loaded from unnamed module\n                Constructor\u003c?\u003e ctor \u003d Class.forName(cn, false, builtinLoader)\n                                           .getDeclaredConstructor(ClassLoader.class);\n                scl \u003d (ClassLoader) ctor.newInstance(builtinLoader);\n            } catch (Exception e) {\n                Throwable cause \u003d e;\n                if (e instanceof InvocationTargetException) {\n                    cause \u003d e.getCause();\n                    if (cause instanceof Error) {\n                        throw (Error) cause;\n                    }\n                }\n                if (cause instanceof RuntimeException) {\n                    throw (RuntimeException) cause;\n                }\n                throw new Error(cause.getMessage(), cause);\n            }\n        } else {\n            scl \u003d builtinLoader;\n        }\n        return scl;\n    }\n\n    /*\n     * Initialize default paths for native libraries search.\n     * Must be done early as JDK may load libraries during bootstrap.\n     *\n     * @see java.lang.System#initPhase1\n     */\n    static void initLibraryPaths() {\n        usr_paths \u003d initializePath(\"java.library.path\");\n        sys_paths \u003d initializePath(\"sun.boot.library.path\");\n    }\n\n    // Returns true if the specified class loader can be found in this class\n    // loader\u0027s delegation chain.\n    boolean isAncestor(ClassLoader cl) {\n        ClassLoader acl \u003d this;\n        do {\n            acl \u003d acl.parent;\n            if (cl \u003d\u003d acl) {\n                return true;\n            }\n        } while (acl !\u003d null);\n        return false;\n    }\n\n    // Tests if class loader access requires \"getClassLoader\" permission\n    // check.  A class loader \u0027from\u0027 can access class loader \u0027to\u0027 if\n    // class loader \u0027from\u0027 is same as class loader \u0027to\u0027 or an ancestor\n    // of \u0027to\u0027.  The class loader in a system domain can access\n    // any class loader.\n    private static boolean needsClassLoaderPermissionCheck(ClassLoader from,\n                                                           ClassLoader to)\n    {\n        if (from \u003d\u003d to)\n            return false;\n\n        if (from \u003d\u003d null)\n            return false;\n\n        return !to.isAncestor(from);\n    }\n\n    // Returns the class\u0027s class loader, or null if none.\n    static ClassLoader getClassLoader(Class\u003c?\u003e caller) {\n        // This can be null if the VM is requesting it\n        if (caller \u003d\u003d null) {\n            return null;\n        }\n        // Circumvent security check since this is package-private\n        return caller.getClassLoader0();\n    }\n\n    /*\n     * Checks RuntimePermission(\"getClassLoader\") permission\n     * if caller\u0027s class loader is not null and caller\u0027s class loader\n     * is not the same as or an ancestor of the given cl argument.\n     */\n    static void checkClassLoaderPermission(ClassLoader cl, Class\u003c?\u003e caller) {\n        SecurityManager sm \u003d System.getSecurityManager();\n        if (sm !\u003d null) {\n            // caller can be null if the VM is requesting it\n            ClassLoader ccl \u003d getClassLoader(caller);\n            if (needsClassLoaderPermissionCheck(ccl, cl)) {\n                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n            }\n        }\n    }\n\n    // The system class loader\n    // @GuardedBy(\"ClassLoader.class\")\n    private static volatile ClassLoader scl;\n\n    // -- Package --\n\n    /**\n     * Define a Package of the given Class object.\n     *\n     * If the given class represents an array type, a primitive type or void,\n     * this method returns {@code null}.\n     *\n     * This method does not throw IllegalArgumentException.\n     */\n    Package definePackage(Class\u003c?\u003e c) {\n        if (c.isPrimitive() || c.isArray()) {\n            return null;\n        }\n\n        return definePackage(c.getPackageName(), c.getModule());\n    }\n\n    /**\n     * Defines a Package of the given name and module\n     *\n     * This method does not throw IllegalArgumentException.\n     *\n     * @param name package name\n     * @param m    module\n     */\n    Package definePackage(String name, Module m) {\n        if (name.isEmpty() \u0026\u0026 m.isNamed()) {\n            throw new InternalError(\"unnamed package in  \" + m);\n        }\n\n        // check if Package object is already defined\n        NamedPackage pkg \u003d packages.get(name);\n        if (pkg instanceof Package)\n            return (Package)pkg;\n\n        return (Package)packages.compute(name, (n, p) -\u003e toPackage(n, p, m));\n    }\n\n    /*\n     * Returns a Package object for the named package\n     */\n    private Package toPackage(String name, NamedPackage p, Module m) {\n        // define Package object if the named package is not yet defined\n        if (p \u003d\u003d null)\n            return NamedPackage.toPackage(name, m);\n\n        // otherwise, replace the NamedPackage object with Package object\n        if (p instanceof Package)\n            return (Package)p;\n\n        return NamedPackage.toPackage(p.packageName(), p.module());\n    }\n\n    /**\n     * Defines a package by \u003ca href\u003d\"#binary-name\"\u003ename\u003c/a\u003e in this {@code ClassLoader}.\n     * \u003cp\u003e\n     * \u003ca href\u003d\"#binary-name\"\u003ePackage names\u003c/a\u003e must be unique within a class loader and\n     * cannot be redefined or changed once created.\n     * \u003cp\u003e\n     * If a class loader wishes to define a package with specific properties,\n     * such as version information, then the class loader should call this\n     * {@code definePackage} method before calling {@code defineClass}.\n     * Otherwise, the\n     * {@link #defineClass(String, byte[], int, int, ProtectionDomain) defineClass}\n     * method will define a package in this class loader corresponding to the package\n     * of the newly defined class; the properties of this defined package are\n     * specified by {@link Package}.\n     *\n     * @apiNote\n     * A class loader that wishes to define a package for classes in a JAR\n     * typically uses the specification and implementation titles, versions, and\n     * vendors from the JAR\u0027s manifest. If the package is specified as\n     * {@linkplain java.util.jar.Attributes.Name#SEALED sealed} in the JAR\u0027s manifest,\n     * the {@code URL} of the JAR file is typically used as the {@code sealBase}.\n     * If classes of package {@code \u0027p\u0027} defined by this class loader\n     * are loaded from multiple JARs, the {@code Package} object may contain\n     * different information depending on the first class of package {@code \u0027p\u0027}\n     * defined and which JAR\u0027s manifest is read first to explicitly define\n     * package {@code \u0027p\u0027}.\n     *\n     * \u003cp\u003e It is strongly recommended that a class loader does not call this\n     * method to explicitly define packages in \u003cem\u003enamed modules\u003c/em\u003e; instead,\n     * the package will be automatically defined when a class is {@linkplain\n     * #defineClass(String, byte[], int, int, ProtectionDomain) being defined}.\n     * If it is desirable to define {@code Package} explicitly, it should ensure\n     * that all packages in a named module are defined with the properties\n     * specified by {@link Package}.  Otherwise, some {@code Package} objects\n     * in a named module may be for example sealed with different seal base.\n     *\n     * @param  name\n     *         The \u003ca href\u003d\"#binary-name\"\u003epackage name\u003c/a\u003e\n     *\n     * @param  specTitle\n     *         The specification title\n     *\n     * @param  specVersion\n     *         The specification version\n     *\n     * @param  specVendor\n     *         The specification vendor\n     *\n     * @param  implTitle\n     *         The implementation title\n     *\n     * @param  implVersion\n     *         The implementation version\n     *\n     * @param  implVendor\n     *         The implementation vendor\n     *\n     * @param  sealBase\n     *         If not {@code null}, then this package is sealed with\n     *         respect to the given code source {@link java.net.URL URL}\n     *         object.  Otherwise, the package is not sealed.\n     *\n     * @return  The newly defined {@code Package} object\n     *\n     * @throws  NullPointerException\n     *          if {@code name} is {@code null}.\n     *\n     * @throws  IllegalArgumentException\n     *          if a package of the given {@code name} is already\n     *          defined by this class loader\n     *\n     *\n     * @since  1.2\n     * @revised 9\n     * @spec JPMS\n     *\n     * @jvms 5.3 Run-time package\n     * @see \u003ca href\u003d\"{@docRoot}/../specs/jar/jar.html#package-sealing\"\u003e\n     *      The JAR File Specification: Package Sealing\u003c/a\u003e\n     */\n    protected Package definePackage(String name, String specTitle,\n                                    String specVersion, String specVendor,\n                                    String implTitle, String implVersion,\n                                    String implVendor, URL sealBase)\n    {\n        Objects.requireNonNull(name);\n\n        // definePackage is not final and may be overridden by custom class loader\n        Package p \u003d new Package(name, specTitle, specVersion, specVendor,\n                                implTitle, implVersion, implVendor,\n                                sealBase, this);\n\n        if (packages.putIfAbsent(name, p) !\u003d null)\n            throw new IllegalArgumentException(name);\n\n        return p;\n    }\n\n    /**\n     * Returns a {@code Package} of the given \u003ca href\u003d\"#binary-name\"\u003ename\u003c/a\u003e that\n     * has been defined by this class loader.\n     *\n     * @param  name The \u003ca href\u003d\"#binary-name\"\u003epackage name\u003c/a\u003e\n     *\n     * @return The {@code Package} of the given name that has been defined\n     *         by this class loader, or {@code null} if not found\n     *\n     * @throws  NullPointerException\n     *          if {@code name} is {@code null}.\n     *\n     * @jvms 5.3 Run-time package\n     *\n     * @since  9\n     * @spec JPMS\n     */\n    public final Package getDefinedPackage(String name) {\n        Objects.requireNonNull(name, \"name cannot be null\");\n\n        NamedPackage p \u003d packages.get(name);\n        if (p \u003d\u003d null)\n            return null;\n\n        return definePackage(name, p.module());\n    }\n\n    /**\n     * Returns all of the {@code Package}s that have been defined by\n     * this class loader.  The returned array has no duplicated {@code Package}s\n     * of the same name.\n     *\n     * @apiNote This method returns an array rather than a {@code Set} or {@code Stream}\n     *          for consistency with the existing {@link #getPackages} method.\n     *\n     * @return The array of {@code Package} objects that have been defined by\n     *         this class loader; or an zero length array if no package has been\n     *         defined by this class loader.\n     *\n     * @jvms 5.3 Run-time package\n     *\n     * @since  9\n     * @spec JPMS\n     */\n    public final Package[] getDefinedPackages() {\n        return packages().toArray(Package[]::new);\n    }\n\n    /**\n     * Finds a package by \u003ca href\u003d\"#binary-name\"\u003ename\u003c/a\u003e in this class loader and its ancestors.\n     * \u003cp\u003e\n     * If this class loader defines a {@code Package} of the given name,\n     * the {@code Package} is returned. Otherwise, the ancestors of\n     * this class loader are searched recursively (parent by parent)\n     * for a {@code Package} of the given name.\n     *\n     * @apiNote The {@link #getPlatformClassLoader() platform class loader}\n     * may delegate to the application class loader but the application class\n     * loader is not its ancestor.  When invoked on the platform class loader,\n     * this method  will not find packages defined to the application\n     * class loader.\n     *\n     * @param  name\n     *         The \u003ca href\u003d\"#binary-name\"\u003epackage name\u003c/a\u003e\n     *\n     * @return The {@code Package} of the given name that has been defined by\n     *         this class loader or its ancestors, or {@code null} if not found.\n     *\n     * @throws  NullPointerException\n     *          if {@code name} is {@code null}.\n     *\n     * @deprecated\n     * If multiple class loaders delegate to each other and define classes\n     * with the same package name, and one such loader relies on the lookup\n     * behavior of {@code getPackage} to return a {@code Package} from\n     * a parent loader, then the properties exposed by the {@code Package}\n     * may not be as expected in the rest of the program.\n     * For example, the {@code Package} will only expose annotations from the\n     * {@code package-info.class} file defined by the parent loader, even if\n     * annotations exist in a {@code package-info.class} file defined by\n     * a child loader.  A more robust approach is to use the\n     * {@link ClassLoader#getDefinedPackage} method which returns\n     * a {@code Package} for the specified class loader.\n     *\n     * @see ClassLoader#getDefinedPackage(String)\n     *\n     * @since  1.2\n     * @revised 9\n     * @spec JPMS\n     */\n    @Deprecated(since\u003d\"9\")\n    protected Package getPackage(String name) {\n        Package pkg \u003d getDefinedPackage(name);\n        if (pkg \u003d\u003d null) {\n            if (parent !\u003d null) {\n                pkg \u003d parent.getPackage(name);\n            } else {\n                pkg \u003d BootLoader.getDefinedPackage(name);\n            }\n        }\n        return pkg;\n    }\n\n    /**\n     * Returns all of the {@code Package}s that have been defined by\n     * this class loader and its ancestors.  The returned array may contain\n     * more than one {@code Package} object of the same package name, each\n     * defined by a different class loader in the class loader hierarchy.\n     *\n     * @apiNote The {@link #getPlatformClassLoader() platform class loader}\n     * may delegate to the application class loader. In other words,\n     * packages in modules defined to the application class loader may be\n     * visible to the platform class loader.  On the other hand,\n     * the application class loader is not its ancestor and hence\n     * when invoked on the platform class loader, this method will not\n     * return any packages defined to the application class loader.\n     *\n     * @return  The array of {@code Package} objects that have been defined by\n     *          this class loader and its ancestors\n     *\n     * @see ClassLoader#getDefinedPackages()\n     *\n     * @since  1.2\n     * @revised 9\n     * @spec JPMS\n     */\n    protected Package[] getPackages() {\n        Stream\u003cPackage\u003e pkgs \u003d packages();\n        ClassLoader ld \u003d parent;\n        while (ld !\u003d null) {\n            pkgs \u003d Stream.concat(ld.packages(), pkgs);\n            ld \u003d ld.parent;\n        }\n        return Stream.concat(BootLoader.packages(), pkgs)\n                     .toArray(Package[]::new);\n    }\n\n\n\n    // package-private\n\n    /**\n     * Returns a stream of Packages defined in this class loader\n     */\n    Stream\u003cPackage\u003e packages() {\n        return packages.values().stream()\n                       .map(p -\u003e definePackage(p.packageName(), p.module()));\n    }\n\n    // -- Native library access --\n\n    /**\n     * Returns the absolute path name of a native library.  The VM invokes this\n     * method to locate the native libraries that belong to classes loaded with\n     * this class loader. If this method returns {@code null}, the VM\n     * searches the library along the path specified as the\n     * \"{@code java.library.path}\" property.\n     *\n     * @param  libname\n     *         The library name\n     *\n     * @return  The absolute path of the native library\n     *\n     * @see  System#loadLibrary(String)\n     * @see  System#mapLibraryName(String)\n     *\n     * @since  1.2\n     */\n    protected String findLibrary(String libname) {\n        return null;\n    }\n\n    /**\n     * The inner class NativeLibrary denotes a loaded native library instance.\n     * Every classloader contains a vector of loaded native libraries in the\n     * private field {@code nativeLibraries}.  The native libraries loaded\n     * into the system are entered into the {@code systemNativeLibraries}\n     * vector.\n     *\n     * \u003cp\u003e Every native library requires a particular version of JNI. This is\n     * denoted by the private {@code jniVersion} field.  This field is set by\n     * the VM when it loads the library, and used by the VM to pass the correct\n     * version of JNI to the native methods.  \u003c/p\u003e\n     *\n     * @see      ClassLoader\n     * @since    1.2\n     */\n    static class NativeLibrary {\n        private static final boolean loadLibraryOnlyIfPresent \u003d ClassLoaderHelper.loadLibraryOnlyIfPresent();\n\n        // the class from which the library is loaded, also indicates\n        // the loader this native library belongs.\n        final Class\u003c?\u003e fromClass;\n        // the canonicalized name of the native library.\n        // or static library name\n        final String name;\n        // Indicates if the native library is linked into the VM\n        final boolean isBuiltin;\n\n        // opaque handle to native library, used in native code.\n        long handle;\n        // the version of JNI environment the native library requires.\n        int jniVersion;\n\n        native boolean load0(String name, boolean isBuiltin,\n                             boolean throwExceptionIfFail);\n\n        native long findEntry(String name);\n\n        NativeLibrary(Class\u003c?\u003e fromClass, String name, boolean isBuiltin) {\n            this.name \u003d name;\n            this.fromClass \u003d fromClass;\n            this.isBuiltin \u003d isBuiltin;\n        }\n\n        /*\n         * Loads the native library and registers for cleanup when its\n         * associated class loader is unloaded\n         */\n        boolean load() {\n            if (handle !\u003d 0) {\n                throw new InternalError(\"Native library \" + name + \" has been loaded\");\n            }\n\n            if (!load0(name, isBuiltin, loadLibraryOnlyIfPresent)) return false;\n\n            // register the class loader for cleanup when unloaded\n            // built class loaders are never unloaded\n            ClassLoader loader \u003d fromClass.getClassLoader();\n            if (loader !\u003d null \u0026\u0026\n                loader !\u003d getBuiltinPlatformClassLoader() \u0026\u0026\n                loader !\u003d getBuiltinAppClassLoader()) {\n                CleanerFactory.cleaner().register(loader,\n                        new Unloader(name, handle, isBuiltin));\n            }\n            return true;\n        }\n\n        static boolean loadLibrary(Class\u003c?\u003e fromClass, String name, boolean isBuiltin) {\n            ClassLoader loader \u003d\n                fromClass \u003d\u003d null ? null : fromClass.getClassLoader();\n\n            synchronized (loadedLibraryNames) {\n                Map\u003cString, NativeLibrary\u003e libs \u003d\n                    loader !\u003d null ? loader.nativeLibraries() : systemNativeLibraries();\n                if (libs.containsKey(name)) {\n                    return true;\n                }\n\n                if (loadedLibraryNames.contains(name)) {\n                    throw new UnsatisfiedLinkError(\"Native Library \" + name +\n                        \" already loaded in another classloader\");\n                }\n\n                /*\n                 * When a library is being loaded, JNI_OnLoad function can cause\n                 * another loadLibrary invocation that should succeed.\n                 *\n                 * We use a static stack to hold the list of libraries we are\n                 * loading because this can happen only when called by the\n                 * same thread because this block is synchronous.\n                 *\n                 * If there is a pending load operation for the library, we\n                 * immediately return success; otherwise, we raise\n                 * UnsatisfiedLinkError.\n                 */\n                for (NativeLibrary lib : nativeLibraryContext) {\n                    if (name.equals(lib.name)) {\n                        if (loader \u003d\u003d lib.fromClass.getClassLoader()) {\n                            return true;\n                        } else {\n                            throw new UnsatisfiedLinkError(\"Native Library \" +\n                                name + \" is being loaded in another classloader\");\n                        }\n                    }\n                }\n                NativeLibrary lib \u003d new NativeLibrary(fromClass, name, isBuiltin);\n                // load the native library\n                nativeLibraryContext.push(lib);\n                try {\n                    if (!lib.load()) return false;\n                } finally {\n                    nativeLibraryContext.pop();\n                }\n                // register the loaded native library\n                loadedLibraryNames.add(name);\n                libs.put(name, lib);\n            }\n            return true;\n        }\n\n        // Invoked in the VM to determine the context class in JNI_OnLoad\n        // and JNI_OnUnload\n        static Class\u003c?\u003e getFromClass() {\n            return nativeLibraryContext.peek().fromClass;\n        }\n\n        // native libraries being loaded\n        static Deque\u003cNativeLibrary\u003e nativeLibraryContext \u003d new ArrayDeque\u003c\u003e(8);\n\n        /*\n         * The run() method will be invoked when this class loader becomes\n         * phantom reachable to unload the native library.\n         */\n        static class Unloader implements Runnable {\n            // This represents the context when a native library is unloaded\n            // and getFromClass() will return null,\n            static final NativeLibrary UNLOADER \u003d\n                new NativeLibrary(null, \"dummy\", false);\n            final String name;\n            final long handle;\n            final boolean isBuiltin;\n\n            Unloader(String name, long handle, boolean isBuiltin) {\n                if (handle \u003d\u003d 0) {\n                    throw new IllegalArgumentException(\n                        \"Invalid handle for native library \" + name);\n                }\n\n                this.name \u003d name;\n                this.handle \u003d handle;\n                this.isBuiltin \u003d isBuiltin;\n            }\n\n            @Override\n            public void run() {\n                synchronized (loadedLibraryNames) {\n                    /* remove the native library name */\n                    loadedLibraryNames.remove(name);\n                    nativeLibraryContext.push(UNLOADER);\n                    try {\n                        unload(name, isBuiltin, handle);\n                    } finally {\n                        nativeLibraryContext.pop();\n                    }\n\n                }\n            }\n        }\n\n        // JNI FindClass expects the caller class if invoked from JNI_OnLoad\n        // and JNI_OnUnload is NativeLibrary class\n        static native void unload(String name, boolean isBuiltin, long handle);\n    }\n\n    // The paths searched for libraries\n    private static String usr_paths[];\n    private static String sys_paths[];\n\n    private static String[] initializePath(String propName) {\n        String ldPath \u003d System.getProperty(propName, \"\");\n        int ldLen \u003d ldPath.length();\n        char ps \u003d File.pathSeparatorChar;\n        int psCount \u003d 0;\n\n        if (ClassLoaderHelper.allowsQuotedPathElements \u0026\u0026\n            ldPath.indexOf(\u0027\\\"\u0027) \u003e\u003d 0) {\n            // First, remove quotes put around quoted parts of paths.\n            // Second, use a quotation mark as a new path separator.\n            // This will preserve any quoted old path separators.\n            char[] buf \u003d new char[ldLen];\n            int bufLen \u003d 0;\n            for (int i \u003d 0; i \u003c ldLen; ++i) {\n                char ch \u003d ldPath.charAt(i);\n                if (ch \u003d\u003d \u0027\\\"\u0027) {\n                    while (++i \u003c ldLen \u0026\u0026\n                        (ch \u003d ldPath.charAt(i)) !\u003d \u0027\\\"\u0027) {\n                        buf[bufLen++] \u003d ch;\n                    }\n                } else {\n                    if (ch \u003d\u003d ps) {\n                        psCount++;\n                        ch \u003d \u0027\\\"\u0027;\n                    }\n                    buf[bufLen++] \u003d ch;\n                }\n            }\n            ldPath \u003d new String(buf, 0, bufLen);\n            ldLen \u003d bufLen;\n            ps \u003d \u0027\\\"\u0027;\n        } else {\n            for (int i \u003d ldPath.indexOf(ps); i \u003e\u003d 0;\n                 i \u003d ldPath.indexOf(ps, i + 1)) {\n                psCount++;\n            }\n        }\n\n        String[] paths \u003d new String[psCount + 1];\n        int pathStart \u003d 0;\n        for (int j \u003d 0; j \u003c psCount; ++j) {\n            int pathEnd \u003d ldPath.indexOf(ps, pathStart);\n            paths[j] \u003d (pathStart \u003c pathEnd) ?\n                ldPath.substring(pathStart, pathEnd) : \".\";\n            pathStart \u003d pathEnd + 1;\n        }\n        paths[psCount] \u003d (pathStart \u003c ldLen) ?\n            ldPath.substring(pathStart, ldLen) : \".\";\n        return paths;\n    }\n\n    // Invoked in the java.lang.Runtime class to implement load and loadLibrary.\n    static void loadLibrary(Class\u003c?\u003e fromClass, String name,\n                            boolean isAbsolute) {\n        ClassLoader loader \u003d\n            (fromClass \u003d\u003d null) ? null : fromClass.getClassLoader();\n        assert sys_paths !\u003d null : \"should be initialized at this point\";\n        assert usr_paths !\u003d null : \"should be initialized at this point\";\n\n        if (isAbsolute) {\n            if (loadLibrary0(fromClass, new File(name))) {\n                return;\n            }\n            throw new UnsatisfiedLinkError(\"Can\u0027t load library: \" + name);\n        }\n        if (loader !\u003d null) {\n            String libfilename \u003d loader.findLibrary(name);\n            if (libfilename !\u003d null) {\n                File libfile \u003d new File(libfilename);\n                if (!libfile.isAbsolute()) {\n                    throw new UnsatisfiedLinkError(\n                        \"ClassLoader.findLibrary failed to return an absolute path: \" + libfilename);\n                }\n                if (loadLibrary0(fromClass, libfile)) {\n                    return;\n                }\n                throw new UnsatisfiedLinkError(\"Can\u0027t load \" + libfilename);\n            }\n        }\n        for (String sys_path : sys_paths) {\n            File libfile \u003d new File(sys_path, System.mapLibraryName(name));\n            if (loadLibrary0(fromClass, libfile)) {\n                return;\n            }\n            libfile \u003d ClassLoaderHelper.mapAlternativeName(libfile);\n            if (libfile !\u003d null \u0026\u0026 loadLibrary0(fromClass, libfile)) {\n                return;\n            }\n        }\n        if (loader !\u003d null) {\n            for (String usr_path : usr_paths) {\n                File libfile \u003d new File(usr_path, System.mapLibraryName(name));\n                if (loadLibrary0(fromClass, libfile)) {\n                    return;\n                }\n                libfile \u003d ClassLoaderHelper.mapAlternativeName(libfile);\n                if (libfile !\u003d null \u0026\u0026 loadLibrary0(fromClass, libfile)) {\n                    return;\n                }\n            }\n        }\n        // Oops, it failed\n        throw new UnsatisfiedLinkError(\"no \" + name +\n            \" in java.library.path: \" + Arrays.toString(usr_paths));\n    }\n\n    private static native String findBuiltinLib(String name);\n\n    private static boolean loadLibrary0(Class\u003c?\u003e fromClass, final File file) {\n        // Check to see if we\u0027re attempting to access a static library\n        String name \u003d findBuiltinLib(file.getName());\n        boolean isBuiltin \u003d (name !\u003d null);\n        if (!isBuiltin) {\n            name \u003d AccessController.doPrivileged(\n                new PrivilegedAction\u003c\u003e() {\n                    public String run() {\n                        try {\n                            if (NativeLibrary.loadLibraryOnlyIfPresent \u0026\u0026 !file.exists()) {\n                                return null;\n                            }\n                            return file.getCanonicalPath();\n                        } catch (IOException e) {\n                            return null;\n                        }\n                    }\n                });\n            if (name \u003d\u003d null) {\n                return false;\n            }\n        }\n        return NativeLibrary.loadLibrary(fromClass, name, isBuiltin);\n    }\n\n    /*\n     * Invoked in the VM class linking code.\n     */\n    private static long findNative(ClassLoader loader, String entryName) {\n        Map\u003cString, NativeLibrary\u003e libs \u003d\n            loader !\u003d null ? loader.nativeLibraries() : systemNativeLibraries();\n        if (libs.isEmpty())\n            return 0;\n\n        // the native libraries map may be updated in another thread\n        // when a native library is being loaded.  No symbol will be\n        // searched from it yet.\n        for (NativeLibrary lib : libs.values()) {\n            long entry \u003d lib.findEntry(entryName);\n            if (entry !\u003d 0) return entry;\n        }\n        return 0;\n    }\n\n    // All native library names we\u0027ve loaded.\n    // This also serves as the lock to obtain nativeLibraries\n    // and write to nativeLibraryContext.\n    private static final Set\u003cString\u003e loadedLibraryNames \u003d new HashSet\u003c\u003e();\n\n    // Native libraries belonging to system classes.\n    private static volatile Map\u003cString, NativeLibrary\u003e systemNativeLibraries;\n\n    // Native libraries associated with the class loader.\n    private volatile Map\u003cString, NativeLibrary\u003e nativeLibraries;\n\n    /*\n     * Returns the native libraries map associated with bootstrap class loader\n     * This method will create the map at the first time when called.\n     */\n    private static Map\u003cString, NativeLibrary\u003e systemNativeLibraries() {\n        Map\u003cString, NativeLibrary\u003e libs \u003d systemNativeLibraries;\n        if (libs \u003d\u003d null) {\n            synchronized (loadedLibraryNames) {\n                libs \u003d systemNativeLibraries;\n                if (libs \u003d\u003d null) {\n                    libs \u003d systemNativeLibraries \u003d new ConcurrentHashMap\u003c\u003e();\n                }\n            }\n        }\n        return libs;\n    }\n\n    /*\n     * Returns the native libraries map associated with this class loader\n     * This method will create the map at the first time when called.\n     */\n    private Map\u003cString, NativeLibrary\u003e nativeLibraries() {\n        Map\u003cString, NativeLibrary\u003e libs \u003d nativeLibraries;\n        if (libs \u003d\u003d null) {\n            synchronized (loadedLibraryNames) {\n                libs \u003d nativeLibraries;\n                if (libs \u003d\u003d null) {\n                    libs \u003d nativeLibraries \u003d new ConcurrentHashMap\u003c\u003e();\n                }\n            }\n        }\n        return libs;\n    }\n\n    // -- Assertion management --\n\n    final Object assertionLock;\n\n    // The default toggle for assertion checking.\n    // @GuardedBy(\"assertionLock\")\n    private boolean defaultAssertionStatus \u003d false;\n\n    // Maps String packageName to Boolean package default assertion status Note\n    // that the default package is placed under a null map key.  If this field\n    // is null then we are delegating assertion status queries to the VM, i.e.,\n    // none of this ClassLoader\u0027s assertion status modification methods have\n    // been invoked.\n    // @GuardedBy(\"assertionLock\")\n    private Map\u003cString, Boolean\u003e packageAssertionStatus \u003d null;\n\n    // Maps String fullyQualifiedClassName to Boolean assertionStatus If this\n    // field is null then we are delegating assertion status queries to the VM,\n    // i.e., none of this ClassLoader\u0027s assertion status modification methods\n    // have been invoked.\n    // @GuardedBy(\"assertionLock\")\n    Map\u003cString, Boolean\u003e classAssertionStatus \u003d null;\n\n    /**\n     * Sets the default assertion status for this class loader.  This setting\n     * determines whether classes loaded by this class loader and initialized\n     * in the future will have assertions enabled or disabled by default.\n     * This setting may be overridden on a per-package or per-class basis by\n     * invoking {@link #setPackageAssertionStatus(String, boolean)} or {@link\n     * #setClassAssertionStatus(String, boolean)}.\n     *\n     * @param  enabled\n     *         {@code true} if classes loaded by this class loader will\n     *         henceforth have assertions enabled by default, {@code false}\n     *         if they will have assertions disabled by default.\n     *\n     * @since  1.4\n     */\n    public void setDefaultAssertionStatus(boolean enabled) {\n        synchronized (assertionLock) {\n            if (classAssertionStatus \u003d\u003d null)\n                initializeJavaAssertionMaps();\n\n            defaultAssertionStatus \u003d enabled;\n        }\n    }\n\n    /**\n     * Sets the package default assertion status for the named package.  The\n     * package default assertion status determines the assertion status for\n     * classes initialized in the future that belong to the named package or\n     * any of its \"subpackages\".\n     *\n     * \u003cp\u003e A subpackage of a package named p is any package whose name begins\n     * with \"{@code p.}\".  For example, {@code javax.swing.text} is a\n     * subpackage of {@code javax.swing}, and both {@code java.util} and\n     * {@code java.lang.reflect} are subpackages of {@code java}.\n     *\n     * \u003cp\u003e In the event that multiple package defaults apply to a given class,\n     * the package default pertaining to the most specific package takes\n     * precedence over the others.  For example, if {@code javax.lang} and\n     * {@code javax.lang.reflect} both have package defaults associated with\n     * them, the latter package default applies to classes in\n     * {@code javax.lang.reflect}.\n     *\n     * \u003cp\u003e Package defaults take precedence over the class loader\u0027s default\n     * assertion status, and may be overridden on a per-class basis by invoking\n     * {@link #setClassAssertionStatus(String, boolean)}.  \u003c/p\u003e\n     *\n     * @param  packageName\n     *         The name of the package whose package default assertion status\n     *         is to be set. A {@code null} value indicates the unnamed\n     *         package that is \"current\"\n     *         (see section 7.4.2 of\n     *         \u003ccite\u003eThe Java\u0026trade; Language Specification\u003c/cite\u003e.)\n     *\n     * @param  enabled\n     *         {@code true} if classes loaded by this classloader and\n     *         belonging to the named package or any of its subpackages will\n     *         have assertions enabled by default, {@code false} if they will\n     *         have assertions disabled by default.\n     *\n     * @since  1.4\n     */\n    public void setPackageAssertionStatus(String packageName,\n                                          boolean enabled) {\n        synchronized (assertionLock) {\n            if (packageAssertionStatus \u003d\u003d null)\n                initializeJavaAssertionMaps();\n\n            packageAssertionStatus.put(packageName, enabled);\n        }\n    }\n\n    /**\n     * Sets the desired assertion status for the named top-level class in this\n     * class loader and any nested classes contained therein.  This setting\n     * takes precedence over the class loader\u0027s default assertion status, and\n     * over any applicable per-package default.  This method has no effect if\n     * the named class has already been initialized.  (Once a class is\n     * initialized, its assertion status cannot change.)\n     *\n     * \u003cp\u003e If the named class is not a top-level class, this invocation will\n     * have no effect on the actual assertion status of any class. \u003c/p\u003e\n     *\n     * @param  className\n     *         The fully qualified class name of the top-level class whose\n     *         assertion status is to be set.\n     *\n     * @param  enabled\n     *         {@code true} if the named class is to have assertions\n     *         enabled when (and if) it is initialized, {@code false} if the\n     *         class is to have assertions disabled.\n     *\n     * @since  1.4\n     */\n    public void setClassAssertionStatus(String className, boolean enabled) {\n        synchronized (assertionLock) {\n            if (classAssertionStatus \u003d\u003d null)\n                initializeJavaAssertionMaps();\n\n            classAssertionStatus.put(className, enabled);\n        }\n    }\n\n    /**\n     * Sets the default assertion status for this class loader to\n     * {@code false} and discards any package defaults or class assertion\n     * status settings associated with the class loader.  This method is\n     * provided so that class loaders can be made to ignore any command line or\n     * persistent assertion status settings and \"start with a clean slate.\"\n     *\n     * @since  1.4\n     */\n    public void clearAssertionStatus() {\n        /*\n         * Whether or not \"Java assertion maps\" are initialized, set\n         * them to empty maps, effectively ignoring any present settings.\n         */\n        synchronized (assertionLock) {\n            classAssertionStatus \u003d new HashMap\u003c\u003e();\n            packageAssertionStatus \u003d new HashMap\u003c\u003e();\n            defaultAssertionStatus \u003d false;\n        }\n    }\n\n    /**\n     * Returns the assertion status that would be assigned to the specified\n     * class if it were to be initialized at the time this method is invoked.\n     * If the named class has had its assertion status set, the most recent\n     * setting will be returned; otherwise, if any package default assertion\n     * status pertains to this class, the most recent setting for the most\n     * specific pertinent package default assertion status is returned;\n     * otherwise, this class loader\u0027s default assertion status is returned.\n     * \u003c/p\u003e\n     *\n     * @param  className\n     *         The fully qualified class name of the class whose desired\n     *         assertion status is being queried.\n     *\n     * @return  The desired assertion status of the specified class.\n     *\n     * @see  #setClassAssertionStatus(String, boolean)\n     * @see  #setPackageAssertionStatus(String, boolean)\n     * @see  #setDefaultAssertionStatus(boolean)\n     *\n     * @since  1.4\n     */\n    boolean desiredAssertionStatus(String className) {\n        synchronized (assertionLock) {\n            // assert classAssertionStatus   !\u003d null;\n            // assert packageAssertionStatus !\u003d null;\n\n            // Check for a class entry\n            Boolean result \u003d classAssertionStatus.get(className);\n            if (result !\u003d null)\n                return result.booleanValue();\n\n            // Check for most specific package entry\n            int dotIndex \u003d className.lastIndexOf(\u0027.\u0027);\n            if (dotIndex \u003c 0) { // default package\n                result \u003d packageAssertionStatus.get(null);\n                if (result !\u003d null)\n                    return result.booleanValue();\n            }\n            while(dotIndex \u003e 0) {\n                className \u003d className.substring(0, dotIndex);\n                result \u003d packageAssertionStatus.get(className);\n                if (result !\u003d null)\n                    return result.booleanValue();\n                dotIndex \u003d className.lastIndexOf(\u0027.\u0027, dotIndex-1);\n            }\n\n            // Return the classloader default\n            return defaultAssertionStatus;\n        }\n    }\n\n    // Set up the assertions with information provided by the VM.\n    // Note: Should only be called inside a synchronized block\n    private void initializeJavaAssertionMaps() {\n        // assert Thread.holdsLock(assertionLock);\n\n        classAssertionStatus \u003d new HashMap\u003c\u003e();\n        packageAssertionStatus \u003d new HashMap\u003c\u003e();\n        AssertionStatusDirectives directives \u003d retrieveDirectives();\n\n        for(int i \u003d 0; i \u003c directives.classes.length; i++)\n            classAssertionStatus.put(directives.classes[i],\n                                     directives.classEnabled[i]);\n\n        for(int i \u003d 0; i \u003c directives.packages.length; i++)\n            packageAssertionStatus.put(directives.packages[i],\n                                       directives.packageEnabled[i]);\n\n        defaultAssertionStatus \u003d directives.deflt;\n    }\n\n    // Retrieves the assertion directives from the VM.\n    private static native AssertionStatusDirectives retrieveDirectives();\n\n\n    // -- Misc --\n\n    /**\n     * Returns the ConcurrentHashMap used as a storage for ClassLoaderValue(s)\n     * associated with this ClassLoader, creating it if it doesn\u0027t already exist.\n     */\n    ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap() {\n        ConcurrentHashMap\u003c?, ?\u003e map \u003d classLoaderValueMap;\n        if (map \u003d\u003d null) {\n            map \u003d new ConcurrentHashMap\u003c\u003e();\n            boolean set \u003d trySetObjectField(\"classLoaderValueMap\", map);\n            if (!set) {\n                // beaten by someone else\n                map \u003d classLoaderValueMap;\n            }\n        }\n        return map;\n    }\n\n    // the storage for ClassLoaderValue(s) associated with this ClassLoader\n    private volatile ConcurrentHashMap\u003c?, ?\u003e classLoaderValueMap;\n\n    /**\n     * Attempts to atomically set a volatile field in this object. Returns\n     * {@code true} if not beaten by another thread. Avoids the use of\n     * AtomicReferenceFieldUpdater in this class.\n     */\n    private boolean trySetObjectField(String name, Object obj) {\n        Unsafe unsafe \u003d Unsafe.getUnsafe();\n        Class\u003c?\u003e k \u003d ClassLoader.class;\n        long offset;\n        offset \u003d unsafe.objectFieldOffset(k, name);\n        return unsafe.compareAndSetObject(this, offset, null, obj);\n    }\n}\n\n/*\n * A utility class that will enumerate over an array of enumerations.\n */\nfinal class CompoundEnumeration\u003cE\u003e implements Enumeration\u003cE\u003e {\n    private final Enumeration\u003cE\u003e[] enums;\n    private int index;\n\n    public CompoundEnumeration(Enumeration\u003cE\u003e[] enums) {\n        this.enums \u003d enums;\n    }\n\n    private boolean next() {\n        while (index \u003c enums.length) {\n            if (enums[index] !\u003d null \u0026\u0026 enums[index].hasMoreElements()) {\n                return true;\n            }\n            index++;\n        }\n        return false;\n    }\n\n    public boolean hasMoreElements() {\n        return next();\n    }\n\n    public E nextElement() {\n        if (!next()) {\n            throw new NoSuchElementException();\n        }\n        return enums[index].nextElement();\n    }\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 18, 2024 3:05:10 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/ClassLoader.java"
  ]
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor27.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.10.18 15:05:10 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/ClassLoader.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:545)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	jdk.internal.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:05:10 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/ClassLoader.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:443)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	jdk.internal.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:05:10 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/ClassLoader.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:10 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

2024.10.18 15:05:10 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/ClassLoader.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.codeLens(WorkspaceLspService.scala:530)
	scala.meta.metals.lsp.DelegatingScalaService.codeLens(DelegatingScalaService.scala:150)
	jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:11 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$3(MetalsLspService.scala:1225)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$2(MetalsLspService.scala:1224)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:05:10 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/ClassLoader.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.documentSymbol(WorkspaceLspService.scala:460)
	scala.meta.metals.lsp.DelegatingScalaService.documentSymbol(DelegatingScalaService.scala:91)
	jdk.internal.reflect.GeneratedMethodAccessor5.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:11 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$documentSymbol$1(MetalsLspService.scala:1055)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:05:10 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/ClassLoader.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:11 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

2024.10.18 15:05:12 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/ClassLoader.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:443)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	jdk.internal.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/lang/ClassLoader.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/lang/ClassLoader.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.18 15:05:12 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.LocalTime.SECONDS_PER_DAY;\nimport static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH;\nimport static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR;\nimport static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_MONTH;\nimport static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_YEAR;\nimport static java.time.temporal.ChronoField.DAY_OF_MONTH;\nimport static java.time.temporal.ChronoField.DAY_OF_YEAR;\nimport static java.time.temporal.ChronoField.EPOCH_DAY;\nimport static java.time.temporal.ChronoField.ERA;\nimport static java.time.temporal.ChronoField.MONTH_OF_YEAR;\nimport static java.time.temporal.ChronoField.PROLEPTIC_MONTH;\nimport static java.time.temporal.ChronoField.YEAR;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.ChronoLocalDate;\nimport java.time.chrono.IsoEra;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneOffsetTransition;\nimport java.time.zone.ZoneRules;\nimport java.util.Objects;\nimport java.util.stream.LongStream;\nimport java.util.stream.Stream;\n\n/**\n * A date without a time-zone in the ISO-8601 calendar system,\n * such as {@code 2007-12-03}.\n * \u003cp\u003e\n * {@code LocalDate} is an immutable date-time object that represents a date,\n * often viewed as year-month-day. Other date fields, such as day-of-year,\n * day-of-week and week-of-year, can also be accessed.\n * For example, the value \"2nd October 2007\" can be stored in a {@code LocalDate}.\n * \u003cp\u003e\n * This class does not store or represent a time or time-zone.\n * Instead, it is a description of the date, as used for birthdays.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n * \u003cp\u003e\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today\u0027s rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code LocalDate} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class LocalDate\n        implements Temporal, TemporalAdjuster, ChronoLocalDate, Serializable {\n\n    /**\n     * The minimum supported {@code LocalDate}, \u0027-999999999-01-01\u0027.\n     * This could be used by an application as a \"far past\" date.\n     */\n    public static final LocalDate MIN \u003d LocalDate.of(Year.MIN_VALUE, 1, 1);\n    /**\n     * The maximum supported {@code LocalDate}, \u0027+999999999-12-31\u0027.\n     * This could be used by an application as a \"far future\" date.\n     */\n    public static final LocalDate MAX \u003d LocalDate.of(Year.MAX_VALUE, 12, 31);\n    /**\n     * The epoch year {@code LocalDate}, \u00271970-01-01\u0027.\n     */\n    public static final LocalDate EPOCH \u003d LocalDate.of(1970, 1, 1);\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 2942565459149668126L;\n    /**\n     * The number of days in a 400 year cycle.\n     */\n    private static final int DAYS_PER_CYCLE \u003d 146097;\n    /**\n     * The number of days from year zero to year 1970.\n     * There are five 400 year cycles from year zero to 2000.\n     * There are 7 leap years from 1970 to 2000.\n     */\n    static final long DAYS_0000_TO_1970 \u003d (DAYS_PER_CYCLE * 5L) - (30L * 365L + 7L);\n\n    /**\n     * The year.\n     */\n    private final int year;\n    /**\n     * The month-of-year.\n     */\n    private final short month;\n    /**\n     * The day-of-month.\n     */\n    private final short day;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date using the system clock and default time-zone, not null\n     */\n    public static LocalDate now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date using the system clock, not null\n     */\n    public static LocalDate now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date - today.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date, not null\n     */\n    public static LocalDate now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        return ofInstant(now, clock.getZone());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a year, month and day.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDate of(int year, Month month, int dayOfMonth) {\n        YEAR.checkValidValue(year);\n        Objects.requireNonNull(month, \"month\");\n        DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        return create(year, month.getValue(), dayOfMonth);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDate} from a year, month and day.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDate of(int year, int month, int dayOfMonth) {\n        YEAR.checkValidValue(year);\n        MONTH_OF_YEAR.checkValidValue(month);\n        DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        return create(year, month, dayOfMonth);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a year and day-of-year.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year and day-of-year.\n     * The day-of-year must be valid for the year, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param dayOfYear  the day-of-year to represent, from 1 to 366\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-year is invalid for the year\n     */\n    public static LocalDate ofYearDay(int year, int dayOfYear) {\n        YEAR.checkValidValue(year);\n        DAY_OF_YEAR.checkValidValue(dayOfYear);\n        boolean leap \u003d IsoChronology.INSTANCE.isLeapYear(year);\n        if (dayOfYear \u003d\u003d 366 \u0026\u0026 leap \u003d\u003d false) {\n            throw new DateTimeException(\"Invalid date \u0027DayOfYear 366\u0027 as \u0027\" + year + \"\u0027 is not a leap year\");\n        }\n        Month moy \u003d Month.of((dayOfYear - 1) / 31 + 1);\n        int monthEnd \u003d moy.firstDayOfYear(leap) + moy.length(leap) - 1;\n        if (dayOfYear \u003e monthEnd) {\n            moy \u003d moy.plus(1);\n        }\n        int dom \u003d dayOfYear - moy.firstDayOfYear(leap) + 1;\n        return new LocalDate(year, moy.getValue(), dom);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates a local date based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date.\n     *\n     * @param instant  the instant to create the date from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the local date, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     * @since 9\n     */\n    public static LocalDate ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        long localSecond \u003d instant.getEpochSecond() + offset.getTotalSeconds();\n        long localEpochDay \u003d Math.floorDiv(localSecond, SECONDS_PER_DAY);\n        return ofEpochDay(localEpochDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from the epoch day count.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified epoch-day.\n     * The {@link ChronoField#EPOCH_DAY EPOCH_DAY} is a simple incrementing count\n     * of days where day 0 is 1970-01-01. Negative numbers represent earlier days.\n     *\n     * @param epochDay  the Epoch Day to convert, based on the epoch 1970-01-01\n     * @return the local date, not null\n     * @throws DateTimeException if the epoch day exceeds the supported date range\n     */\n    public static LocalDate ofEpochDay(long epochDay) {\n        EPOCH_DAY.checkValidValue(epochDay);\n        long zeroDay \u003d epochDay + DAYS_0000_TO_1970;\n        // find the march-based year\n        zeroDay -\u003d 60;  // adjust to 0000-03-01 so leap day is at end of four year cycle\n        long adjust \u003d 0;\n        if (zeroDay \u003c 0) {\n            // adjust negative years to positive for calculation\n            long adjustCycles \u003d (zeroDay + 1) / DAYS_PER_CYCLE - 1;\n            adjust \u003d adjustCycles * 400;\n            zeroDay +\u003d -adjustCycles * DAYS_PER_CYCLE;\n        }\n        long yearEst \u003d (400 * zeroDay + 591) / DAYS_PER_CYCLE;\n        long doyEst \u003d zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);\n        if (doyEst \u003c 0) {\n            // fix estimate\n            yearEst--;\n            doyEst \u003d zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);\n        }\n        yearEst +\u003d adjust;  // reset any negative year\n        int marchDoy0 \u003d (int) doyEst;\n\n        // convert march-based values back to january-based\n        int marchMonth0 \u003d (marchDoy0 * 5 + 2) / 153;\n        int month \u003d (marchMonth0 + 2) % 12 + 1;\n        int dom \u003d marchDoy0 - (marchMonth0 * 306 + 5) / 10 + 1;\n        yearEst +\u003d marchMonth0 / 10;\n\n        // check year now we are certain it is correct\n        int year \u003d YEAR.checkValidIntValue(yearEst);\n        return new LocalDate(year, month, dom);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a temporal object.\n     * \u003cp\u003e\n     * This obtains a local date based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code LocalDate}.\n     * \u003cp\u003e\n     * The conversion uses the {@link TemporalQueries#localDate()} query, which relies\n     * on extracting the {@link ChronoField#EPOCH_DAY EPOCH_DAY} field.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code LocalDate::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the local date, not null\n     * @throws DateTimeException if unable to convert to a {@code LocalDate}\n     */\n    public static LocalDate from(TemporalAccessor temporal) {\n        Objects.requireNonNull(temporal, \"temporal\");\n        LocalDate date \u003d temporal.query(TemporalQueries.localDate());\n        if (date \u003d\u003d null) {\n            throw new DateTimeException(\"Unable to obtain LocalDate from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName());\n        }\n        return date;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a text string such as {@code 2007-12-03}.\n     * \u003cp\u003e\n     * The string must represent a valid date and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_DATE}.\n     *\n     * @param text  the text to parse such as \"2007-12-03\", not null\n     * @return the parsed local date, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDate parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_LOCAL_DATE);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDate} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed local date, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDate parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, LocalDate::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a local date from the year, month and day fields.\n     *\n     * @param year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 to 12, validated\n     * @param dayOfMonth  the day-of-month to represent, validated from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the day-of-month is invalid for the month-year\n     */\n    private static LocalDate create(int year, int month, int dayOfMonth) {\n        if (dayOfMonth \u003e 28) {\n            int dom \u003d 31;\n            switch (month) {\n                case 2:\n                    dom \u003d (IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n                    break;\n                case 4:\n                case 6:\n                case 9:\n                case 11:\n                    dom \u003d 30;\n                    break;\n            }\n            if (dayOfMonth \u003e dom) {\n                if (dayOfMonth \u003d\u003d 29) {\n                    throw new DateTimeException(\"Invalid date \u0027February 29\u0027 as \u0027\" + year + \"\u0027 is not a leap year\");\n                } else {\n                    throw new DateTimeException(\"Invalid date \u0027\" + Month.of(month).name() + \" \" + dayOfMonth + \"\u0027\");\n                }\n            }\n        }\n        return new LocalDate(year, month, dayOfMonth);\n    }\n\n    /**\n     * Resolves the date, resolving days past the end of month.\n     *\n     * @param year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, validated from 1 to 12\n     * @param day  the day-of-month to represent, validated from 1 to 31\n     * @return the resolved date, not null\n     */\n    private static LocalDate resolvePreviousValid(int year, int month, int day) {\n        switch (month) {\n            case 2:\n                day \u003d Math.min(day, IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n                break;\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                day \u003d Math.min(day, 30);\n                break;\n        }\n        return new LocalDate(year, month, day);\n    }\n\n    /**\n     * Constructor, previously validated.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, valid for year-month, from 1 to 31\n     */\n    private LocalDate(int year, int month, int dayOfMonth) {\n        this.year \u003d year;\n        this.month \u003d (short) month;\n        this.day \u003d (short) dayOfMonth;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalField field) {\n        return ChronoLocalDate.super.isSupported(field);\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        return ChronoLocalDate.super.isSupported(unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            if (f.isDateBased()) {\n                switch (f) {\n                    case DAY_OF_MONTH: return ValueRange.of(1, lengthOfMonth());\n                    case DAY_OF_YEAR: return ValueRange.of(1, lengthOfYear());\n                    case ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, getMonth() \u003d\u003d Month.FEBRUARY \u0026\u0026 isLeapYear() \u003d\u003d false ? 4 : 5);\n                    case YEAR_OF_ERA:\n                        return (getYear() \u003c\u003d 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n                }\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date, except {@code EPOCH_DAY} and {@code PROLEPTIC_MONTH}\n     * which are too large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc and performance\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            return get0(field);\n        }\n        return ChronoLocalDate.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            if (field \u003d\u003d EPOCH_DAY) {\n                return toEpochDay();\n            }\n            if (field \u003d\u003d PROLEPTIC_MONTH) {\n                return getProlepticMonth();\n            }\n            return get0(field);\n        }\n        return field.getFrom(this);\n    }\n\n    private int get0(TemporalField field) {\n        switch ((ChronoField) field) {\n            case DAY_OF_WEEK: return getDayOfWeek().getValue();\n            case ALIGNED_DAY_OF_WEEK_IN_MONTH: return ((day - 1) % 7) + 1;\n            case ALIGNED_DAY_OF_WEEK_IN_YEAR: return ((getDayOfYear() - 1) % 7) + 1;\n            case DAY_OF_MONTH: return day;\n            case DAY_OF_YEAR: return getDayOfYear();\n            case EPOCH_DAY: throw new UnsupportedTemporalTypeException(\"Invalid field \u0027EpochDay\u0027 for get() method, use getLong() instead\");\n            case ALIGNED_WEEK_OF_MONTH: return ((day - 1) / 7) + 1;\n            case ALIGNED_WEEK_OF_YEAR: return ((getDayOfYear() - 1) / 7) + 1;\n            case MONTH_OF_YEAR: return month;\n            case PROLEPTIC_MONTH: throw new UnsupportedTemporalTypeException(\"Invalid field \u0027ProlepticMonth\u0027 for get() method, use getLong() instead\");\n            case YEAR_OF_ERA: return (year \u003e\u003d 1 ? year : 1 - year);\n            case YEAR: return year;\n            case ERA: return (year \u003e\u003d 1 ? 1 : 0);\n        }\n        throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n    }\n\n    private long getProlepticMonth() {\n        return (year * 12L + month - 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology of this date, which is the ISO calendar system.\n     * \u003cp\u003e\n     * The {@code Chronology} represents the calendar system in use.\n     * The ISO-8601 calendar system is the modern civil calendar system used today\n     * in most of the world. It is equivalent to the proleptic Gregorian calendar\n     * system, in which today\u0027s rules for leap years are applied for all time.\n     *\n     * @return the ISO chronology, not null\n     */\n    @Override\n    public IsoChronology getChronology() {\n        return IsoChronology.INSTANCE;\n    }\n\n    /**\n     * Gets the era applicable at this date.\n     * \u003cp\u003e\n     * The official ISO-8601 standard does not define eras, however {@code IsoChronology} does.\n     * It defines two eras, \u0027CE\u0027 from year one onwards and \u0027BCE\u0027 from year zero backwards.\n     * Since dates before the Julian-Gregorian cutover are not in line with history,\n     * the cutover between \u0027BCE\u0027 and \u0027CE\u0027 is also not aligned with the commonly used\n     * eras, often referred to using \u0027BC\u0027 and \u0027AD\u0027.\n     * \u003cp\u003e\n     * Users of this class should typically ignore this method as it exists primarily\n     * to fulfill the {@link ChronoLocalDate} contract where it is necessary to support\n     * the Japanese calendar system.\n     *\n     * @return the IsoEra applicable at this date, not null\n     */\n    @Override // override for Javadoc\n    public IsoEra getEra() {\n        return (getYear() \u003e\u003d 1 ? IsoEra.CE : IsoEra.BCE);\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return year;\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return month;\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return Month.of(month);\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return day;\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return getMonth().firstDayOfYear(isLeapYear()) + day - 1;\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        int dow0 \u003d Math.floorMod(toEpochDay() + 3, 7);\n        return DayOfWeek.of(dow0 + 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     * \u003cp\u003e\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     * \u003cp\u003e\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     * \u003cp\u003e\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return true if the year is leap, false otherwise\n     */\n    @Override // override for Javadoc and performance\n    public boolean isLeapYear() {\n        return IsoChronology.INSTANCE.isLeapYear(year);\n    }\n\n    /**\n     * Returns the length of the month represented by this date.\n     * \u003cp\u003e\n     * This returns the length of the month in days.\n     * For example, a date in January would return 31.\n     *\n     * @return the length of the month in days\n     */\n    @Override\n    public int lengthOfMonth() {\n        switch (month) {\n            case 2:\n                return (isLeapYear() ? 29 : 28);\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Returns the length of the year represented by this date.\n     * \u003cp\u003e\n     * This returns the length of the year in days, either 365 or 366.\n     *\n     * @return 366 if the year is leap, 365 otherwise\n     */\n    @Override // override for Javadoc and performance\n    public int lengthOfYear() {\n        return (isLeapYear() ? 366 : 365);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the date adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * \u003cp\u003e\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d localDate.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return a {@code LocalDate} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return (LocalDate) adjuster;\n        }\n        return (LocalDate) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAY_OF_WEEK} -\n     *  Returns a {@code LocalDate} with the specified day-of-week.\n     *  The date is adjusted up to 6 days forward or backward within the boundary\n     *  of a Monday to Sunday week.\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH} -\n     *  Returns a {@code LocalDate} with the specified aligned-day-of-week.\n     *  The date is adjusted to the specified month-based aligned-day-of-week.\n     *  Aligned weeks are counted such that the first week of a given month starts\n     *  on the first day of that month.\n     *  This may cause the date to be moved up to 6 days into the following month.\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR} -\n     *  Returns a {@code LocalDate} with the specified aligned-day-of-week.\n     *  The date is adjusted to the specified year-based aligned-day-of-week.\n     *  Aligned weeks are counted such that the first week of a given year starts\n     *  on the first day of that year.\n     *  This may cause the date to be moved up to 6 days into the following year.\n     * \u003cli\u003e{@code DAY_OF_MONTH} -\n     *  Returns a {@code LocalDate} with the specified day-of-month.\n     *  The month and year will be unchanged. If the day-of-month is invalid for the\n     *  year and month, then a {@code DateTimeException} is thrown.\n     * \u003cli\u003e{@code DAY_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified day-of-year.\n     *  The year will be unchanged. If the day-of-year is invalid for the\n     *  year, then a {@code DateTimeException} is thrown.\n     * \u003cli\u003e{@code EPOCH_DAY} -\n     *  Returns a {@code LocalDate} with the specified epoch-day.\n     *  This completely replaces the date and is equivalent to {@link #ofEpochDay(long)}.\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH} -\n     *  Returns a {@code LocalDate} with the specified aligned-week-of-month.\n     *  Aligned weeks are counted such that the first week of a given month starts\n     *  on the first day of that month.\n     *  This adjustment moves the date in whole week chunks to match the specified week.\n     *  The result will have the same day-of-week as this date.\n     *  This may cause the date to be moved into the following month.\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified aligned-week-of-year.\n     *  Aligned weeks are counted such that the first week of a given year starts\n     *  on the first day of that year.\n     *  This adjustment moves the date in whole week chunks to match the specified week.\n     *  The result will have the same day-of-week as this date.\n     *  This may cause the date to be moved into the following year.\n     * \u003cli\u003e{@code MONTH_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified month-of-year.\n     *  The year will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code PROLEPTIC_MONTH} -\n     *  Returns a {@code LocalDate} with the specified proleptic-month.\n     *  The day-of-month will be unchanged, unless it would be invalid for the new month\n     *  and year. In that case, the day-of-month is adjusted to the maximum valid value\n     *  for the new month and year.\n     * \u003cli\u003e{@code YEAR_OF_ERA} -\n     *  Returns a {@code LocalDate} with the specified year-of-era.\n     *  The era and month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code YEAR} -\n     *  Returns a {@code LocalDate} with the specified year.\n     *  The month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code ERA} -\n     *  Returns a {@code LocalDate} with the specified era.\n     *  The year-of-era and month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return a {@code LocalDate} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            f.checkValidValue(newValue);\n            switch (f) {\n                case DAY_OF_WEEK: return plusDays(newValue - getDayOfWeek().getValue());\n                case ALIGNED_DAY_OF_WEEK_IN_MONTH: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n                case ALIGNED_DAY_OF_WEEK_IN_YEAR: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                case DAY_OF_MONTH: return withDayOfMonth((int) newValue);\n                case DAY_OF_YEAR: return withDayOfYear((int) newValue);\n                case EPOCH_DAY: return LocalDate.ofEpochDay(newValue);\n                case ALIGNED_WEEK_OF_MONTH: return plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_MONTH));\n                case ALIGNED_WEEK_OF_YEAR: return plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_YEAR));\n                case MONTH_OF_YEAR: return withMonth((int) newValue);\n                case PROLEPTIC_MONTH: return plusMonths(newValue - getProlepticMonth());\n                case YEAR_OF_ERA: return withYear((int) (year \u003e\u003d 1 ? newValue : 1 - newValue));\n                case YEAR: return withYear((int) newValue);\n                case ERA: return (getLong(ERA) \u003d\u003d newValue ? this : withYear(1 - year));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the year altered.\n     * \u003cp\u003e\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return a {@code LocalDate} based on this date with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public LocalDate withYear(int year) {\n        if (this.year \u003d\u003d year) {\n            return this;\n        }\n        YEAR.checkValidValue(year);\n        return resolvePreviousValid(year, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the month-of-year altered.\n     * \u003cp\u003e\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return a {@code LocalDate} based on this date with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public LocalDate withMonth(int month) {\n        if (this.month \u003d\u003d month) {\n            return this;\n        }\n        MONTH_OF_YEAR.checkValidValue(month);\n        return resolvePreviousValid(year, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting date is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return a {@code LocalDate} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public LocalDate withDayOfMonth(int dayOfMonth) {\n        if (this.day \u003d\u003d dayOfMonth) {\n            return this;\n        }\n        return of(year, month, dayOfMonth);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the day-of-year altered.\n     * \u003cp\u003e\n     * If the resulting date is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return a {@code LocalDate} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public LocalDate withDayOfYear(int dayOfYear) {\n        if (this.getDayOfYear() \u003d\u003d dayOfYear) {\n            return this;\n        }\n        return ofYearDay(year, dayOfYear);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return a {@code LocalDate} based on this date with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate plus(TemporalAmount amountToAdd) {\n        if (amountToAdd instanceof Period) {\n            Period periodToAdd \u003d (Period) amountToAdd;\n            return plusMonths(periodToAdd.toTotalMonths()).plusDays(periodToAdd.getDays());\n        }\n        Objects.requireNonNull(amountToAdd, \"amountToAdd\");\n        return (LocalDate) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, adding the amount can cause the resulting date to become invalid.\n     * For example, adding one month to 31st January would result in 31st February.\n     * In cases like this, the unit is responsible for resolving the date.\n     * Typically it will choose the previous valid date, which would be the last valid\n     * day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented here.\n     * The supported fields behave as follows:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAYS} -\n     *  Returns a {@code LocalDate} with the specified number of days added.\n     *  This is equivalent to {@link #plusDays(long)}.\n     * \u003cli\u003e{@code WEEKS} -\n     *  Returns a {@code LocalDate} with the specified number of weeks added.\n     *  This is equivalent to {@link #plusWeeks(long)} and uses a 7 day week.\n     * \u003cli\u003e{@code MONTHS} -\n     *  Returns a {@code LocalDate} with the specified number of months added.\n     *  This is equivalent to {@link #plusMonths(long)}.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code YEARS} -\n     *  Returns a {@code LocalDate} with the specified number of years added.\n     *  This is equivalent to {@link #plusYears(long)}.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code DECADES} -\n     *  Returns a {@code LocalDate} with the specified number of decades added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 10.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code CENTURIES} -\n     *  Returns a {@code LocalDate} with the specified number of centuries added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 100.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code MILLENNIA} -\n     *  Returns a {@code LocalDate} with the specified number of millennia added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 1,000.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code ERAS} -\n     *  Returns a {@code LocalDate} with the specified number of eras added.\n     *  Only two eras are supported so the amount must be one, zero or minus one.\n     *  If the amount is non-zero then the year is changed such that the year-of-era\n     *  is unchanged.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * All other {@code ChronoUnit} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return a {@code LocalDate} based on this date with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            ChronoUnit f \u003d (ChronoUnit) unit;\n            switch (f) {\n                case DAYS: return plusDays(amountToAdd);\n                case WEEKS: return plusWeeks(amountToAdd);\n                case MONTHS: return plusMonths(amountToAdd);\n                case YEARS: return plusYears(amountToAdd);\n                case DECADES: return plusYears(Math.multiplyExact(amountToAdd, 10));\n                case CENTURIES: return plusYears(Math.multiplyExact(amountToAdd, 100));\n                case MILLENNIA: return plusYears(Math.multiplyExact(amountToAdd, 1000));\n                case ERAS: return with(ERA, Math.addExact(getLong(ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param yearsToAdd  the years to add, may be negative\n     * @return a {@code LocalDate} based on this date with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusYears(long yearsToAdd) {\n        if (yearsToAdd \u003d\u003d 0) {\n            return this;\n        }\n        int newYear \u003d YEAR.checkValidIntValue(year + yearsToAdd);  // safe overflow\n        return resolvePreviousValid(newYear, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param monthsToAdd  the months to add, may be negative\n     * @return a {@code LocalDate} based on this date with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusMonths(long monthsToAdd) {\n        if (monthsToAdd \u003d\u003d 0) {\n            return this;\n        }\n        long monthCount \u003d year * 12L + (month - 1);\n        long calcMonths \u003d monthCount + monthsToAdd;  // safe overflow\n        int newYear \u003d YEAR.checkValidIntValue(Math.floorDiv(calcMonths, 12));\n        int newMonth \u003d Math.floorMod(calcMonths, 12) + 1;\n        return resolvePreviousValid(newYear, newMonth, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeksToAdd  the weeks to add, may be negative\n     * @return a {@code LocalDate} based on this date with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusWeeks(long weeksToAdd) {\n        return plusDays(Math.multiplyExact(weeksToAdd, 7));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param daysToAdd  the days to add, may be negative\n     * @return a {@code LocalDate} based on this date with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusDays(long daysToAdd) {\n        if (daysToAdd \u003d\u003d 0) {\n            return this;\n        }\n        long dom \u003d day + daysToAdd;\n        if (dom \u003e 0) {\n            if (dom \u003c\u003d 28) {\n                return new LocalDate(year, month, (int) dom);\n            } else if (dom \u003c\u003d 59) { // 59th Jan is 28th Feb, 59th Feb is 31st Mar\n                long monthLen \u003d lengthOfMonth();\n                if (dom \u003c\u003d monthLen) {\n                    return new LocalDate(year, month, (int) dom);\n                } else if (month \u003c 12) {\n                    return new LocalDate(year, month + 1, (int) (dom - monthLen));\n                } else {\n                    YEAR.checkValidValue(year + 1);\n                    return new LocalDate(year + 1, 1, (int) (dom - monthLen));\n                }\n            }\n        }\n\n        long mjDay \u003d Math.addExact(toEpochDay(), daysToAdd);\n        return LocalDate.ofEpochDay(mjDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return a {@code LocalDate} based on this date with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate minus(TemporalAmount amountToSubtract) {\n        if (amountToSubtract instanceof Period) {\n            Period periodToSubtract \u003d (Period) amountToSubtract;\n            return minusMonths(periodToSubtract.toTotalMonths()).minusDays(periodToSubtract.getDays());\n        }\n        Objects.requireNonNull(amountToSubtract, \"amountToSubtract\");\n        return (LocalDate) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return a {@code LocalDate} based on this date with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param yearsToSubtract  the years to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusYears(long yearsToSubtract) {\n        return (yearsToSubtract \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-yearsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param monthsToSubtract  the months to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusMonths(long monthsToSubtract) {\n        return (monthsToSubtract \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-monthsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeksToSubtract  the weeks to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusWeeks(long weeksToSubtract) {\n        return (weeksToSubtract \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeksToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param daysToSubtract  the days to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusDays(long daysToSubtract) {\n        return (daysToSubtract \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-daysToSubtract));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date using the specified query.\n     * \u003cp\u003e\n     * This queries this date using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) this;\n        }\n        return ChronoLocalDate.super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the date changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * passing {@link ChronoField#EPOCH_DAY} as the field.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisLocalDate.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisLocalDate);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc\n    public Temporal adjustInto(Temporal temporal) {\n        return ChronoLocalDate.super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the amount of time until another date in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code LocalDate}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code LocalDate} using {@link #from(TemporalAccessor)}.\n     * For example, the amount in days between two dates can be calculated\n     * using {@code startDate.until(endDate, DAYS)}.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two dates.\n     * For example, the amount in months between 2012-06-15 and 2012-08-14\n     * will only be one month as it is one day short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code DAYS}, {@code WEEKS}, {@code MONTHS}, {@code YEARS},\n     * {@code DECADES}, {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS}\n     * are supported. Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to a {@code LocalDate}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date and the end date\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to a {@code LocalDate}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        LocalDate end \u003d LocalDate.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch ((ChronoUnit) unit) {\n                case DAYS: return daysUntil(end);\n                case WEEKS: return daysUntil(end) / 7;\n                case MONTHS: return monthsUntil(end);\n                case YEARS: return monthsUntil(end) / 12;\n                case DECADES: return monthsUntil(end) / 120;\n                case CENTURIES: return monthsUntil(end) / 1200;\n                case MILLENNIA: return monthsUntil(end) / 12000;\n                case ERAS: return end.getLong(ERA) - getLong(ERA);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    long daysUntil(LocalDate end) {\n        return end.toEpochDay() - toEpochDay();  // no overflow\n    }\n\n    private long monthsUntil(LocalDate end) {\n        long packed1 \u003d getProlepticMonth() * 32L + getDayOfMonth();  // no overflow\n        long packed2 \u003d end.getProlepticMonth() * 32L + end.getDayOfMonth();  // no overflow\n        return (packed2 - packed1) / 32;\n    }\n\n    /**\n     * Calculates the period between this date and another date as a {@code Period}.\n     * \u003cp\u003e\n     * This calculates the period between two dates in terms of years, months and days.\n     * The start and end points are {@code this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The negative sign will be the same in each of year, month and day.\n     * \u003cp\u003e\n     * The calculation is performed using the ISO calendar system.\n     * If necessary, the input date will be converted to ISO.\n     * \u003cp\u003e\n     * The start date is included, but the end date is not.\n     * The period is calculated by removing complete months, then calculating\n     * the remaining number of days, adjusting to ensure that both have the same sign.\n     * The number of months is then normalized into years and months based on a 12 month year.\n     * A month is considered to be complete if the end day-of-month is greater\n     * than or equal to the start day-of-month.\n     * For example, from {@code 2010-01-15} to {@code 2011-03-18} is \"1 year, 2 months and 3 days\".\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link Period#between(LocalDate, LocalDate)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   period \u003d start.until(end);\n     *   period \u003d Period.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     *\n     * @param endDateExclusive  the end date, exclusive, which may be in any chronology, not null\n     * @return the period between this date and the end date, not null\n     */\n    @Override\n    public Period until(ChronoLocalDate endDateExclusive) {\n        LocalDate end \u003d LocalDate.from(endDateExclusive);\n        long totalMonths \u003d end.getProlepticMonth() - this.getProlepticMonth();  // safe\n        int days \u003d end.day - this.day;\n        if (totalMonths \u003e 0 \u0026\u0026 days \u003c 0) {\n            totalMonths--;\n            LocalDate calcDate \u003d this.plusMonths(totalMonths);\n            days \u003d (int) (end.toEpochDay() - calcDate.toEpochDay());  // safe\n        } else if (totalMonths \u003c 0 \u0026\u0026 days \u003e 0) {\n            totalMonths++;\n            days -\u003d end.lengthOfMonth();\n        }\n        long years \u003d totalMonths / 12;  // safe\n        int months \u003d (int) (totalMonths % 12);  // safe\n        return Period.of(Math.toIntExact(years), months, days);\n    }\n\n    /**\n     * Returns a sequential ordered stream of dates. The returned stream starts from this date\n     * (inclusive) and goes to {@code endExclusive} (exclusive) by an incremental step of 1 day.\n     * \u003cp\u003e\n     * This method is equivalent to {@code datesUntil(endExclusive, Period.ofDays(1))}.\n     *\n     * @param endExclusive  the end date, exclusive, not null\n     * @return a sequential {@code Stream} for the range of {@code LocalDate} values\n     * @throws IllegalArgumentException if end date is before this date\n     * @since 9\n     */\n    public Stream\u003cLocalDate\u003e datesUntil(LocalDate endExclusive) {\n        long end \u003d endExclusive.toEpochDay();\n        long start \u003d toEpochDay();\n        if (end \u003c start) {\n            throw new IllegalArgumentException(endExclusive + \" \u003c \" + this);\n        }\n        return LongStream.range(start, end).mapToObj(LocalDate::ofEpochDay);\n    }\n\n    /**\n     * Returns a sequential ordered stream of dates by given incremental step. The returned stream\n     * starts from this date (inclusive) and goes to {@code endExclusive} (exclusive).\n     * \u003cp\u003e\n     * The n-th date which appears in the stream is equal to {@code this.plus(step.multipliedBy(n))}\n     * (but the result of step multiplication never overflows). For example, if this date is\n     * {@code 2015-01-31}, the end date is {@code 2015-05-01} and the step is 1 month, then the\n     * stream contains {@code 2015-01-31}, {@code 2015-02-28}, {@code 2015-03-31}, and\n     * {@code 2015-04-30}.\n     *\n     * @param endExclusive  the end date, exclusive, not null\n     * @param step  the non-zero, non-negative {@code Period} which represents the step.\n     * @return a sequential {@code Stream} for the range of {@code LocalDate} values\n     * @throws IllegalArgumentException if step is zero, or {@code step.getDays()} and\n     *             {@code step.toTotalMonths()} have opposite sign, or end date is before this date\n     *             and step is positive, or end date is after this date and step is negative\n     * @since 9\n     */\n    public Stream\u003cLocalDate\u003e datesUntil(LocalDate endExclusive, Period step) {\n        if (step.isZero()) {\n            throw new IllegalArgumentException(\"step is zero\");\n        }\n        long end \u003d endExclusive.toEpochDay();\n        long start \u003d toEpochDay();\n        long until \u003d end - start;\n        long months \u003d step.toTotalMonths();\n        long days \u003d step.getDays();\n        if ((months \u003c 0 \u0026\u0026 days \u003e 0) || (months \u003e 0 \u0026\u0026 days \u003c 0)) {\n            throw new IllegalArgumentException(\"period months and days are of opposite sign\");\n        }\n        if (until \u003d\u003d 0) {\n            return Stream.empty();\n        }\n        int sign \u003d months \u003e 0 || days \u003e 0 ? 1 : -1;\n        if (sign \u003c 0 ^ until \u003c 0) {\n            throw new IllegalArgumentException(endExclusive + (sign \u003c 0 ? \" \u003e \" : \" \u003c \") + this);\n        }\n        if (months \u003d\u003d 0) {\n            long steps \u003d (until - sign) / days; // non-negative\n            return LongStream.rangeClosed(0, steps).mapToObj(\n                    n -\u003e LocalDate.ofEpochDay(start + n * days));\n        }\n        // 48699/1600 \u003d 365.2425/12, no overflow, non-negative result\n        long steps \u003d until * 1600 / (months * 48699 + days * 1600) + 1;\n        long addMonths \u003d months * steps;\n        long addDays \u003d days * steps;\n        long maxAddMonths \u003d months \u003e 0 ? MAX.getProlepticMonth() - getProlepticMonth()\n                : getProlepticMonth() - MIN.getProlepticMonth();\n        // adjust steps estimation\n        if (addMonths * sign \u003e maxAddMonths\n                || (plusMonths(addMonths).toEpochDay() + addDays) * sign \u003e\u003d end * sign) {\n            steps--;\n            addMonths -\u003d months;\n            addDays -\u003d days;\n            if (addMonths * sign \u003e maxAddMonths\n                    || (plusMonths(addMonths).toEpochDay() + addDays) * sign \u003e\u003d end * sign) {\n                steps--;\n            }\n        }\n        return LongStream.rangeClosed(0, steps).mapToObj(\n                n -\u003e this.plusMonths(months * n).plusDays(days * n));\n    }\n\n    /**\n     * Formats this date using the specified formatter.\n     * \u003cp\u003e\n     * This date will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    @Override  // override for Javadoc and performance\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param time  the time to combine with, not null\n     * @return the local date-time formed from this date and the specified time, not null\n     */\n    @Override\n    public LocalDateTime atTime(LocalTime time) {\n        return LocalDateTime.of(this, time);\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour and minute.\n     * The seconds and nanosecond fields will be set to zero.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute) {\n        return atTime(LocalTime.of(hour, minute));\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour, minute and second.\n     * The nanosecond field will be set to zero.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute, int second) {\n        return atTime(LocalTime.of(hour, minute, second));\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour, minute, second and nanosecond.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute, int second, int nanoOfSecond) {\n        return atTime(LocalTime.of(hour, minute, second, nanoOfSecond));\n    }\n\n    /**\n     * Combines this date with an offset time to create an {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param time  the time to combine with, not null\n     * @return the offset date-time formed from this date and the specified time, not null\n     */\n    public OffsetDateTime atTime(OffsetTime time) {\n        return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.getOffset());\n    }\n\n    /**\n     * Combines this date with the time of midnight to create a {@code LocalDateTime}\n     * at the start of this date.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the time of\n     * midnight, 00:00, at the start of this date.\n     *\n     * @return the local date-time of midnight at the start of this date, not null\n     */\n    public LocalDateTime atStartOfDay() {\n        return LocalDateTime.of(this, LocalTime.MIDNIGHT);\n    }\n\n    /**\n     * Returns a zoned date-time from this date at the earliest valid time according\n     * to the rules in the time-zone.\n     * \u003cp\u003e\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may not be midnight.\n     * \u003cp\u003e\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, there are two valid offsets, and the earlier one is used,\n     * corresponding to the first occurrence of midnight on the date.\n     * In the case of a gap, the zoned date-time will represent the instant just after the gap.\n     * \u003cp\u003e\n     * If the zone ID is a {@link ZoneOffset}, then the result always has a time of midnight.\n     * \u003cp\u003e\n     * To convert to a specific time in a given time-zone call {@link #atTime(LocalTime)}\n     * followed by {@link LocalDateTime#atZone(ZoneId)}.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atStartOfDay(ZoneId zone) {\n        Objects.requireNonNull(zone, \"zone\");\n        // need to handle case where there is a gap from 11:30 to 00:30\n        // standard ZDT factory would result in 01:00 rather than 00:30\n        LocalDateTime ldt \u003d atTime(LocalTime.MIDNIGHT);\n        if (zone instanceof ZoneOffset \u003d\u003d false) {\n            ZoneRules rules \u003d zone.getRules();\n            ZoneOffsetTransition trans \u003d rules.getTransition(ldt);\n            if (trans !\u003d null \u0026\u0026 trans.isGap()) {\n                ldt \u003d trans.getDateTimeAfter();\n            }\n        }\n        return ZonedDateTime.of(ldt, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public long toEpochDay() {\n        long y \u003d year;\n        long m \u003d month;\n        long total \u003d 0;\n        total +\u003d 365 * y;\n        if (y \u003e\u003d 0) {\n            total +\u003d (y + 3) / 4 - (y + 99) / 100 + (y + 399) / 400;\n        } else {\n            total -\u003d y / -4 - y / -100 + y / -400;\n        }\n        total +\u003d ((367 * m - 362) / 12);\n        total +\u003d day - 1;\n        if (m \u003e 2) {\n            total--;\n            if (isLeapYear() \u003d\u003d false) {\n                total--;\n            }\n        }\n        return total - DAYS_0000_TO_1970;\n    }\n\n    /**\n     * Converts this {@code LocalDate} to the number of seconds since the epoch\n     * of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This combines this local date with the specified time and\n     * offset to calculate the epoch-second value, which is the\n     * number of elapsed seconds from 1970-01-01T00:00:00Z.\n     * Instants on the time-line after the epoch are positive, earlier\n     * are negative.\n     *\n     * @param time the local time, not null\n     * @param offset the zone offset, not null\n     * @return the number of seconds since the epoch of 1970-01-01T00:00:00Z, may be negative\n     * @since 9\n     */\n    public long toEpochSecond(LocalTime time, ZoneOffset offset) {\n        Objects.requireNonNull(time, \"time\");\n        Objects.requireNonNull(offset, \"offset\");\n        long secs \u003d toEpochDay() * SECONDS_PER_DAY + time.toSecondOfDay();\n        secs -\u003d offset.getTotalSeconds();\n        return secs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date to another date.\n     * \u003cp\u003e\n     * The comparison is primarily based on the date, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * If all the dates being compared are instances of {@code LocalDate},\n     * then the comparison will be entirely based on the date.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link java.time.chrono.ChronoLocalDate#compareTo}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override  // override for Javadoc and performance\n    public int compareTo(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other);\n        }\n        return ChronoLocalDate.super.compareTo(other);\n    }\n\n    int compareTo0(LocalDate otherDate) {\n        int cmp \u003d (year - otherDate.year);\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d (month - otherDate.month);\n            if (cmp \u003d\u003d 0) {\n                cmp \u003d (day - otherDate.day);\n            }\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date is after the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents a point on the\n     * local time-line after the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isAfter(b) \u003d\u003d false\n     *   a.isAfter(a) \u003d\u003d false\n     *   b.isAfter(a) \u003d\u003d true\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is after the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isAfter(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003e 0;\n        }\n        return ChronoLocalDate.super.isAfter(other);\n    }\n\n    /**\n     * Checks if this date is before the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents a point on the\n     * local time-line before the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isBefore(b) \u003d\u003d true\n     *   a.isBefore(a) \u003d\u003d false\n     *   b.isBefore(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is before the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isBefore(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003c 0;\n        }\n        return ChronoLocalDate.super.isBefore(other);\n    }\n\n    /**\n     * Checks if this date is equal to the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents the same point on the\n     * local time-line as the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isEqual(b) \u003d\u003d false\n     *   a.isEqual(a) \u003d\u003d true\n     *   b.isEqual(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)}\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is equal to the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isEqual(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003d\u003d 0;\n        }\n        return ChronoLocalDate.super.isEqual(other);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date is equal to another date.\n     * \u003cp\u003e\n     * Compares this {@code LocalDate} with another ensuring that the date is the same.\n     * \u003cp\u003e\n     * Only objects of type {@code LocalDate} are compared, other types return false.\n     * To compare the dates of two {@code TemporalAccessor} instances, including dates\n     * in two different chronologies, use {@link ChronoField#EPOCH_DAY} as a comparator.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof LocalDate) {\n            return compareTo0((LocalDate) obj) \u003d\u003d 0;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        int yearValue \u003d year;\n        int monthValue \u003d month;\n        int dayValue \u003d day;\n        return (yearValue \u0026 0xFFFFF800) ^ ((yearValue \u003c\u003c 11) + (monthValue \u003c\u003c 6) + (dayValue));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date as a {@code String}, such as {@code 2007-12-03}.\n     * \u003cp\u003e\n     * The output will be in the ISO-8601 format {@code uuuu-MM-dd}.\n     *\n     * @return a string representation of this date, not null\n     */\n    @Override\n    public String toString() {\n        int yearValue \u003d year;\n        int monthValue \u003d month;\n        int dayValue \u003d day;\n        int absYear \u003d Math.abs(yearValue);\n        StringBuilder buf \u003d new StringBuilder(10);\n        if (absYear \u003c 1000) {\n            if (yearValue \u003c 0) {\n                buf.append(yearValue - 10000).deleteCharAt(1);\n            } else {\n                buf.append(yearValue + 10000).deleteCharAt(0);\n            }\n        } else {\n            if (yearValue \u003e 9999) {\n                buf.append(\u0027+\u0027);\n            }\n            buf.append(yearValue);\n        }\n        return buf.append(monthValue \u003c 10 ? \"-0\" : \"-\")\n            .append(monthValue)\n            .append(dayValue \u003c 10 ? \"-0\" : \"-\")\n            .append(dayValue)\n            .toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(3);  // identifies a LocalDate\n     *  out.writeInt(year);\n     *  out.writeByte(month);\n     *  out.writeByte(day);\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.LOCAL_DATE_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(DataOutput out) throws IOException {\n        out.writeInt(year);\n        out.writeByte(month);\n        out.writeByte(day);\n    }\n\n    static LocalDate readExternal(DataInput in) throws IOException {\n        int year \u003d in.readInt();\n        int month \u003d in.readByte();\n        int dayOfMonth \u003d in.readByte();\n        return LocalDate.of(year, month, dayOfMonth);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 18, 2024 3:05:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java"
  ]
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor27.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.10.18 15:05:12 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.semanticTokensFull(WorkspaceLspService.scala:545)
	scala.meta.metals.lsp.DelegatingScalaService.semanticTokensFull(DelegatingScalaService.scala:208)
	jdk.internal.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:05:12 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:443)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	jdk.internal.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:05:12 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

2024.10.18 15:05:12 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.codeLens(WorkspaceLspService.scala:530)
	scala.meta.metals.lsp.DelegatingScalaService.codeLens(DelegatingScalaService.scala:150)
	jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$3(MetalsLspService.scala:1225)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$2(MetalsLspService.scala:1224)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:05:12 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.documentSymbol(WorkspaceLspService.scala:460)
	scala.meta.metals.lsp.DelegatingScalaService.documentSymbol(DelegatingScalaService.scala:91)
	jdk.internal.reflect.GeneratedMethodAccessor5.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$documentSymbol$1(MetalsLspService.scala:1055)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:05:12 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

oct 18, 2024 3:05:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:14 INFO SparkContext: Invoking stop() from shutdown hook"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:14 IN..._15-05-14-430.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:14 INFO SparkContext: SparkContext is stopping with exitCode 0."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:14 IN..._15-05-14-430.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:14 INFO SparkUI: Stopped Spark web UI at http://host.docker.internal:4041"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:14 IN..._15-05-14-433.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:14 INFO MapOutputTrackerMasterEndpoint: MapOutputTrackerMasterEndpoint stopped!"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:14 IN..._15-05-14-449.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:14 INFO MemoryStore: MemoryStore cleared"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:14 IN..._15-05-14-458.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:14 INFO BlockManager: BlockManager stopped"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:14 IN..._15-05-14-458.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:14 INFO BlockManagerMaster: BlockManagerMaster stopped"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:14 IN..._15-05-14-463.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:14 INFO OutputCommitCoordinator$OutputCommitCoordinatorEndpoint: OutputCommitCoordinator stopped!"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:14 IN..._15-05-14-466.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:14 INFO SparkContext: Successfully stopped SparkContext"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:14 IN..._15-05-14-478.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:14 INFO ShutdownHookManager: Shutdown hook called"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:14 IN..._15-05-14-479.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:14 INFO ShutdownHookManager: Deleting directory C:\\Users\\jalva\\AppData\\Local\\Temp\\spark-25be4233-959e-4bd6-a43b-c7e317162307"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:14 IN..._15-05-14-479.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.18 15:05:20 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.hover(WorkspaceLspService.scala:438)
	scala.meta.metals.lsp.DelegatingScalaService.hover(DelegatingScalaService.scala:82)
	jdk.internal.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:21 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.Compilers.withPCAndAdjustLsp(Compilers.scala:1340)
	at scala.meta.internal.metals.Compilers.hover(Compilers.scala:885)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$hover$1(MetalsLspService.scala:999)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.hover(MetalsLspService.scala:997)
	at scala.meta.internal.metals.WorkspaceLspService.hover(WorkspaceLspService.scala:438)
	at scala.meta.metals.lsp.DelegatingScalaService.hover(DelegatingScalaService.scala:82)
	at jdk.internal.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 28 more

2024.10.18 15:05:20 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:443)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	jdk.internal.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:05:20 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:443)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	jdk.internal.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:05:25 INFO  Canceling debug proxy for [example.Main]
2024.10.18 15:05:25 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.18 15:05:25 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.18 15:05:25 INFO  Starting debug proxy for [example.Main]
2024.10.18 15:05:25 INFO  Loaded expression compiler in 1 millisecond
2024.10.18 15:05:25 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:05:25 WARN  Found duplicate entry jersey-server in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:05:25 WARN  Found duplicate entry jersey-client in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:05:26 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.hover(WorkspaceLspService.scala:438)
	scala.meta.metals.lsp.DelegatingScalaService.hover(DelegatingScalaService.scala:82)
	jdk.internal.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:26 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.Compilers.withPCAndAdjustLsp(Compilers.scala:1340)
	at scala.meta.internal.metals.Compilers.hover(Compilers.scala:885)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$hover$1(MetalsLspService.scala:999)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.hover(MetalsLspService.scala:997)
	at scala.meta.internal.metals.WorkspaceLspService.hover(WorkspaceLspService.scala:438)
	at scala.meta.metals.lsp.DelegatingScalaService.hover(DelegatingScalaService.scala:82)
	at jdk.internal.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 28 more

2024.10.18 15:05:26 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:443)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	jdk.internal.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:05:26 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:443)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	jdk.internal.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:05:28 INFO  Loaded all sources and classes in 2 seconds
2024.10.18 15:05:28 INFO  Initialized Scala 3 decoder in 0 milliseconds
2024.10.18 15:05:28 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:54625 .
2024.10.18 15:05:28 INFO  Attaching to debuggee VM succeeded.
2024.10.18 15:05:28 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:28 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

2024.10.18 15:05:28 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.documentSymbol(WorkspaceLspService.scala:460)
	scala.meta.metals.lsp.DelegatingScalaService.documentSymbol(DelegatingScalaService.scala:91)
	jdk.internal.reflect.GeneratedMethodAccessor5.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:28 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$documentSymbol$1(MetalsLspService.scala:1055)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:05:28 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:28 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

oct 18, 2024 3:05:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:29 INFO SparkContext: Running Spark version 3.5.0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:29 IN..._15-05-29-405.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:29 INFO SparkContext: OS info Windows 11, 10.0, amd64"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:29 IN..._15-05-29-407.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:29 INFO SparkContext: Java version 11.0.24"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:29 IN..._15-05-29-407.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:29 INFO ResourceUtils: \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:29 IN..._15-05-29-592.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:29 INFO ResourceUtils: No custom resources configured for spark.driver."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:29 IN..._15-05-29-593.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:29 INFO ResourceUtils: \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:29 IN..._15-05-29-593.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:29 INFO SparkContext: Submitted application: spark-javi"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:29 IN..._15-05-29-593.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:29 INFO ResourceProfile: Default ResourceProfile created, executor resources: Map(cores -\u003e name: cores, amount: 1, script: , vendor: , memory -\u003e name: memory, amount: 1024, script: , vendor: , offHeap -\u003e name: offHeap, amount: 0, script: , vendor: ), task resources: Map(cpus -\u003e name: cpus, amount: 1.0)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:29 IN..._15-05-29-618.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:29 INFO ResourceProfile: Limiting resource is cpu"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:29 IN..._15-05-29-624.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:29 INFO ResourceProfileManager: Added ResourceProfile id: 0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:29 IN..._15-05-29-625.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:29 INFO SecurityManager: Changing view acls to: jalva"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:29 IN..._15-05-29-678.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:29 INFO SecurityManager: Changing modify acls to: jalva"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:29 IN..._15-05-29-679.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:29 INFO SecurityManager: Changing view acls groups to: "
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:29 IN..._15-05-29-679.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:29 INFO SecurityManager: Changing modify acls groups to: "
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:29 IN..._15-05-29-679.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:29 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:29 INFO SecurityManager: SecurityManager: authentication disabled; ui acls disabled; users with view permissions: jalva; groups with view permissions: EMPTY; users with modify permissions: jalva; groups with modify permissions: EMPTY"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:29 IN..._15-05-29-679.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO Utils: Successfully started service \u0027sparkDriver\u0027 on port 54666."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-239.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO SparkEnv: Registering MapOutputTracker"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-263.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: An illegal reflective access operation has occurred"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: An illegal ..._15-05-30-283.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Illegal reflective access by org.apache.spark.unsafe.Platform (file:/C:/Users/jalva/AppData/Local/Coursier/Cache/v1/https/repo1.maven.org/maven2/org/apache/spark/spark-unsafe_2.13/3.5.0/spark-unsafe_2.13-3.5.0.jar) to constructor java.nio.DirectByteBuffer(long,int)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Illegal ref..._15-05-30-288.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Please consider reporting this to the maintainers of org.apache.spark.unsafe.Platform"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Please cons..._15-05-30-288.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Use --illegal-access\u003dwarn to enable warnings of further illegal reflective access operations"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Use --illeg..._15-05-30-289.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: All illegal access operations will be denied in a future release"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: All illegal..._15-05-30-289.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO SparkEnv: Registering BlockManagerMaster"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-297.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO BlockManagerMasterEndpoint: Using org.apache.spark.storage.DefaultTopologyMapper for getting topology information"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-314.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO BlockManagerMasterEndpoint: BlockManagerMasterEndpoint up"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-315.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO SparkEnv: Registering BlockManagerMasterHeartbeat"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-318.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO DiskBlockManager: Created local directory at C:\\Users\\jalva\\AppData\\Local\\Temp\\blockmgr-e61ba433-acf0-4551-9d33-9bd7199a722c"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-341.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO MemoryStore: MemoryStore started with capacity 2.2 GiB"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-368.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO SparkEnv: Registering OutputCommitCoordinator"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-387.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO JettyUtils: Start Jetty 0.0.0.0:4040 for SparkUI"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-500.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 WARN Utils: Service \u0027SparkUI\u0027 could not bind on port 4040. Attempting port 4041."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 WA..._15-05-30-543.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO Utils: Successfully started service \u0027SparkUI\u0027 on port 4041."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-556.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.18 15:05:30 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.hover(WorkspaceLspService.scala:438)
	scala.meta.metals.lsp.DelegatingScalaService.hover(DelegatingScalaService.scala:82)
	jdk.internal.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.Compilers.withPCAndAdjustLsp(Compilers.scala:1340)
	at scala.meta.internal.metals.Compilers.hover(Compilers.scala:885)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$hover$1(MetalsLspService.scala:999)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.hover(MetalsLspService.scala:997)
	at scala.meta.internal.metals.WorkspaceLspService.hover(WorkspaceLspService.scala:438)
	at scala.meta.metals.lsp.DelegatingScalaService.hover(DelegatingScalaService.scala:82)
	at jdk.internal.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 28 more

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO Executor: Starting executor ID driver on host host.docker.internal"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-643.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO Executor: OS info Windows 11, 10.0, amd64"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-644.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO Executor: Java version 11.0.24"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-644.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO Executor: Starting executor with user classpath (userClassPathFirst \u003d false): \u0027\u0027"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-650.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO Executor: Created or updated repl class loader org.apache.spark.util.MutableURLClassLoader@7e9f2c32 for default."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-651.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO Utils: Successfully started service \u0027org.apache.spark.network.netty.NettyBlockTransferService\u0027 on port 54717."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-673.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO NettyBlockTransferService: Server created on host.docker.internal:54717"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-673.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO BlockManager: Using org.apache.spark.storage.RandomBlockReplicationPolicy for block replication policy"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-674.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO BlockManagerMaster: Registering BlockManager BlockManagerId(driver, host.docker.internal, 54717, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-681.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO BlockManagerMasterEndpoint: Registering block manager host.docker.internal:54717 with 2.2 GiB RAM, BlockManagerId(driver, host.docker.internal, 54717, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-684.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO BlockManagerMaster: Registered BlockManager BlockManagerId(driver, host.docker.internal, 54717, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-686.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:30 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:30 INFO BlockManager: Initialized BlockManager: BlockManagerId(driver, host.docker.internal, 54717, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:30 IN..._15-05-30-687.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:37 INFO SparkContext: Invoking stop() from shutdown hook"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:37 IN..._15-05-37-072.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:37 INFO SparkContext: SparkContext is stopping with exitCode 0."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:37 IN..._15-05-37-072.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:37 INFO SparkUI: Stopped Spark web UI at http://host.docker.internal:4041"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:37 IN..._15-05-37-077.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:37 INFO MapOutputTrackerMasterEndpoint: MapOutputTrackerMasterEndpoint stopped!"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:37 IN..._15-05-37-088.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:37 INFO MemoryStore: MemoryStore cleared"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:37 IN..._15-05-37-096.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:37 INFO BlockManager: BlockManager stopped"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:37 IN..._15-05-37-096.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:37 INFO BlockManagerMaster: BlockManagerMaster stopped"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:37 IN..._15-05-37-100.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:37 INFO OutputCommitCoordinator$OutputCommitCoordinatorEndpoint: OutputCommitCoordinator stopped!"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:37 IN..._15-05-37-103.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:37 INFO SparkContext: Successfully stopped SparkContext"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:37 IN..._15-05-37-106.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:37 INFO ShutdownHookManager: Shutdown hook called"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:37 IN..._15-05-37-107.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:05:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:05:37 INFO ShutdownHookManager: Deleting directory C:\\Users\\jalva\\AppData\\Local\\Temp\\spark-5465ad5f-a220-4724-b4d0-7d0206eb4f8d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:05:37 IN..._15-05-37-107.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.18 15:05:37 INFO  Canceling debug proxy for [example.Main]
2024.10.18 15:05:37 INFO  Closing debug server tcp://0.0.0.0:54623
2024.10.18 15:07:18 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5' (since 49m 8.597s)
2024.10.18 15:07:19 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.18 15:07:19 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.18 15:07:19 INFO  Starting debug proxy for [example.Main]
2024.10.18 15:07:18 INFO  Loaded expression compiler in 1 millisecond
2024.10.18 15:07:18 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:07:18 WARN  Found duplicate entry jersey-server in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:07:18 WARN  Found duplicate entry jersey-client in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:07:21 INFO  Loaded all sources and classes in 2 seconds
2024.10.18 15:07:21 INFO  Initialized Scala 3 decoder in 0 milliseconds
2024.10.18 15:07:21 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:54736 .
2024.10.18 15:07:21 INFO  Attaching to debuggee VM succeeded.
oct 18, 2024 3:07:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:22 INFO SparkContext: Running Spark version 3.5.0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:22 IN..._15-07-22-383.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:22 INFO SparkContext: OS info Windows 11, 10.0, amd64"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:22 IN..._15-07-22-385.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:22 INFO SparkContext: Java version 11.0.24"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:22 IN..._15-07-22-386.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:22 INFO ResourceUtils: \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:22 IN..._15-07-22-575.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:22 INFO ResourceUtils: No custom resources configured for spark.driver."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:22 IN..._15-07-22-576.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:22 INFO ResourceUtils: \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:22 IN..._15-07-22-576.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:22 INFO SparkContext: Submitted application: spark-javi"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:22 IN..._15-07-22-576.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:22 INFO ResourceProfile: Default ResourceProfile created, executor resources: Map(cores -\u003e name: cores, amount: 1, script: , vendor: , memory -\u003e name: memory, amount: 1024, script: , vendor: , offHeap -\u003e name: offHeap, amount: 0, script: , vendor: ), task resources: Map(cpus -\u003e name: cpus, amount: 1.0)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:22 IN..._15-07-22-602.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:22 INFO ResourceProfile: Limiting resource is cpu"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:22 IN..._15-07-22-606.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:22 INFO ResourceProfileManager: Added ResourceProfile id: 0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:22 IN..._15-07-22-606.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:22 INFO SecurityManager: Changing view acls to: jalva"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:22 IN..._15-07-22-656.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:22 INFO SecurityManager: Changing modify acls to: jalva"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:22 IN..._15-07-22-656.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:22 INFO SecurityManager: Changing view acls groups to: "
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:22 IN..._15-07-22-656.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:22 INFO SecurityManager: Changing modify acls groups to: "
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:22 IN..._15-07-22-657.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:22 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:22 INFO SecurityManager: SecurityManager: authentication disabled; ui acls disabled; users with view permissions: jalva; groups with view permissions: EMPTY; users with modify permissions: jalva; groups with modify permissions: EMPTY"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:22 IN..._15-07-22-657.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO Utils: Successfully started service \u0027sparkDriver\u0027 on port 54774."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-205.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO SparkEnv: Registering MapOutputTracker"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-225.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: An illegal reflective access operation has occurred"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: An illegal ..._15-07-23-241.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Illegal reflective access by org.apache.spark.unsafe.Platform (file:/C:/Users/jalva/AppData/Local/Coursier/Cache/v1/https/repo1.maven.org/maven2/org/apache/spark/spark-unsafe_2.13/3.5.0/spark-unsafe_2.13-3.5.0.jar) to constructor java.nio.DirectByteBuffer(long,int)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Illegal ref..._15-07-23-241.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Please consider reporting this to the maintainers of org.apache.spark.unsafe.Platform"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Please cons..._15-07-23-241.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Use --illegal-access\u003dwarn to enable warnings of further illegal reflective access operations"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Use --illeg..._15-07-23-242.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: All illegal access operations will be denied in a future release"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: All illegal..._15-07-23-242.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO SparkEnv: Registering BlockManagerMaster"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-251.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO BlockManagerMasterEndpoint: Using org.apache.spark.storage.DefaultTopologyMapper for getting topology information"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-266.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO BlockManagerMasterEndpoint: BlockManagerMasterEndpoint up"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-267.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO SparkEnv: Registering BlockManagerMasterHeartbeat"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-270.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO DiskBlockManager: Created local directory at C:\\Users\\jalva\\AppData\\Local\\Temp\\blockmgr-8dd60404-d8da-4a14-8391-909c73ab6fdc"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-297.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO MemoryStore: MemoryStore started with capacity 2.2 GiB"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-333.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO SparkEnv: Registering OutputCommitCoordinator"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-347.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO JettyUtils: Start Jetty 0.0.0.0:4040 for SparkUI"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-454.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 WARN Utils: Service \u0027SparkUI\u0027 could not bind on port 4040. Attempting port 4041."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 WA..._15-07-23-496.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO Utils: Successfully started service \u0027SparkUI\u0027 on port 4041."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-506.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO Executor: Starting executor ID driver on host host.docker.internal"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-593.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO Executor: OS info Windows 11, 10.0, amd64"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-594.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO Executor: Java version 11.0.24"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-594.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO Executor: Starting executor with user classpath (userClassPathFirst \u003d false): \u0027\u0027"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-600.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO Executor: Created or updated repl class loader org.apache.spark.util.MutableURLClassLoader@7e9f2c32 for default."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-600.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO Utils: Successfully started service \u0027org.apache.spark.network.netty.NettyBlockTransferService\u0027 on port 54825."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-628.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO NettyBlockTransferService: Server created on host.docker.internal:54825"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-630.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO BlockManager: Using org.apache.spark.storage.RandomBlockReplicationPolicy for block replication policy"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-631.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO BlockManagerMaster: Registering BlockManager BlockManagerId(driver, host.docker.internal, 54825, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-637.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO BlockManagerMasterEndpoint: Registering block manager host.docker.internal:54825 with 2.2 GiB RAM, BlockManagerId(driver, host.docker.internal, 54825, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-640.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO BlockManagerMaster: Registered BlockManager BlockManagerId(driver, host.docker.internal, 54825, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-642.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO BlockManager: Initialized BlockManager: BlockManagerId(driver, host.docker.internal, 54825, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-642.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO SparkContext: Invoking stop() from shutdown hook"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-957.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO SparkContext: SparkContext is stopping with exitCode 0."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-958.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO SparkUI: Stopped Spark web UI at http://host.docker.internal:4041"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-959.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO MapOutputTrackerMasterEndpoint: MapOutputTrackerMasterEndpoint stopped!"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-972.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO MemoryStore: MemoryStore cleared"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-980.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO BlockManager: BlockManager stopped"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-980.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO BlockManagerMaster: BlockManagerMaster stopped"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-985.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO OutputCommitCoordinator$OutputCommitCoordinatorEndpoint: OutputCommitCoordinator stopped!"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-989.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO SparkContext: Successfully stopped SparkContext"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-994.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO ShutdownHookManager: Shutdown hook called"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-994.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:23 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:23 INFO ShutdownHookManager: Deleting directory C:\\Users\\jalva\\AppData\\Local\\Temp\\spark-2202928c-65f7-453c-b2a5-35c98314af16"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:23 IN..._15-07-23-994.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.18 15:07:24 INFO  Canceling debug proxy for [example.Main]
2024.10.18 15:07:24 INFO  Closing debug server tcp://0.0.0.0:54733
2024.10.18 15:07:33 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5' (since 49m 22.869s)
2024.10.18 15:07:33 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.18 15:07:33 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.18 15:07:33 INFO  Starting debug proxy for [example.Main]
2024.10.18 15:07:33 INFO  Loaded expression compiler in 1 millisecond
2024.10.18 15:07:33 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:07:33 WARN  Found duplicate entry jersey-server in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:07:33 WARN  Found duplicate entry jersey-client in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:07:35 INFO  Loaded all sources and classes in 2 seconds
2024.10.18 15:07:35 INFO  Initialized Scala 3 decoder in 0 milliseconds
2024.10.18 15:07:35 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:54830 .
2024.10.18 15:07:35 INFO  Attaching to debuggee VM succeeded.
oct 18, 2024 3:07:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:36 INFO SparkContext: Running Spark version 3.5.0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:36 IN..._15-07-36-930.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:36 INFO SparkContext: OS info Windows 11, 10.0, amd64"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:36 IN..._15-07-36-932.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:36 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:36 INFO SparkContext: Java version 11.0.24"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:36 IN..._15-07-36-932.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO ResourceUtils: \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-131.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO ResourceUtils: No custom resources configured for spark.driver."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-132.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO ResourceUtils: \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-132.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO SparkContext: Submitted application: spark-javi"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-132.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO ResourceProfile: Default ResourceProfile created, executor resources: Map(cores -\u003e name: cores, amount: 1, script: , vendor: , memory -\u003e name: memory, amount: 1024, script: , vendor: , offHeap -\u003e name: offHeap, amount: 0, script: , vendor: ), task resources: Map(cpus -\u003e name: cpus, amount: 1.0)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-155.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO ResourceProfile: Limiting resource is cpu"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-159.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO ResourceProfileManager: Added ResourceProfile id: 0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-160.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO SecurityManager: Changing view acls to: jalva"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-209.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO SecurityManager: Changing modify acls to: jalva"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-211.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO SecurityManager: Changing view acls groups to: "
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-211.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO SecurityManager: Changing modify acls groups to: "
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-211.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO SecurityManager: SecurityManager: authentication disabled; ui acls disabled; users with view permissions: jalva; groups with view permissions: EMPTY; users with modify permissions: jalva; groups with modify permissions: EMPTY"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-211.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO Utils: Successfully started service \u0027sparkDriver\u0027 on port 54866."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-739.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO SparkEnv: Registering MapOutputTracker"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-760.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: An illegal reflective access operation has occurred"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: An illegal ..._15-07-37-777.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Illegal reflective access by org.apache.spark.unsafe.Platform (file:/C:/Users/jalva/AppData/Local/Coursier/Cache/v1/https/repo1.maven.org/maven2/org/apache/spark/spark-unsafe_2.13/3.5.0/spark-unsafe_2.13-3.5.0.jar) to constructor java.nio.DirectByteBuffer(long,int)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Illegal ref..._15-07-37-777.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Please consider reporting this to the maintainers of org.apache.spark.unsafe.Platform"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Please cons..._15-07-37-777.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Use --illegal-access\u003dwarn to enable warnings of further illegal reflective access operations"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Use --illeg..._15-07-37-777.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: All illegal access operations will be denied in a future release"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: All illegal..._15-07-37-778.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO SparkEnv: Registering BlockManagerMaster"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-788.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO BlockManagerMasterEndpoint: Using org.apache.spark.storage.DefaultTopologyMapper for getting topology information"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-805.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO BlockManagerMasterEndpoint: BlockManagerMasterEndpoint up"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-806.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO SparkEnv: Registering BlockManagerMasterHeartbeat"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-809.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO DiskBlockManager: Created local directory at C:\\Users\\jalva\\AppData\\Local\\Temp\\blockmgr-9d3d92d7-3b63-4cc4-9ecb-6e9e35075ca0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-831.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO MemoryStore: MemoryStore started with capacity 2.2 GiB"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-855.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO SparkEnv: Registering OutputCommitCoordinator"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-871.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:37 INFO JettyUtils: Start Jetty 0.0.0.0:4040 for SparkUI"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:37 IN..._15-07-37-977.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 WARN Utils: Service \u0027SparkUI\u0027 could not bind on port 4040. Attempting port 4041."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 WA..._15-07-38-017.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO Utils: Successfully started service \u0027SparkUI\u0027 on port 4041."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-029.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO Executor: Starting executor ID driver on host host.docker.internal"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-114.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO Executor: OS info Windows 11, 10.0, amd64"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-115.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO Executor: Java version 11.0.24"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-115.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO Executor: Starting executor with user classpath (userClassPathFirst \u003d false): \u0027\u0027"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-120.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO Executor: Created or updated repl class loader org.apache.spark.util.MutableURLClassLoader@7e9f2c32 for default."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-121.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO Utils: Successfully started service \u0027org.apache.spark.network.netty.NettyBlockTransferService\u0027 on port 54918."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-145.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO NettyBlockTransferService: Server created on host.docker.internal:54918"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-146.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO BlockManager: Using org.apache.spark.storage.RandomBlockReplicationPolicy for block replication policy"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-147.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO BlockManagerMaster: Registering BlockManager BlockManagerId(driver, host.docker.internal, 54918, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-154.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO BlockManagerMasterEndpoint: Registering block manager host.docker.internal:54918 with 2.2 GiB RAM, BlockManagerId(driver, host.docker.internal, 54918, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-159.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO BlockManagerMaster: Registered BlockManager BlockManagerId(driver, host.docker.internal, 54918, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-161.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO BlockManager: Initialized BlockManager: BlockManagerId(driver, host.docker.internal, 54918, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-162.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO SparkContext: Invoking stop() from shutdown hook"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-457.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO SparkContext: SparkContext is stopping with exitCode 0."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-459.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO SparkUI: Stopped Spark web UI at http://host.docker.internal:4041"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-461.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO MapOutputTrackerMasterEndpoint: MapOutputTrackerMasterEndpoint stopped!"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-473.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO MemoryStore: MemoryStore cleared"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-481.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO BlockManager: BlockManager stopped"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-482.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO BlockManagerMaster: BlockManagerMaster stopped"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-485.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO OutputCommitCoordinator$OutputCommitCoordinatorEndpoint: OutputCommitCoordinator stopped!"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-489.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO SparkContext: Successfully stopped SparkContext"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-493.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO ShutdownHookManager: Shutdown hook called"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-493.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:38 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:38 INFO ShutdownHookManager: Deleting directory C:\\Users\\jalva\\AppData\\Local\\Temp\\spark-f940b4fa-c352-4e56-b1ee-931a15ff67a5"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:38 IN..._15-07-38-495.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.18 15:07:38 INFO  Canceling debug proxy for [example.Main]
2024.10.18 15:07:38 INFO  Closing debug server tcp://0.0.0.0:54827
2024.10.18 15:07:43 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5' (since 49m 32.853s)
2024.10.18 15:07:43 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.18 15:07:43 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.18 15:07:43 INFO  Starting debug proxy for [example.Main]
2024.10.18 15:07:43 INFO  Loaded expression compiler in 0 milliseconds
2024.10.18 15:07:43 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:07:43 WARN  Found duplicate entry jersey-server in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:07:43 WARN  Found duplicate entry jersey-client in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:07:45 INFO  Loaded all sources and classes in 2 seconds
2024.10.18 15:07:45 INFO  Initialized Scala 3 decoder in 0 milliseconds
2024.10.18 15:07:45 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:54926 .
2024.10.18 15:07:45 INFO  Attaching to debuggee VM succeeded.
oct 18, 2024 3:07:46 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:46 INFO SparkContext: Running Spark version 3.5.0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:46 IN..._15-07-46-900.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:46 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:46 INFO SparkContext: OS info Windows 11, 10.0, amd64"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:46 IN..._15-07-46-902.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:46 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:46 INFO SparkContext: Java version 11.0.24"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:46 IN..._15-07-46-903.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO ResourceUtils: \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-080.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO ResourceUtils: No custom resources configured for spark.driver."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-080.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO ResourceUtils: \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-081.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO SparkContext: Submitted application: spark-javi"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-081.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO ResourceProfile: Default ResourceProfile created, executor resources: Map(cores -\u003e name: cores, amount: 1, script: , vendor: , memory -\u003e name: memory, amount: 1024, script: , vendor: , offHeap -\u003e name: offHeap, amount: 0, script: , vendor: ), task resources: Map(cpus -\u003e name: cpus, amount: 1.0)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-102.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO ResourceProfile: Limiting resource is cpu"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-106.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO ResourceProfileManager: Added ResourceProfile id: 0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-107.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO SecurityManager: Changing view acls to: jalva"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-156.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO SecurityManager: Changing modify acls to: jalva"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-157.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO SecurityManager: Changing view acls groups to: "
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-157.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO SecurityManager: Changing modify acls groups to: "
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-157.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO SecurityManager: SecurityManager: authentication disabled; ui acls disabled; users with view permissions: jalva; groups with view permissions: EMPTY; users with modify permissions: jalva; groups with modify permissions: EMPTY"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-157.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO Utils: Successfully started service \u0027sparkDriver\u0027 on port 54962."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-710.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO SparkEnv: Registering MapOutputTracker"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-730.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: An illegal reflective access operation has occurred"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: An illegal ..._15-07-47-746.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Illegal reflective access by org.apache.spark.unsafe.Platform (file:/C:/Users/jalva/AppData/Local/Coursier/Cache/v1/https/repo1.maven.org/maven2/org/apache/spark/spark-unsafe_2.13/3.5.0/spark-unsafe_2.13-3.5.0.jar) to constructor java.nio.DirectByteBuffer(long,int)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Illegal ref..._15-07-47-746.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Please consider reporting this to the maintainers of org.apache.spark.unsafe.Platform"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Please cons..._15-07-47-747.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Use --illegal-access\u003dwarn to enable warnings of further illegal reflective access operations"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Use --illeg..._15-07-47-747.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: All illegal access operations will be denied in a future release"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: All illegal..._15-07-47-747.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO SparkEnv: Registering BlockManagerMaster"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-755.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO BlockManagerMasterEndpoint: Using org.apache.spark.storage.DefaultTopologyMapper for getting topology information"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-771.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO BlockManagerMasterEndpoint: BlockManagerMasterEndpoint up"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-772.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO SparkEnv: Registering BlockManagerMasterHeartbeat"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-774.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO DiskBlockManager: Created local directory at C:\\Users\\jalva\\AppData\\Local\\Temp\\blockmgr-5bbc31c6-72f7-436a-8a98-35c3d0b25d32"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-793.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO MemoryStore: MemoryStore started with capacity 2.2 GiB"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-818.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO SparkEnv: Registering OutputCommitCoordinator"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-831.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO JettyUtils: Start Jetty 0.0.0.0:4040 for SparkUI"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-942.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 WARN Utils: Service \u0027SparkUI\u0027 could not bind on port 4040. Attempting port 4041."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 WA..._15-07-47-984.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:47 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:47 INFO Utils: Successfully started service \u0027SparkUI\u0027 on port 4041."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:47 IN..._15-07-47-995.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO Executor: Starting executor ID driver on host host.docker.internal"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-080.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO Executor: OS info Windows 11, 10.0, amd64"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-081.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO Executor: Java version 11.0.24"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-081.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO Executor: Starting executor with user classpath (userClassPathFirst \u003d false): \u0027\u0027"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-087.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO Executor: Created or updated repl class loader org.apache.spark.util.MutableURLClassLoader@7e9f2c32 for default."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-088.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO Utils: Successfully started service \u0027org.apache.spark.network.netty.NettyBlockTransferService\u0027 on port 55013."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-113.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO NettyBlockTransferService: Server created on host.docker.internal:55013"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-114.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO BlockManager: Using org.apache.spark.storage.RandomBlockReplicationPolicy for block replication policy"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-115.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO BlockManagerMaster: Registering BlockManager BlockManagerId(driver, host.docker.internal, 55013, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-121.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO BlockManagerMasterEndpoint: Registering block manager host.docker.internal:55013 with 2.2 GiB RAM, BlockManagerId(driver, host.docker.internal, 55013, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-126.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO BlockManagerMaster: Registered BlockManager BlockManagerId(driver, host.docker.internal, 55013, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-128.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO BlockManager: Initialized BlockManager: BlockManagerId(driver, host.docker.internal, 55013, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-129.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO SparkContext: Invoking stop() from shutdown hook"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-427.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO SparkContext: SparkContext is stopping with exitCode 0."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-427.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO SparkUI: Stopped Spark web UI at http://host.docker.internal:4041"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-431.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO MapOutputTrackerMasterEndpoint: MapOutputTrackerMasterEndpoint stopped!"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-443.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO MemoryStore: MemoryStore cleared"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-452.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO BlockManager: BlockManager stopped"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-452.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO BlockManagerMaster: BlockManagerMaster stopped"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-456.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO OutputCommitCoordinator$OutputCommitCoordinatorEndpoint: OutputCommitCoordinator stopped!"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-460.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO SparkContext: Successfully stopped SparkContext"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-464.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO ShutdownHookManager: Shutdown hook called"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-465.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:07:48 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:07:48 INFO ShutdownHookManager: Deleting directory C:\\Users\\jalva\\AppData\\Local\\Temp\\spark-0cb8dbb8-6be0-4b45-800e-d6b8fec6e3cd"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:07:48 IN..._15-07-48-465.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.18 15:07:48 INFO  Canceling debug proxy for [example.Main]
2024.10.18 15:07:48 INFO  Closing debug server tcp://0.0.0.0:54923
2024.10.18 15:08:09 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5' (since 49m 58.753s)
2024.10.18 15:08:09 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.18 15:08:09 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.18 15:08:09 INFO  Starting debug proxy for [example.Main]
2024.10.18 15:08:09 INFO  Loaded expression compiler in 1 millisecond
2024.10.18 15:08:09 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:08:09 WARN  Found duplicate entry jersey-server in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:08:09 WARN  Found duplicate entry jersey-client in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:08:11 INFO  Loaded all sources and classes in 2 seconds
2024.10.18 15:08:11 INFO  Initialized Scala 3 decoder in 0 milliseconds
2024.10.18 15:08:11 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:55021 .
2024.10.18 15:08:11 INFO  Attaching to debuggee VM succeeded.
oct 18, 2024 3:08:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:12 INFO SparkContext: Running Spark version 3.5.0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:12 IN..._15-08-12-909.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:12 INFO SparkContext: OS info Windows 11, 10.0, amd64"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:12 IN..._15-08-12-912.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:12 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:12 INFO SparkContext: Java version 11.0.24"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:12 IN..._15-08-12-912.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO ResourceUtils: \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-102.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO ResourceUtils: No custom resources configured for spark.driver."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-102.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO ResourceUtils: \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-103.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO SparkContext: Submitted application: spark-javi"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-103.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO ResourceProfile: Default ResourceProfile created, executor resources: Map(cores -\u003e name: cores, amount: 1, script: , vendor: , memory -\u003e name: memory, amount: 1024, script: , vendor: , offHeap -\u003e name: offHeap, amount: 0, script: , vendor: ), task resources: Map(cpus -\u003e name: cpus, amount: 1.0)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-122.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO ResourceProfile: Limiting resource is cpu"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-125.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO ResourceProfileManager: Added ResourceProfile id: 0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-125.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO SecurityManager: Changing view acls to: jalva"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-175.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO SecurityManager: Changing modify acls to: jalva"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-175.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO SecurityManager: Changing view acls groups to: "
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-176.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO SecurityManager: Changing modify acls groups to: "
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-177.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO SecurityManager: SecurityManager: authentication disabled; ui acls disabled; users with view permissions: jalva; groups with view permissions: EMPTY; users with modify permissions: jalva; groups with modify permissions: EMPTY"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-177.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO Utils: Successfully started service \u0027sparkDriver\u0027 on port 55057."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-715.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO SparkEnv: Registering MapOutputTracker"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-734.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: An illegal reflective access operation has occurred"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: An illegal ..._15-08-13-750.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Illegal reflective access by org.apache.spark.unsafe.Platform (file:/C:/Users/jalva/AppData/Local/Coursier/Cache/v1/https/repo1.maven.org/maven2/org/apache/spark/spark-unsafe_2.13/3.5.0/spark-unsafe_2.13-3.5.0.jar) to constructor java.nio.DirectByteBuffer(long,int)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Illegal ref..._15-08-13-750.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Please consider reporting this to the maintainers of org.apache.spark.unsafe.Platform"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Please cons..._15-08-13-751.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Use --illegal-access\u003dwarn to enable warnings of further illegal reflective access operations"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Use --illeg..._15-08-13-751.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: All illegal access operations will be denied in a future release"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: All illegal..._15-08-13-751.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO SparkEnv: Registering BlockManagerMaster"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-760.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO BlockManagerMasterEndpoint: Using org.apache.spark.storage.DefaultTopologyMapper for getting topology information"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-775.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO BlockManagerMasterEndpoint: BlockManagerMasterEndpoint up"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-776.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO SparkEnv: Registering BlockManagerMasterHeartbeat"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-779.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO DiskBlockManager: Created local directory at C:\\Users\\jalva\\AppData\\Local\\Temp\\blockmgr-5fb9a586-6a5f-4d9e-aaac-ca556343242e"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-799.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO MemoryStore: MemoryStore started with capacity 2.2 GiB"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-824.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO SparkEnv: Registering OutputCommitCoordinator"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-837.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 INFO JettyUtils: Start Jetty 0.0.0.0:4040 for SparkUI"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 IN..._15-08-13-947.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:13 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:13 WARN Utils: Service \u0027SparkUI\u0027 could not bind on port 4040. Attempting port 4041."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:13 WA..._15-08-13-991.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:14 INFO Utils: Successfully started service \u0027SparkUI\u0027 on port 4041."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:14 IN..._15-08-14-003.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:14 INFO Executor: Starting executor ID driver on host host.docker.internal"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:14 IN..._15-08-14-092.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:14 INFO Executor: OS info Windows 11, 10.0, amd64"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:14 IN..._15-08-14-093.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:14 INFO Executor: Java version 11.0.24"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:14 IN..._15-08-14-093.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:14 INFO Executor: Starting executor with user classpath (userClassPathFirst \u003d false): \u0027\u0027"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:14 IN..._15-08-14-098.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:14 INFO Executor: Created or updated repl class loader org.apache.spark.util.MutableURLClassLoader@7e9f2c32 for default."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:14 IN..._15-08-14-099.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:14 INFO Utils: Successfully started service \u0027org.apache.spark.network.netty.NettyBlockTransferService\u0027 on port 55108."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:14 IN..._15-08-14-121.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:14 INFO NettyBlockTransferService: Server created on host.docker.internal:55108"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:14 IN..._15-08-14-121.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:14 INFO BlockManager: Using org.apache.spark.storage.RandomBlockReplicationPolicy for block replication policy"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:14 IN..._15-08-14-123.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:14 INFO BlockManagerMaster: Registering BlockManager BlockManagerId(driver, host.docker.internal, 55108, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:14 IN..._15-08-14-128.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:14 INFO BlockManagerMasterEndpoint: Registering block manager host.docker.internal:55108 with 2.2 GiB RAM, BlockManagerId(driver, host.docker.internal, 55108, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:14 IN..._15-08-14-131.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:14 INFO BlockManagerMaster: Registered BlockManager BlockManagerId(driver, host.docker.internal, 55108, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:14 IN..._15-08-14-133.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:14 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:08:14 INFO BlockManager: Initialized BlockManager: BlockManagerId(driver, host.docker.internal, 55108, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:08:14 IN..._15-08-14-133.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:08:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": [
    "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java"
  ]
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didFocus(WorkspaceLspService.scala:698)
	at scala.meta.metals.lsp.DelegatingScalaService.didFocus(DelegatingScalaService.scala:43)
	at jdk.internal.reflect.GeneratedMethodAccessor27.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.10.18 15:08:37 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.inlayHints(WorkspaceLspService.scala:443)
	scala.meta.metals.lsp.DelegatingScalaService.inlayHints(DelegatingScalaService.scala:213)
	jdk.internal.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

2024.10.18 15:08:37 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:08:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

2024.10.18 15:08:37 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.codeLens(WorkspaceLspService.scala:530)
	scala.meta.metals.lsp.DelegatingScalaService.codeLens(DelegatingScalaService.scala:150)
	jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:08:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$3(MetalsLspService.scala:1225)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$codeLens$2(MetalsLspService.scala:1224)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:08:37 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.documentSymbol(WorkspaceLspService.scala:460)
	scala.meta.metals.lsp.DelegatingScalaService.documentSymbol(DelegatingScalaService.scala:91)
	jdk.internal.reflect.GeneratedMethodAccessor5.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:08:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$documentSymbol$1(MetalsLspService.scala:1055)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 13 more

2024.10.18 15:08:37 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:08:37 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$foldingRange$1(MetalsLspService.scala:1235)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.foldingRange(MetalsLspService.scala:1234)
	at scala.meta.internal.metals.WorkspaceLspService.foldingRange(WorkspaceLspService.scala:535)
	at scala.meta.metals.lsp.DelegatingScalaService.foldingRange(DelegatingScalaService.scala:155)
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 26 more

oct 18, 2024 3:08:39 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 18, 2024 3:09:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:09:00 INFO SparkContext: Invoking stop() from shutdown hook"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:09:00 IN..._15-09-00-697.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:09:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:09:00 INFO SparkContext: SparkContext is stopping with exitCode 0."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:09:00 IN..._15-09-00-698.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:09:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:09:00 INFO SparkUI: Stopped Spark web UI at http://host.docker.internal:4041"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:09:00 IN..._15-09-00-703.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:09:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:09:00 INFO MapOutputTrackerMasterEndpoint: MapOutputTrackerMasterEndpoint stopped!"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:09:00 IN..._15-09-00-726.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:09:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:09:00 INFO MemoryStore: MemoryStore cleared"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:09:00 IN..._15-09-00-738.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:09:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:09:00 INFO BlockManager: BlockManager stopped"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:09:00 IN..._15-09-00-739.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:09:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:09:00 INFO BlockManagerMaster: BlockManagerMaster stopped"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:09:00 IN..._15-09-00-745.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:09:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:09:00 INFO OutputCommitCoordinator$OutputCommitCoordinatorEndpoint: OutputCommitCoordinator stopped!"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:09:00 IN..._15-09-00-749.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:09:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:09:00 INFO SparkContext: Successfully stopped SparkContext"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:09:00 IN..._15-09-00-755.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:09:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:09:00 INFO ShutdownHookManager: Shutdown hook called"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:09:00 IN..._15-09-00-755.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:09:00 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:09:00 INFO ShutdownHookManager: Deleting directory C:\\Users\\jalva\\AppData\\Local\\Temp\\spark-d690eb09-e2ae-4106-8c17-834c7138672c"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:09:00 IN..._15-09-00-755.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.18 15:09:01 INFO  Canceling debug proxy for [example.Main]
2024.10.18 15:09:01 INFO  Closing debug server tcp://0.0.0.0:55018
2024.10.18 15:12:31 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java

Uri: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:756)
	scala.meta.internal.metals.WorkspaceLspService.getServiceForOpt(WorkspaceLspService.scala:308)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:317)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:783)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:128)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:271)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:201)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

oct 18, 2024 3:12:31 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Copyright (c) 2007-2012, Stephen Colebourne \u0026 Michael Nascimento Santos\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * Neither the name of JSR-310 nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage java.time;\n\nimport static java.time.LocalTime.SECONDS_PER_DAY;\nimport static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH;\nimport static java.time.temporal.ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR;\nimport static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_MONTH;\nimport static java.time.temporal.ChronoField.ALIGNED_WEEK_OF_YEAR;\nimport static java.time.temporal.ChronoField.DAY_OF_MONTH;\nimport static java.time.temporal.ChronoField.DAY_OF_YEAR;\nimport static java.time.temporal.ChronoField.EPOCH_DAY;\nimport static java.time.temporal.ChronoField.ERA;\nimport static java.time.temporal.ChronoField.MONTH_OF_YEAR;\nimport static java.time.temporal.ChronoField.PROLEPTIC_MONTH;\nimport static java.time.temporal.ChronoField.YEAR;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.chrono.ChronoLocalDate;\nimport java.time.chrono.IsoEra;\nimport java.time.chrono.IsoChronology;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.Temporal;\nimport java.time.temporal.TemporalAccessor;\nimport java.time.temporal.TemporalAdjuster;\nimport java.time.temporal.TemporalAmount;\nimport java.time.temporal.TemporalField;\nimport java.time.temporal.TemporalQueries;\nimport java.time.temporal.TemporalQuery;\nimport java.time.temporal.TemporalUnit;\nimport java.time.temporal.UnsupportedTemporalTypeException;\nimport java.time.temporal.ValueRange;\nimport java.time.zone.ZoneOffsetTransition;\nimport java.time.zone.ZoneRules;\nimport java.util.Objects;\nimport java.util.stream.LongStream;\nimport java.util.stream.Stream;\n\n/**\n * A date without a time-zone in the ISO-8601 calendar system,\n * such as {@code 2007-12-03}.\n * \u003cp\u003e\n * {@code LocalDate} is an immutable date-time object that represents a date,\n * often viewed as year-month-day. Other date fields, such as day-of-year,\n * day-of-week and week-of-year, can also be accessed.\n * For example, the value \"2nd October 2007\" can be stored in a {@code LocalDate}.\n * \u003cp\u003e\n * This class does not store or represent a time or time-zone.\n * Instead, it is a description of the date, as used for birthdays.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n * \u003cp\u003e\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today\u0027s rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * \u003cp\u003e\n * This is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; use of identity-sensitive operations (including reference equality\n * ({@code \u003d\u003d}), identity hash code, or synchronization) on instances of\n * {@code LocalDate} may have unpredictable results and should be avoided.\n * The {@code equals} method should be used for comparisons.\n *\n * @implSpec\n * This class is immutable and thread-safe.\n *\n * @since 1.8\n */\npublic final class LocalDate\n        implements Temporal, TemporalAdjuster, ChronoLocalDate, Serializable {\n\n    /**\n     * The minimum supported {@code LocalDate}, \u0027-999999999-01-01\u0027.\n     * This could be used by an application as a \"far past\" date.\n     */\n    public static final LocalDate MIN \u003d LocalDate.of(Year.MIN_VALUE, 1, 1);\n    /**\n     * The maximum supported {@code LocalDate}, \u0027+999999999-12-31\u0027.\n     * This could be used by an application as a \"far future\" date.\n     */\n    public static final LocalDate MAX \u003d LocalDate.of(Year.MAX_VALUE, 12, 31);\n    /**\n     * The epoch year {@code LocalDate}, \u00271970-01-01\u0027.\n     */\n    public static final LocalDate EPOCH \u003d LocalDate.of(1970, 1, 1);\n\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID \u003d 2942565459149668126L;\n    /**\n     * The number of days in a 400 year cycle.\n     */\n    private static final int DAYS_PER_CYCLE \u003d 146097;\n    /**\n     * The number of days from year zero to year 1970.\n     * There are five 400 year cycles from year zero to 2000.\n     * There are 7 leap years from 1970 to 2000.\n     */\n    static final long DAYS_0000_TO_1970 \u003d (DAYS_PER_CYCLE * 5L) - (30L * 365L + 7L);\n\n    /**\n     * The year.\n     */\n    private final int year;\n    /**\n     * The month-of-year.\n     */\n    private final short month;\n    /**\n     * The day-of-month.\n     */\n    private final short day;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date from the system clock in the default time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#systemDefaultZone() system clock} in the default\n     * time-zone to obtain the current date.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return the current date using the system clock and default time-zone, not null\n     */\n    public static LocalDate now() {\n        return now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date from the system clock in the specified time-zone.\n     * \u003cp\u003e\n     * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * \u003cp\u003e\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the current date using the system clock, not null\n     */\n    public static LocalDate now(ZoneId zone) {\n        return now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date from the specified clock.\n     * \u003cp\u003e\n     * This will query the specified clock to obtain the current date - today.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param clock  the clock to use, not null\n     * @return the current date, not null\n     */\n    public static LocalDate now(Clock clock) {\n        Objects.requireNonNull(clock, \"clock\");\n        final Instant now \u003d clock.instant();  // called once\n        return ofInstant(now, clock.getZone());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a year, month and day.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDate of(int year, Month month, int dayOfMonth) {\n        YEAR.checkValidValue(year);\n        Objects.requireNonNull(month, \"month\");\n        DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        return create(year, month.getValue(), dayOfMonth);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDate} from a year, month and day.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public static LocalDate of(int year, int month, int dayOfMonth) {\n        YEAR.checkValidValue(year);\n        MONTH_OF_YEAR.checkValidValue(month);\n        DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        return create(year, month, dayOfMonth);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a year and day-of-year.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified year and day-of-year.\n     * The day-of-year must be valid for the year, otherwise an exception will be thrown.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param dayOfYear  the day-of-year to represent, from 1 to 366\n     * @return the local date, not null\n     * @throws DateTimeException if the value of any field is out of range,\n     *  or if the day-of-year is invalid for the year\n     */\n    public static LocalDate ofYearDay(int year, int dayOfYear) {\n        YEAR.checkValidValue(year);\n        DAY_OF_YEAR.checkValidValue(dayOfYear);\n        boolean leap \u003d IsoChronology.INSTANCE.isLeapYear(year);\n        if (dayOfYear \u003d\u003d 366 \u0026\u0026 leap \u003d\u003d false) {\n            throw new DateTimeException(\"Invalid date \u0027DayOfYear 366\u0027 as \u0027\" + year + \"\u0027 is not a leap year\");\n        }\n        Month moy \u003d Month.of((dayOfYear - 1) / 31 + 1);\n        int monthEnd \u003d moy.firstDayOfYear(leap) + moy.length(leap) - 1;\n        if (dayOfYear \u003e monthEnd) {\n            moy \u003d moy.plus(1);\n        }\n        int dom \u003d dayOfYear - moy.firstDayOfYear(leap) + 1;\n        return new LocalDate(year, moy.getValue(), dom);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from an {@code Instant} and zone ID.\n     * \u003cp\u003e\n     * This creates a local date based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date.\n     *\n     * @param instant  the instant to create the date from, not null\n     * @param zone  the time-zone, which may be an offset, not null\n     * @return the local date, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     * @since 9\n     */\n    public static LocalDate ofInstant(Instant instant, ZoneId zone) {\n        Objects.requireNonNull(instant, \"instant\");\n        Objects.requireNonNull(zone, \"zone\");\n        ZoneRules rules \u003d zone.getRules();\n        ZoneOffset offset \u003d rules.getOffset(instant);\n        long localSecond \u003d instant.getEpochSecond() + offset.getTotalSeconds();\n        long localEpochDay \u003d Math.floorDiv(localSecond, SECONDS_PER_DAY);\n        return ofEpochDay(localEpochDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from the epoch day count.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate} with the specified epoch-day.\n     * The {@link ChronoField#EPOCH_DAY EPOCH_DAY} is a simple incrementing count\n     * of days where day 0 is 1970-01-01. Negative numbers represent earlier days.\n     *\n     * @param epochDay  the Epoch Day to convert, based on the epoch 1970-01-01\n     * @return the local date, not null\n     * @throws DateTimeException if the epoch day exceeds the supported date range\n     */\n    public static LocalDate ofEpochDay(long epochDay) {\n        EPOCH_DAY.checkValidValue(epochDay);\n        long zeroDay \u003d epochDay + DAYS_0000_TO_1970;\n        // find the march-based year\n        zeroDay -\u003d 60;  // adjust to 0000-03-01 so leap day is at end of four year cycle\n        long adjust \u003d 0;\n        if (zeroDay \u003c 0) {\n            // adjust negative years to positive for calculation\n            long adjustCycles \u003d (zeroDay + 1) / DAYS_PER_CYCLE - 1;\n            adjust \u003d adjustCycles * 400;\n            zeroDay +\u003d -adjustCycles * DAYS_PER_CYCLE;\n        }\n        long yearEst \u003d (400 * zeroDay + 591) / DAYS_PER_CYCLE;\n        long doyEst \u003d zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);\n        if (doyEst \u003c 0) {\n            // fix estimate\n            yearEst--;\n            doyEst \u003d zeroDay - (365 * yearEst + yearEst / 4 - yearEst / 100 + yearEst / 400);\n        }\n        yearEst +\u003d adjust;  // reset any negative year\n        int marchDoy0 \u003d (int) doyEst;\n\n        // convert march-based values back to january-based\n        int marchMonth0 \u003d (marchDoy0 * 5 + 2) / 153;\n        int month \u003d (marchMonth0 + 2) % 12 + 1;\n        int dom \u003d marchDoy0 - (marchMonth0 * 306 + 5) / 10 + 1;\n        yearEst +\u003d marchMonth0 / 10;\n\n        // check year now we are certain it is correct\n        int year \u003d YEAR.checkValidIntValue(yearEst);\n        return new LocalDate(year, month, dom);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a temporal object.\n     * \u003cp\u003e\n     * This obtains a local date based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code LocalDate}.\n     * \u003cp\u003e\n     * The conversion uses the {@link TemporalQueries#localDate()} query, which relies\n     * on extracting the {@link ChronoField#EPOCH_DAY EPOCH_DAY} field.\n     * \u003cp\u003e\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code LocalDate::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the local date, not null\n     * @throws DateTimeException if unable to convert to a {@code LocalDate}\n     */\n    public static LocalDate from(TemporalAccessor temporal) {\n        Objects.requireNonNull(temporal, \"temporal\");\n        LocalDate date \u003d temporal.query(TemporalQueries.localDate());\n        if (date \u003d\u003d null) {\n            throw new DateTimeException(\"Unable to obtain LocalDate from TemporalAccessor: \" +\n                    temporal + \" of type \" + temporal.getClass().getName());\n        }\n        return date;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@code LocalDate} from a text string such as {@code 2007-12-03}.\n     * \u003cp\u003e\n     * The string must represent a valid date and is parsed using\n     * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_DATE}.\n     *\n     * @param text  the text to parse such as \"2007-12-03\", not null\n     * @return the parsed local date, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDate parse(CharSequence text) {\n        return parse(text, DateTimeFormatter.ISO_LOCAL_DATE);\n    }\n\n    /**\n     * Obtains an instance of {@code LocalDate} from a text string using a specific formatter.\n     * \u003cp\u003e\n     * The text is parsed using the formatter, returning a date.\n     *\n     * @param text  the text to parse, not null\n     * @param formatter  the formatter to use, not null\n     * @return the parsed local date, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    public static LocalDate parse(CharSequence text, DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, LocalDate::from);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a local date from the year, month and day fields.\n     *\n     * @param year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, from 1 to 12, validated\n     * @param dayOfMonth  the day-of-month to represent, validated from 1 to 31\n     * @return the local date, not null\n     * @throws DateTimeException if the day-of-month is invalid for the month-year\n     */\n    private static LocalDate create(int year, int month, int dayOfMonth) {\n        if (dayOfMonth \u003e 28) {\n            int dom \u003d 31;\n            switch (month) {\n                case 2:\n                    dom \u003d (IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n                    break;\n                case 4:\n                case 6:\n                case 9:\n                case 11:\n                    dom \u003d 30;\n                    break;\n            }\n            if (dayOfMonth \u003e dom) {\n                if (dayOfMonth \u003d\u003d 29) {\n                    throw new DateTimeException(\"Invalid date \u0027February 29\u0027 as \u0027\" + year + \"\u0027 is not a leap year\");\n                } else {\n                    throw new DateTimeException(\"Invalid date \u0027\" + Month.of(month).name() + \" \" + dayOfMonth + \"\u0027\");\n                }\n            }\n        }\n        return new LocalDate(year, month, dayOfMonth);\n    }\n\n    /**\n     * Resolves the date, resolving days past the end of month.\n     *\n     * @param year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, validated from 1 to 12\n     * @param day  the day-of-month to represent, validated from 1 to 31\n     * @return the resolved date, not null\n     */\n    private static LocalDate resolvePreviousValid(int year, int month, int day) {\n        switch (month) {\n            case 2:\n                day \u003d Math.min(day, IsoChronology.INSTANCE.isLeapYear(year) ? 29 : 28);\n                break;\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                day \u003d Math.min(day, 30);\n                break;\n        }\n        return new LocalDate(year, month, day);\n    }\n\n    /**\n     * Constructor, previously validated.\n     *\n     * @param year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param month  the month-of-year to represent, not null\n     * @param dayOfMonth  the day-of-month to represent, valid for year-month, from 1 to 31\n     */\n    private LocalDate(int year, int month, int dayOfMonth) {\n        this.year \u003d year;\n        this.month \u003d (short) month;\n        this.day \u003d (short) dayOfMonth;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \u003cp\u003e\n     * This checks if this date can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAY_OF_WEEK}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * \u003cli\u003e{@code DAY_OF_MONTH}\n     * \u003cli\u003e{@code DAY_OF_YEAR}\n     * \u003cli\u003e{@code EPOCH_DAY}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH}\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR}\n     * \u003cli\u003e{@code MONTH_OF_YEAR}\n     * \u003cli\u003e{@code PROLEPTIC_MONTH}\n     * \u003cli\u003e{@code YEAR_OF_ERA}\n     * \u003cli\u003e{@code YEAR}\n     * \u003cli\u003e{@code ERA}\n     * \u003c/ul\u003e\n     * All other {@code ChronoField} instances will return false.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this date, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalField field) {\n        return ChronoLocalDate.super.isSupported(field);\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \u003cp\u003e\n     * This checks if the specified unit can be added to, or subtracted from, this date.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \u003cp\u003e\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAYS}\n     * \u003cli\u003e{@code WEEKS}\n     * \u003cli\u003e{@code MONTHS}\n     * \u003cli\u003e{@code YEARS}\n     * \u003cli\u003e{@code DECADES}\n     * \u003cli\u003e{@code CENTURIES}\n     * \u003cli\u003e{@code MILLENNIA}\n     * \u003cli\u003e{@code ERAS}\n     * \u003c/ul\u003e\n     * All other {@code ChronoUnit} instances will return false.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     */\n    @Override  // override for Javadoc\n    public boolean isSupported(TemporalUnit unit) {\n        return ChronoLocalDate.super.isSupported(unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \u003cp\u003e\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     */\n    @Override\n    public ValueRange range(TemporalField field) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            if (f.isDateBased()) {\n                switch (f) {\n                    case DAY_OF_MONTH: return ValueRange.of(1, lengthOfMonth());\n                    case DAY_OF_YEAR: return ValueRange.of(1, lengthOfYear());\n                    case ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, getMonth() \u003d\u003d Month.FEBRUARY \u0026\u0026 isLeapYear() \u003d\u003d false ? 4 : 5);\n                    case YEAR_OF_ERA:\n                        return (getYear() \u003c\u003d 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n                }\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as an {@code int}.\n     * \u003cp\u003e\n     * This queries this date for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date, except {@code EPOCH_DAY} and {@code PROLEPTIC_MONTH}\n     * which are too large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc and performance\n    public int get(TemporalField field) {\n        if (field instanceof ChronoField) {\n            return get0(field);\n        }\n        return ChronoLocalDate.super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as a {@code long}.\n     * \u003cp\u003e\n     * This queries this date for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link #isSupported(TemporalField) supported fields} will return valid\n     * values based on this date.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long getLong(TemporalField field) {\n        if (field instanceof ChronoField) {\n            if (field \u003d\u003d EPOCH_DAY) {\n                return toEpochDay();\n            }\n            if (field \u003d\u003d PROLEPTIC_MONTH) {\n                return getProlepticMonth();\n            }\n            return get0(field);\n        }\n        return field.getFrom(this);\n    }\n\n    private int get0(TemporalField field) {\n        switch ((ChronoField) field) {\n            case DAY_OF_WEEK: return getDayOfWeek().getValue();\n            case ALIGNED_DAY_OF_WEEK_IN_MONTH: return ((day - 1) % 7) + 1;\n            case ALIGNED_DAY_OF_WEEK_IN_YEAR: return ((getDayOfYear() - 1) % 7) + 1;\n            case DAY_OF_MONTH: return day;\n            case DAY_OF_YEAR: return getDayOfYear();\n            case EPOCH_DAY: throw new UnsupportedTemporalTypeException(\"Invalid field \u0027EpochDay\u0027 for get() method, use getLong() instead\");\n            case ALIGNED_WEEK_OF_MONTH: return ((day - 1) / 7) + 1;\n            case ALIGNED_WEEK_OF_YEAR: return ((getDayOfYear() - 1) / 7) + 1;\n            case MONTH_OF_YEAR: return month;\n            case PROLEPTIC_MONTH: throw new UnsupportedTemporalTypeException(\"Invalid field \u0027ProlepticMonth\u0027 for get() method, use getLong() instead\");\n            case YEAR_OF_ERA: return (year \u003e\u003d 1 ? year : 1 - year);\n            case YEAR: return year;\n            case ERA: return (year \u003e\u003d 1 ? 1 : 0);\n        }\n        throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n    }\n\n    private long getProlepticMonth() {\n        return (year * 12L + month - 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology of this date, which is the ISO calendar system.\n     * \u003cp\u003e\n     * The {@code Chronology} represents the calendar system in use.\n     * The ISO-8601 calendar system is the modern civil calendar system used today\n     * in most of the world. It is equivalent to the proleptic Gregorian calendar\n     * system, in which today\u0027s rules for leap years are applied for all time.\n     *\n     * @return the ISO chronology, not null\n     */\n    @Override\n    public IsoChronology getChronology() {\n        return IsoChronology.INSTANCE;\n    }\n\n    /**\n     * Gets the era applicable at this date.\n     * \u003cp\u003e\n     * The official ISO-8601 standard does not define eras, however {@code IsoChronology} does.\n     * It defines two eras, \u0027CE\u0027 from year one onwards and \u0027BCE\u0027 from year zero backwards.\n     * Since dates before the Julian-Gregorian cutover are not in line with history,\n     * the cutover between \u0027BCE\u0027 and \u0027CE\u0027 is also not aligned with the commonly used\n     * eras, often referred to using \u0027BC\u0027 and \u0027AD\u0027.\n     * \u003cp\u003e\n     * Users of this class should typically ignore this method as it exists primarily\n     * to fulfill the {@link ChronoLocalDate} contract where it is necessary to support\n     * the Japanese calendar system.\n     *\n     * @return the IsoEra applicable at this date, not null\n     */\n    @Override // override for Javadoc\n    public IsoEra getEra() {\n        return (getYear() \u003e\u003d 1 ? IsoEra.CE : IsoEra.BCE);\n    }\n\n    /**\n     * Gets the year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the year.\n     * \u003cp\u003e\n     * The year returned by this method is proleptic as per {@code get(YEAR)}.\n     * To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.\n     *\n     * @return the year, from MIN_YEAR to MAX_YEAR\n     */\n    public int getYear() {\n        return year;\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \u003cp\u003e\n     * This method returns the month as an {@code int} from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link #getMonth()}.\n     *\n     * @return the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    public int getMonthValue() {\n        return month;\n    }\n\n    /**\n     * Gets the month-of-year field using the {@code Month} enum.\n     * \u003cp\u003e\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link Month#getValue() int value}.\n     *\n     * @return the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    public Month getMonth() {\n        return Month.of(month);\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-month.\n     *\n     * @return the day-of-month, from 1 to 31\n     */\n    public int getDayOfMonth() {\n        return day;\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \u003cp\u003e\n     * This method returns the primitive {@code int} value for the day-of-year.\n     *\n     * @return the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    public int getDayOfYear() {\n        return getMonth().firstDayOfYear(isLeapYear()) + day - 1;\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@code DayOfWeek}.\n     * \u003cp\u003e\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what {@code int} values mean.\n     * If you need access to the primitive {@code int} value then the enum\n     * provides the {@link DayOfWeek#getValue() int value}.\n     * \u003cp\u003e\n     * Additional information can be obtained from the {@code DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return the day-of-week, not null\n     */\n    public DayOfWeek getDayOfWeek() {\n        int dow0 \u003d Math.floorMod(toEpochDay() + 3, 7);\n        return DayOfWeek.of(dow0 + 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     * \u003cp\u003e\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     * \u003cp\u003e\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     * \u003cp\u003e\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return true if the year is leap, false otherwise\n     */\n    @Override // override for Javadoc and performance\n    public boolean isLeapYear() {\n        return IsoChronology.INSTANCE.isLeapYear(year);\n    }\n\n    /**\n     * Returns the length of the month represented by this date.\n     * \u003cp\u003e\n     * This returns the length of the month in days.\n     * For example, a date in January would return 31.\n     *\n     * @return the length of the month in days\n     */\n    @Override\n    public int lengthOfMonth() {\n        switch (month) {\n            case 2:\n                return (isLeapYear() ? 29 : 28);\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Returns the length of the year represented by this date.\n     * \u003cp\u003e\n     * This returns the length of the year in days, either 365 or 366.\n     *\n     * @return 366 if the year is leap, 365 otherwise\n     */\n    @Override // override for Javadoc and performance\n    public int lengthOfYear() {\n        return (isLeapYear() ? 366 : 365);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the date adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \u003cp\u003e\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * \u003cp\u003e\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@code TemporalAdjuster} interface,\n     * such as {@link Month} and {@link java.time.MonthDay MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \u003cp\u003e\n     * For example this code returns a date on the last day of July:\n     * \u003cpre\u003e\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result \u003d localDate.with(JULY).with(lastDayOfMonth());\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param adjuster the adjuster to use, not null\n     * @return a {@code LocalDate} based on {@code this} with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate with(TemporalAdjuster adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return (LocalDate) adjuster;\n        }\n        return (LocalDate) adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified field set to a new value.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, changing the specified field can cause the resulting date to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAY_OF_WEEK} -\n     *  Returns a {@code LocalDate} with the specified day-of-week.\n     *  The date is adjusted up to 6 days forward or backward within the boundary\n     *  of a Monday to Sunday week.\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_MONTH} -\n     *  Returns a {@code LocalDate} with the specified aligned-day-of-week.\n     *  The date is adjusted to the specified month-based aligned-day-of-week.\n     *  Aligned weeks are counted such that the first week of a given month starts\n     *  on the first day of that month.\n     *  This may cause the date to be moved up to 6 days into the following month.\n     * \u003cli\u003e{@code ALIGNED_DAY_OF_WEEK_IN_YEAR} -\n     *  Returns a {@code LocalDate} with the specified aligned-day-of-week.\n     *  The date is adjusted to the specified year-based aligned-day-of-week.\n     *  Aligned weeks are counted such that the first week of a given year starts\n     *  on the first day of that year.\n     *  This may cause the date to be moved up to 6 days into the following year.\n     * \u003cli\u003e{@code DAY_OF_MONTH} -\n     *  Returns a {@code LocalDate} with the specified day-of-month.\n     *  The month and year will be unchanged. If the day-of-month is invalid for the\n     *  year and month, then a {@code DateTimeException} is thrown.\n     * \u003cli\u003e{@code DAY_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified day-of-year.\n     *  The year will be unchanged. If the day-of-year is invalid for the\n     *  year, then a {@code DateTimeException} is thrown.\n     * \u003cli\u003e{@code EPOCH_DAY} -\n     *  Returns a {@code LocalDate} with the specified epoch-day.\n     *  This completely replaces the date and is equivalent to {@link #ofEpochDay(long)}.\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_MONTH} -\n     *  Returns a {@code LocalDate} with the specified aligned-week-of-month.\n     *  Aligned weeks are counted such that the first week of a given month starts\n     *  on the first day of that month.\n     *  This adjustment moves the date in whole week chunks to match the specified week.\n     *  The result will have the same day-of-week as this date.\n     *  This may cause the date to be moved into the following month.\n     * \u003cli\u003e{@code ALIGNED_WEEK_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified aligned-week-of-year.\n     *  Aligned weeks are counted such that the first week of a given year starts\n     *  on the first day of that year.\n     *  This adjustment moves the date in whole week chunks to match the specified week.\n     *  The result will have the same day-of-week as this date.\n     *  This may cause the date to be moved into the following year.\n     * \u003cli\u003e{@code MONTH_OF_YEAR} -\n     *  Returns a {@code LocalDate} with the specified month-of-year.\n     *  The year will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code PROLEPTIC_MONTH} -\n     *  Returns a {@code LocalDate} with the specified proleptic-month.\n     *  The day-of-month will be unchanged, unless it would be invalid for the new month\n     *  and year. In that case, the day-of-month is adjusted to the maximum valid value\n     *  for the new month and year.\n     * \u003cli\u003e{@code YEAR_OF_ERA} -\n     *  Returns a {@code LocalDate} with the specified year-of-era.\n     *  The era and month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code YEAR} -\n     *  Returns a {@code LocalDate} with the specified year.\n     *  The month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003cli\u003e{@code ERA} -\n     *  Returns a {@code LocalDate} with the specified era.\n     *  The year-of-era and month will be unchanged. The day-of-month will also be unchanged,\n     *  unless it would be invalid for the new month and year. In that case, the\n     *  day-of-month is adjusted to the maximum valid value for the new month and year.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@code DateTimeException} will be thrown.\n     * \u003cp\u003e\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return a {@code LocalDate} based on {@code this} with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate with(TemporalField field, long newValue) {\n        if (field instanceof ChronoField) {\n            ChronoField f \u003d (ChronoField) field;\n            f.checkValidValue(newValue);\n            switch (f) {\n                case DAY_OF_WEEK: return plusDays(newValue - getDayOfWeek().getValue());\n                case ALIGNED_DAY_OF_WEEK_IN_MONTH: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n                case ALIGNED_DAY_OF_WEEK_IN_YEAR: return plusDays(newValue - getLong(ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                case DAY_OF_MONTH: return withDayOfMonth((int) newValue);\n                case DAY_OF_YEAR: return withDayOfYear((int) newValue);\n                case EPOCH_DAY: return LocalDate.ofEpochDay(newValue);\n                case ALIGNED_WEEK_OF_MONTH: return plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_MONTH));\n                case ALIGNED_WEEK_OF_YEAR: return plusWeeks(newValue - getLong(ALIGNED_WEEK_OF_YEAR));\n                case MONTH_OF_YEAR: return withMonth((int) newValue);\n                case PROLEPTIC_MONTH: return plusMonths(newValue - getProlepticMonth());\n                case YEAR_OF_ERA: return withYear((int) (year \u003e\u003d 1 ? newValue : 1 - newValue));\n                case YEAR: return withYear((int) newValue);\n                case ERA: return (getLong(ERA) \u003d\u003d newValue ? this : withYear(1 - year));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the year altered.\n     * \u003cp\u003e\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return a {@code LocalDate} based on this date with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    public LocalDate withYear(int year) {\n        if (this.year \u003d\u003d year) {\n            return this;\n        }\n        YEAR.checkValidValue(year);\n        return resolvePreviousValid(year, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the month-of-year altered.\n     * \u003cp\u003e\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return a {@code LocalDate} based on this date with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    public LocalDate withMonth(int month) {\n        if (this.month \u003d\u003d month) {\n            return this;\n        }\n        MONTH_OF_YEAR.checkValidValue(month);\n        return resolvePreviousValid(year, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the day-of-month altered.\n     * \u003cp\u003e\n     * If the resulting date is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31\n     * @return a {@code LocalDate} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    public LocalDate withDayOfMonth(int dayOfMonth) {\n        if (this.day \u003d\u003d dayOfMonth) {\n            return this;\n        }\n        return of(year, month, dayOfMonth);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the day-of-year altered.\n     * \u003cp\u003e\n     * If the resulting date is invalid, an exception is thrown.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return a {@code LocalDate} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    public LocalDate withDayOfYear(int dayOfYear) {\n        if (this.getDayOfYear() \u003d\u003d dayOfYear) {\n            return this;\n        }\n        return ofYearDay(year, dayOfYear);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the specified amount added.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free\n     * to implement the addition in any way it wishes, however it typically\n     * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully added.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount to add, not null\n     * @return a {@code LocalDate} based on this date with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate plus(TemporalAmount amountToAdd) {\n        if (amountToAdd instanceof Period) {\n            Period periodToAdd \u003d (Period) amountToAdd;\n            return plusMonths(periodToAdd.toTotalMonths()).plusDays(periodToAdd.getDays());\n        }\n        Objects.requireNonNull(amountToAdd, \"amountToAdd\");\n        return (LocalDate) amountToAdd.addTo(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified amount added.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * In some cases, adding the amount can cause the resulting date to become invalid.\n     * For example, adding one month to 31st January would result in 31st February.\n     * In cases like this, the unit is responsible for resolving the date.\n     * Typically it will choose the previous valid date, which would be the last valid\n     * day of February in this example.\n     * \u003cp\u003e\n     * If the field is a {@link ChronoUnit} then the addition is implemented here.\n     * The supported fields behave as follows:\n     * \u003cul\u003e\n     * \u003cli\u003e{@code DAYS} -\n     *  Returns a {@code LocalDate} with the specified number of days added.\n     *  This is equivalent to {@link #plusDays(long)}.\n     * \u003cli\u003e{@code WEEKS} -\n     *  Returns a {@code LocalDate} with the specified number of weeks added.\n     *  This is equivalent to {@link #plusWeeks(long)} and uses a 7 day week.\n     * \u003cli\u003e{@code MONTHS} -\n     *  Returns a {@code LocalDate} with the specified number of months added.\n     *  This is equivalent to {@link #plusMonths(long)}.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code YEARS} -\n     *  Returns a {@code LocalDate} with the specified number of years added.\n     *  This is equivalent to {@link #plusYears(long)}.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code DECADES} -\n     *  Returns a {@code LocalDate} with the specified number of decades added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 10.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code CENTURIES} -\n     *  Returns a {@code LocalDate} with the specified number of centuries added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 100.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code MILLENNIA} -\n     *  Returns a {@code LocalDate} with the specified number of millennia added.\n     *  This is equivalent to calling {@link #plusYears(long)} with the amount\n     *  multiplied by 1,000.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003cli\u003e{@code ERAS} -\n     *  Returns a {@code LocalDate} with the specified number of eras added.\n     *  Only two eras are supported so the amount must be one, zero or minus one.\n     *  If the amount is non-zero then the year is changed such that the year-of-era\n     *  is unchanged.\n     *  The day-of-month will be unchanged unless it would be invalid for the new\n     *  month and year. In that case, the day-of-month is adjusted to the maximum\n     *  valid value for the new month and year.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * All other {@code ChronoUnit} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * \u003cp\u003e\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToAdd  the amount of the unit to add to the result, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return a {@code LocalDate} based on this date with the specified amount added, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate plus(long amountToAdd, TemporalUnit unit) {\n        if (unit instanceof ChronoUnit) {\n            ChronoUnit f \u003d (ChronoUnit) unit;\n            switch (f) {\n                case DAYS: return plusDays(amountToAdd);\n                case WEEKS: return plusWeeks(amountToAdd);\n                case MONTHS: return plusMonths(amountToAdd);\n                case YEARS: return plusYears(amountToAdd);\n                case DECADES: return plusYears(Math.multiplyExact(amountToAdd, 10));\n                case CENTURIES: return plusYears(Math.multiplyExact(amountToAdd, 100));\n                case MILLENNIA: return plusYears(Math.multiplyExact(amountToAdd, 1000));\n                case ERAS: return with(ERA, Math.addExact(getLong(ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of years added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input years to the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param yearsToAdd  the years to add, may be negative\n     * @return a {@code LocalDate} based on this date with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusYears(long yearsToAdd) {\n        if (yearsToAdd \u003d\u003d 0) {\n            return this;\n        }\n        int newYear \u003d YEAR.checkValidIntValue(year + yearsToAdd);  // safe overflow\n        return resolvePreviousValid(newYear, month, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of months added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eAdd the input months to the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param monthsToAdd  the months to add, may be negative\n     * @return a {@code LocalDate} based on this date with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusMonths(long monthsToAdd) {\n        if (monthsToAdd \u003d\u003d 0) {\n            return this;\n        }\n        long monthCount \u003d year * 12L + (month - 1);\n        long calcMonths \u003d monthCount + monthsToAdd;  // safe overflow\n        int newYear \u003d YEAR.checkValidIntValue(Math.floorDiv(calcMonths, 12));\n        int newMonth \u003d Math.floorMod(calcMonths, 12) + 1;\n        return resolvePreviousValid(newYear, newMonth, day);\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of weeks added.\n     * \u003cp\u003e\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeksToAdd  the weeks to add, may be negative\n     * @return a {@code LocalDate} based on this date with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusWeeks(long weeksToAdd) {\n        return plusDays(Math.multiplyExact(weeksToAdd, 7));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of days added.\n     * \u003cp\u003e\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param daysToAdd  the days to add, may be negative\n     * @return a {@code LocalDate} based on this date with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate plusDays(long daysToAdd) {\n        if (daysToAdd \u003d\u003d 0) {\n            return this;\n        }\n        long dom \u003d day + daysToAdd;\n        if (dom \u003e 0) {\n            if (dom \u003c\u003d 28) {\n                return new LocalDate(year, month, (int) dom);\n            } else if (dom \u003c\u003d 59) { // 59th Jan is 28th Feb, 59th Feb is 31st Mar\n                long monthLen \u003d lengthOfMonth();\n                if (dom \u003c\u003d monthLen) {\n                    return new LocalDate(year, month, (int) dom);\n                } else if (month \u003c 12) {\n                    return new LocalDate(year, month + 1, (int) (dom - monthLen));\n                } else {\n                    YEAR.checkValidValue(year + 1);\n                    return new LocalDate(year + 1, 1, (int) (dom - monthLen));\n                }\n            }\n        }\n\n        long mjDay \u003d Math.addExact(toEpochDay(), daysToAdd);\n        return LocalDate.ofEpochDay(mjDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this date with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the specified amount subtracted.\n     * The amount is typically {@link Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface.\n     * \u003cp\u003e\n     * The calculation is delegated to the amount object by calling\n     * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free\n     * to implement the subtraction in any way it wishes, however it typically\n     * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation\n     * of the amount implementation to determine if it can be successfully subtracted.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount to subtract, not null\n     * @return a {@code LocalDate} based on this date with the subtraction made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate minus(TemporalAmount amountToSubtract) {\n        if (amountToSubtract instanceof Period) {\n            Period periodToSubtract \u003d (Period) amountToSubtract;\n            return minusMonths(periodToSubtract.toTotalMonths()).minusDays(periodToSubtract.getDays());\n        }\n        Objects.requireNonNull(amountToSubtract, \"amountToSubtract\");\n        return (LocalDate) amountToSubtract.subtractFrom(this);\n    }\n\n    /**\n     * Returns a copy of this date with the specified amount subtracted.\n     * \u003cp\u003e\n     * This returns a {@code LocalDate}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \u003cp\u003e\n     * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return a {@code LocalDate} based on this date with the specified amount subtracted, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public LocalDate minus(long amountToSubtract, TemporalUnit unit) {\n        return (amountToSubtract \u003d\u003d Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of years subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the years field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input years from the year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param yearsToSubtract  the years to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusYears(long yearsToSubtract) {\n        return (yearsToSubtract \u003d\u003d Long.MIN_VALUE ? plusYears(Long.MAX_VALUE).plusYears(1) : plusYears(-yearsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of months subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the months field in three steps:\n     * \u003col\u003e\n     * \u003cli\u003eSubtract the input months from the month-of-year field\u003c/li\u003e\n     * \u003cli\u003eCheck if the resulting date would be invalid\u003c/li\u003e\n     * \u003cli\u003eAdjust the day-of-month to the last valid day if necessary\u003c/li\u003e\n     * \u003c/ol\u003e\n     * \u003cp\u003e\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param monthsToSubtract  the months to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusMonths(long monthsToSubtract) {\n        return (monthsToSubtract \u003d\u003d Long.MIN_VALUE ? plusMonths(Long.MAX_VALUE).plusMonths(1) : plusMonths(-monthsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of weeks subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param weeksToSubtract  the weeks to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusWeeks(long weeksToSubtract) {\n        return (weeksToSubtract \u003d\u003d Long.MIN_VALUE ? plusWeeks(Long.MAX_VALUE).plusWeeks(1) : plusWeeks(-weeksToSubtract));\n    }\n\n    /**\n     * Returns a copy of this {@code LocalDate} with the specified number of days subtracted.\n     * \u003cp\u003e\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     * \u003cp\u003e\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param daysToSubtract  the days to subtract, may be negative\n     * @return a {@code LocalDate} based on this date with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    public LocalDate minusDays(long daysToSubtract) {\n        return (daysToSubtract \u003d\u003d Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-daysToSubtract));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date using the specified query.\n     * \u003cp\u003e\n     * This queries this date using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \u003cp\u003e\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param \u003cR\u003e the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public \u003cR\u003e R query(TemporalQuery\u003cR\u003e query) {\n        if (query \u003d\u003d TemporalQueries.localDate()) {\n            return (R) this;\n        }\n        return ChronoLocalDate.super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date as this object.\n     * \u003cp\u003e\n     * This returns a temporal object of the same observable type as the input\n     * with the date changed to be the same as this.\n     * \u003cp\u003e\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * passing {@link ChronoField#EPOCH_DAY} as the field.\n     * \u003cp\u003e\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal \u003d thisLocalDate.adjustInto(temporal);\n     *   temporal \u003d temporal.with(thisLocalDate);\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override  // override for Javadoc\n    public Temporal adjustInto(Temporal temporal) {\n        return ChronoLocalDate.super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the amount of time until another date in terms of the specified unit.\n     * \u003cp\u003e\n     * This calculates the amount of time between two {@code LocalDate}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code LocalDate} using {@link #from(TemporalAccessor)}.\n     * For example, the amount in days between two dates can be calculated\n     * using {@code startDate.until(endDate, DAYS)}.\n     * \u003cp\u003e\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two dates.\n     * For example, the amount in months between 2012-06-15 and 2012-08-14\n     * will only be one month as it is one day short of two months.\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   amount \u003d start.until(end, MONTHS);\n     *   amount \u003d MONTHS.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     * \u003cp\u003e\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code DAYS}, {@code WEEKS}, {@code MONTHS}, {@code YEARS},\n     * {@code DECADES}, {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS}\n     * are supported. Other {@code ChronoUnit} values will throw an exception.\n     * \u003cp\u003e\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * \u003cp\u003e\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to a {@code LocalDate}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date and the end date\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to a {@code LocalDate}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        LocalDate end \u003d LocalDate.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch ((ChronoUnit) unit) {\n                case DAYS: return daysUntil(end);\n                case WEEKS: return daysUntil(end) / 7;\n                case MONTHS: return monthsUntil(end);\n                case YEARS: return monthsUntil(end) / 12;\n                case DECADES: return monthsUntil(end) / 120;\n                case CENTURIES: return monthsUntil(end) / 1200;\n                case MILLENNIA: return monthsUntil(end) / 12000;\n                case ERAS: return end.getLong(ERA) - getLong(ERA);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.between(this, end);\n    }\n\n    long daysUntil(LocalDate end) {\n        return end.toEpochDay() - toEpochDay();  // no overflow\n    }\n\n    private long monthsUntil(LocalDate end) {\n        long packed1 \u003d getProlepticMonth() * 32L + getDayOfMonth();  // no overflow\n        long packed2 \u003d end.getProlepticMonth() * 32L + end.getDayOfMonth();  // no overflow\n        return (packed2 - packed1) / 32;\n    }\n\n    /**\n     * Calculates the period between this date and another date as a {@code Period}.\n     * \u003cp\u003e\n     * This calculates the period between two dates in terms of years, months and days.\n     * The start and end points are {@code this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The negative sign will be the same in each of year, month and day.\n     * \u003cp\u003e\n     * The calculation is performed using the ISO calendar system.\n     * If necessary, the input date will be converted to ISO.\n     * \u003cp\u003e\n     * The start date is included, but the end date is not.\n     * The period is calculated by removing complete months, then calculating\n     * the remaining number of days, adjusting to ensure that both have the same sign.\n     * The number of months is then normalized into years and months based on a 12 month year.\n     * A month is considered to be complete if the end day-of-month is greater\n     * than or equal to the start day-of-month.\n     * For example, from {@code 2010-01-15} to {@code 2011-03-18} is \"1 year, 2 months and 3 days\".\n     * \u003cp\u003e\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link Period#between(LocalDate, LocalDate)}:\n     * \u003cpre\u003e\n     *   // these two lines are equivalent\n     *   period \u003d start.until(end);\n     *   period \u003d Period.between(start, end);\n     * \u003c/pre\u003e\n     * The choice should be made based on which makes the code more readable.\n     *\n     * @param endDateExclusive  the end date, exclusive, which may be in any chronology, not null\n     * @return the period between this date and the end date, not null\n     */\n    @Override\n    public Period until(ChronoLocalDate endDateExclusive) {\n        LocalDate end \u003d LocalDate.from(endDateExclusive);\n        long totalMonths \u003d end.getProlepticMonth() - this.getProlepticMonth();  // safe\n        int days \u003d end.day - this.day;\n        if (totalMonths \u003e 0 \u0026\u0026 days \u003c 0) {\n            totalMonths--;\n            LocalDate calcDate \u003d this.plusMonths(totalMonths);\n            days \u003d (int) (end.toEpochDay() - calcDate.toEpochDay());  // safe\n        } else if (totalMonths \u003c 0 \u0026\u0026 days \u003e 0) {\n            totalMonths++;\n            days -\u003d end.lengthOfMonth();\n        }\n        long years \u003d totalMonths / 12;  // safe\n        int months \u003d (int) (totalMonths % 12);  // safe\n        return Period.of(Math.toIntExact(years), months, days);\n    }\n\n    /**\n     * Returns a sequential ordered stream of dates. The returned stream starts from this date\n     * (inclusive) and goes to {@code endExclusive} (exclusive) by an incremental step of 1 day.\n     * \u003cp\u003e\n     * This method is equivalent to {@code datesUntil(endExclusive, Period.ofDays(1))}.\n     *\n     * @param endExclusive  the end date, exclusive, not null\n     * @return a sequential {@code Stream} for the range of {@code LocalDate} values\n     * @throws IllegalArgumentException if end date is before this date\n     * @since 9\n     */\n    public Stream\u003cLocalDate\u003e datesUntil(LocalDate endExclusive) {\n        long end \u003d endExclusive.toEpochDay();\n        long start \u003d toEpochDay();\n        if (end \u003c start) {\n            throw new IllegalArgumentException(endExclusive + \" \u003c \" + this);\n        }\n        return LongStream.range(start, end).mapToObj(LocalDate::ofEpochDay);\n    }\n\n    /**\n     * Returns a sequential ordered stream of dates by given incremental step. The returned stream\n     * starts from this date (inclusive) and goes to {@code endExclusive} (exclusive).\n     * \u003cp\u003e\n     * The n-th date which appears in the stream is equal to {@code this.plus(step.multipliedBy(n))}\n     * (but the result of step multiplication never overflows). For example, if this date is\n     * {@code 2015-01-31}, the end date is {@code 2015-05-01} and the step is 1 month, then the\n     * stream contains {@code 2015-01-31}, {@code 2015-02-28}, {@code 2015-03-31}, and\n     * {@code 2015-04-30}.\n     *\n     * @param endExclusive  the end date, exclusive, not null\n     * @param step  the non-zero, non-negative {@code Period} which represents the step.\n     * @return a sequential {@code Stream} for the range of {@code LocalDate} values\n     * @throws IllegalArgumentException if step is zero, or {@code step.getDays()} and\n     *             {@code step.toTotalMonths()} have opposite sign, or end date is before this date\n     *             and step is positive, or end date is after this date and step is negative\n     * @since 9\n     */\n    public Stream\u003cLocalDate\u003e datesUntil(LocalDate endExclusive, Period step) {\n        if (step.isZero()) {\n            throw new IllegalArgumentException(\"step is zero\");\n        }\n        long end \u003d endExclusive.toEpochDay();\n        long start \u003d toEpochDay();\n        long until \u003d end - start;\n        long months \u003d step.toTotalMonths();\n        long days \u003d step.getDays();\n        if ((months \u003c 0 \u0026\u0026 days \u003e 0) || (months \u003e 0 \u0026\u0026 days \u003c 0)) {\n            throw new IllegalArgumentException(\"period months and days are of opposite sign\");\n        }\n        if (until \u003d\u003d 0) {\n            return Stream.empty();\n        }\n        int sign \u003d months \u003e 0 || days \u003e 0 ? 1 : -1;\n        if (sign \u003c 0 ^ until \u003c 0) {\n            throw new IllegalArgumentException(endExclusive + (sign \u003c 0 ? \" \u003e \" : \" \u003c \") + this);\n        }\n        if (months \u003d\u003d 0) {\n            long steps \u003d (until - sign) / days; // non-negative\n            return LongStream.rangeClosed(0, steps).mapToObj(\n                    n -\u003e LocalDate.ofEpochDay(start + n * days));\n        }\n        // 48699/1600 \u003d 365.2425/12, no overflow, non-negative result\n        long steps \u003d until * 1600 / (months * 48699 + days * 1600) + 1;\n        long addMonths \u003d months * steps;\n        long addDays \u003d days * steps;\n        long maxAddMonths \u003d months \u003e 0 ? MAX.getProlepticMonth() - getProlepticMonth()\n                : getProlepticMonth() - MIN.getProlepticMonth();\n        // adjust steps estimation\n        if (addMonths * sign \u003e maxAddMonths\n                || (plusMonths(addMonths).toEpochDay() + addDays) * sign \u003e\u003d end * sign) {\n            steps--;\n            addMonths -\u003d months;\n            addDays -\u003d days;\n            if (addMonths * sign \u003e maxAddMonths\n                    || (plusMonths(addMonths).toEpochDay() + addDays) * sign \u003e\u003d end * sign) {\n                steps--;\n            }\n        }\n        return LongStream.rangeClosed(0, steps).mapToObj(\n                n -\u003e this.plusMonths(months * n).plusDays(days * n));\n    }\n\n    /**\n     * Formats this date using the specified formatter.\n     * \u003cp\u003e\n     * This date will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    @Override  // override for Javadoc and performance\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param time  the time to combine with, not null\n     * @return the local date-time formed from this date and the specified time, not null\n     */\n    @Override\n    public LocalDateTime atTime(LocalTime time) {\n        return LocalDateTime.of(this, time);\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour and minute.\n     * The seconds and nanosecond fields will be set to zero.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute) {\n        return atTime(LocalTime.of(hour, minute));\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour, minute and second.\n     * The nanosecond field will be set to zero.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute, int second) {\n        return atTime(LocalTime.of(hour, minute, second));\n    }\n\n    /**\n     * Combines this date with a time to create a {@code LocalDateTime}.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the\n     * specified hour, minute, second and nanosecond.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param hour  the hour-of-day to use, from 0 to 23\n     * @param minute  the minute-of-hour to use, from 0 to 59\n     * @param second  the second-of-minute to represent, from 0 to 59\n     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999\n     * @return the local date-time formed from this date and the specified time, not null\n     * @throws DateTimeException if the value of any field is out of range\n     */\n    public LocalDateTime atTime(int hour, int minute, int second, int nanoOfSecond) {\n        return atTime(LocalTime.of(hour, minute, second, nanoOfSecond));\n    }\n\n    /**\n     * Combines this date with an offset time to create an {@code OffsetDateTime}.\n     * \u003cp\u003e\n     * This returns an {@code OffsetDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param time  the time to combine with, not null\n     * @return the offset date-time formed from this date and the specified time, not null\n     */\n    public OffsetDateTime atTime(OffsetTime time) {\n        return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.getOffset());\n    }\n\n    /**\n     * Combines this date with the time of midnight to create a {@code LocalDateTime}\n     * at the start of this date.\n     * \u003cp\u003e\n     * This returns a {@code LocalDateTime} formed from this date at the time of\n     * midnight, 00:00, at the start of this date.\n     *\n     * @return the local date-time of midnight at the start of this date, not null\n     */\n    public LocalDateTime atStartOfDay() {\n        return LocalDateTime.of(this, LocalTime.MIDNIGHT);\n    }\n\n    /**\n     * Returns a zoned date-time from this date at the earliest valid time according\n     * to the rules in the time-zone.\n     * \u003cp\u003e\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may not be midnight.\n     * \u003cp\u003e\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, there are two valid offsets, and the earlier one is used,\n     * corresponding to the first occurrence of midnight on the date.\n     * In the case of a gap, the zoned date-time will represent the instant just after the gap.\n     * \u003cp\u003e\n     * If the zone ID is a {@link ZoneOffset}, then the result always has a time of midnight.\n     * \u003cp\u003e\n     * To convert to a specific time in a given time-zone call {@link #atTime(LocalTime)}\n     * followed by {@link LocalDateTime#atZone(ZoneId)}.\n     *\n     * @param zone  the zone ID to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atStartOfDay(ZoneId zone) {\n        Objects.requireNonNull(zone, \"zone\");\n        // need to handle case where there is a gap from 11:30 to 00:30\n        // standard ZDT factory would result in 01:00 rather than 00:30\n        LocalDateTime ldt \u003d atTime(LocalTime.MIDNIGHT);\n        if (zone instanceof ZoneOffset \u003d\u003d false) {\n            ZoneRules rules \u003d zone.getRules();\n            ZoneOffsetTransition trans \u003d rules.getTransition(ldt);\n            if (trans !\u003d null \u0026\u0026 trans.isGap()) {\n                ldt \u003d trans.getDateTimeAfter();\n            }\n        }\n        return ZonedDateTime.of(ldt, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public long toEpochDay() {\n        long y \u003d year;\n        long m \u003d month;\n        long total \u003d 0;\n        total +\u003d 365 * y;\n        if (y \u003e\u003d 0) {\n            total +\u003d (y + 3) / 4 - (y + 99) / 100 + (y + 399) / 400;\n        } else {\n            total -\u003d y / -4 - y / -100 + y / -400;\n        }\n        total +\u003d ((367 * m - 362) / 12);\n        total +\u003d day - 1;\n        if (m \u003e 2) {\n            total--;\n            if (isLeapYear() \u003d\u003d false) {\n                total--;\n            }\n        }\n        return total - DAYS_0000_TO_1970;\n    }\n\n    /**\n     * Converts this {@code LocalDate} to the number of seconds since the epoch\n     * of 1970-01-01T00:00:00Z.\n     * \u003cp\u003e\n     * This combines this local date with the specified time and\n     * offset to calculate the epoch-second value, which is the\n     * number of elapsed seconds from 1970-01-01T00:00:00Z.\n     * Instants on the time-line after the epoch are positive, earlier\n     * are negative.\n     *\n     * @param time the local time, not null\n     * @param offset the zone offset, not null\n     * @return the number of seconds since the epoch of 1970-01-01T00:00:00Z, may be negative\n     * @since 9\n     */\n    public long toEpochSecond(LocalTime time, ZoneOffset offset) {\n        Objects.requireNonNull(time, \"time\");\n        Objects.requireNonNull(offset, \"offset\");\n        long secs \u003d toEpochDay() * SECONDS_PER_DAY + time.toSecondOfDay();\n        secs -\u003d offset.getTotalSeconds();\n        return secs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date to another date.\n     * \u003cp\u003e\n     * The comparison is primarily based on the date, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * \u003cp\u003e\n     * If all the dates being compared are instances of {@code LocalDate},\n     * then the comparison will be entirely based on the date.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link java.time.chrono.ChronoLocalDate#compareTo}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n    @Override  // override for Javadoc and performance\n    public int compareTo(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other);\n        }\n        return ChronoLocalDate.super.compareTo(other);\n    }\n\n    int compareTo0(LocalDate otherDate) {\n        int cmp \u003d (year - otherDate.year);\n        if (cmp \u003d\u003d 0) {\n            cmp \u003d (month - otherDate.month);\n            if (cmp \u003d\u003d 0) {\n                cmp \u003d (day - otherDate.day);\n            }\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date is after the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents a point on the\n     * local time-line after the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isAfter(b) \u003d\u003d false\n     *   a.isAfter(a) \u003d\u003d false\n     *   b.isAfter(a) \u003d\u003d true\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is after the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isAfter(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003e 0;\n        }\n        return ChronoLocalDate.super.isAfter(other);\n    }\n\n    /**\n     * Checks if this date is before the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents a point on the\n     * local time-line before the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isBefore(b) \u003d\u003d true\n     *   a.isBefore(a) \u003d\u003d false\n     *   b.isBefore(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is before the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isBefore(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003c 0;\n        }\n        return ChronoLocalDate.super.isBefore(other);\n    }\n\n    /**\n     * Checks if this date is equal to the specified date.\n     * \u003cp\u003e\n     * This checks to see if this date represents the same point on the\n     * local time-line as the other date.\n     * \u003cpre\u003e\n     *   LocalDate a \u003d LocalDate.of(2012, 6, 30);\n     *   LocalDate b \u003d LocalDate.of(2012, 7, 1);\n     *   a.isEqual(b) \u003d\u003d false\n     *   a.isEqual(a) \u003d\u003d true\n     *   b.isEqual(a) \u003d\u003d false\n     * \u003c/pre\u003e\n     * \u003cp\u003e\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link #compareTo(ChronoLocalDate)}\n     * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this date is equal to the specified date\n     */\n    @Override  // override for Javadoc and performance\n    public boolean isEqual(ChronoLocalDate other) {\n        if (other instanceof LocalDate) {\n            return compareTo0((LocalDate) other) \u003d\u003d 0;\n        }\n        return ChronoLocalDate.super.isEqual(other);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date is equal to another date.\n     * \u003cp\u003e\n     * Compares this {@code LocalDate} with another ensuring that the date is the same.\n     * \u003cp\u003e\n     * Only objects of type {@code LocalDate} are compared, other types return false.\n     * To compare the dates of two {@code TemporalAccessor} instances, including dates\n     * in two different chronologies, use {@link ChronoField#EPOCH_DAY} as a comparator.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (obj instanceof LocalDate) {\n            return compareTo0((LocalDate) obj) \u003d\u003d 0;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        int yearValue \u003d year;\n        int monthValue \u003d month;\n        int dayValue \u003d day;\n        return (yearValue \u0026 0xFFFFF800) ^ ((yearValue \u003c\u003c 11) + (monthValue \u003c\u003c 6) + (dayValue));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date as a {@code String}, such as {@code 2007-12-03}.\n     * \u003cp\u003e\n     * The output will be in the ISO-8601 format {@code uuuu-MM-dd}.\n     *\n     * @return a string representation of this date, not null\n     */\n    @Override\n    public String toString() {\n        int yearValue \u003d year;\n        int monthValue \u003d month;\n        int dayValue \u003d day;\n        int absYear \u003d Math.abs(yearValue);\n        StringBuilder buf \u003d new StringBuilder(10);\n        if (absYear \u003c 1000) {\n            if (yearValue \u003c 0) {\n                buf.append(yearValue - 10000).deleteCharAt(1);\n            } else {\n                buf.append(yearValue + 10000).deleteCharAt(0);\n            }\n        } else {\n            if (yearValue \u003e 9999) {\n                buf.append(\u0027+\u0027);\n            }\n            buf.append(yearValue);\n        }\n        return buf.append(monthValue \u003c 10 ? \"-0\" : \"-\")\n            .append(monthValue)\n            .append(dayValue \u003c 10 ? \"-0\" : \"-\")\n            .append(dayValue)\n            .toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Writes the object using a\n     * \u003ca href\u003d\"../../serialized-form.html#java.time.Ser\"\u003ededicated serialized form\u003c/a\u003e.\n     * @serialData\n     * \u003cpre\u003e\n     *  out.writeByte(3);  // identifies a LocalDate\n     *  out.writeInt(year);\n     *  out.writeByte(month);\n     *  out.writeByte(day);\n     * \u003c/pre\u003e\n     *\n     * @return the instance of {@code Ser}, not null\n     */\n    private Object writeReplace() {\n        return new Ser(Ser.LOCAL_DATE_TYPE, this);\n    }\n\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n\n    void writeExternal(DataOutput out) throws IOException {\n        out.writeInt(year);\n        out.writeByte(month);\n        out.writeByte(day);\n    }\n\n    static LocalDate readExternal(DataInput in) throws IOException {\n        int year \u003d in.readInt();\n        int month \u003d in.readByte();\n        int dayOfMonth \u003d in.readByte();\n        return LocalDate.of(year, month, dayOfMonth);\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:391)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

oct 18, 2024 3:12:31 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Eclipse%20Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip%21/java.base/java/time/LocalDate.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:152)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:773)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:770)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:410)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Eclipse Adoptium/jdk-11.0.24.8-hotspot/lib/src.zip!/java.base/java/time/LocalDate.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.10.18 15:12:43 INFO  compiling root (2 scala sources)
2024.10.18 15:12:43 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5' (since 54m 33.098s)
2024.10.18 15:12:43 INFO  compiling root (2 scala sources)
2024.10.18 15:12:43 INFO  time: compiled root in 0.24s
2024.10.18 15:12:43 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5' (since 54m 33.348s)
2024.10.18 15:12:43 INFO  compiling root (2 scala sources)
2024.10.18 15:12:43 INFO  compiling root (2 scala sources)
2024.10.18 15:12:43 INFO  time: compiled root in 0.19s
2024.10.18 15:12:43 INFO  {
  "jsonrpc": "2.0",
  "id": "143",
  "error": {
    "code": -32603,
    "message": "Compilation not successful"
  }
}
2024.10.18 15:12:59 INFO  compiling root (2 scala sources)
2024.10.18 15:12:59 INFO  time: compiled root in 0.22s
2024.10.18 15:13:14 INFO  compiling root (2 scala sources)
2024.10.18 15:13:14 INFO  time: compiled root in 0.82s
2024.10.18 15:13:25 INFO  compiling root (1 scala source)
2024.10.18 15:13:25 INFO  time: compiled root in 0.63s
2024.10.18 15:13:30 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.5' (since 55m 20.169s)
2024.10.18 15:13:30 INFO  tracing is disabled for protocol dap-server, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-server.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-server.trace.json
2024.10.18 15:13:30 INFO  tracing is disabled for protocol dap-client, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Proyectos\spark-datos-energia\.metals\dap-client.trace.json or C:\Users\jalva\AppData\Local\scalameta\metals\cache\dap-client.trace.json
2024.10.18 15:13:30 INFO  Starting debug proxy for [example.Main]
2024.10.18 15:13:30 INFO  Loaded expression compiler in 2 milliseconds
2024.10.18 15:13:30 WARN  Found duplicate entry core_2.13 in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:13:30 WARN  Found duplicate entry jersey-server in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:13:30 WARN  Found duplicate entry jersey-client in debuggee MainClassDebugAdapter(root, example.Main)
2024.10.18 15:13:33 INFO  Loaded all sources and classes in 2 seconds
2024.10.18 15:13:33 INFO  Initialized Scala 3 decoder in 0 milliseconds
2024.10.18 15:13:33 INFO  Trying to attach to remote debuggee VM kubernetes.docker.internal:55211 .
2024.10.18 15:13:33 INFO  Attaching to debuggee VM succeeded.
oct 18, 2024 3:13:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:34 INFO SparkContext: Running Spark version 3.5.0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:34 IN..._15-13-34-202.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:34 INFO SparkContext: OS info Windows 11, 10.0, amd64"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:34 IN..._15-13-34-209.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:34 INFO SparkContext: Java version 11.0.24"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:34 IN..._15-13-34-209.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:34 INFO ResourceUtils: \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:34 IN..._15-13-34-398.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:34 INFO ResourceUtils: No custom resources configured for spark.driver."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:34 IN..._15-13-34-399.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:34 INFO ResourceUtils: \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:34 IN..._15-13-34-399.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:34 INFO SparkContext: Submitted application: spark-javi"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:34 IN..._15-13-34-399.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:34 INFO ResourceProfile: Default ResourceProfile created, executor resources: Map(cores -\u003e name: cores, amount: 1, script: , vendor: , memory -\u003e name: memory, amount: 1024, script: , vendor: , offHeap -\u003e name: offHeap, amount: 0, script: , vendor: ), task resources: Map(cpus -\u003e name: cpus, amount: 1.0)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:34 IN..._15-13-34-421.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:34 INFO ResourceProfile: Limiting resource is cpu"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:34 IN..._15-13-34-424.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:34 INFO ResourceProfileManager: Added ResourceProfile id: 0"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:34 IN..._15-13-34-425.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:34 INFO SecurityManager: Changing view acls to: jalva"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:34 IN..._15-13-34-474.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:34 INFO SecurityManager: Changing modify acls to: jalva"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:34 IN..._15-13-34-475.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:34 INFO SecurityManager: Changing view acls groups to: "
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:34 IN..._15-13-34-475.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:34 INFO SecurityManager: Changing modify acls groups to: "
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:34 IN..._15-13-34-475.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:34 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:34 INFO SecurityManager: SecurityManager: authentication disabled; ui acls disabled; users with view permissions: jalva; groups with view permissions: EMPTY; users with modify permissions: jalva; groups with modify permissions: EMPTY"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:34 IN..._15-13-34-475.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO Utils: Successfully started service \u0027sparkDriver\u0027 on port 55247."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-022.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO SparkEnv: Registering MapOutputTracker"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-044.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: An illegal reflective access operation has occurred"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: An illegal ..._15-13-35-061.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Illegal reflective access by org.apache.spark.unsafe.Platform (file:/C:/Users/jalva/AppData/Local/Coursier/Cache/v1/https/repo1.maven.org/maven2/org/apache/spark/spark-unsafe_2.13/3.5.0/spark-unsafe_2.13-3.5.0.jar) to constructor java.nio.DirectByteBuffer(long,int)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Illegal ref..._15-13-35-061.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Please consider reporting this to the maintainers of org.apache.spark.unsafe.Platform"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Please cons..._15-13-35-062.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: Use --illegal-access\u003dwarn to enable warnings of further illegal reflective access operations"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: Use --illeg..._15-13-35-062.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "WARNING: All illegal access operations will be denied in a future release"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 9: r_WARNING: All illegal..._15-13-35-062.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO SparkEnv: Registering BlockManagerMaster"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-072.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO BlockManagerMasterEndpoint: Using org.apache.spark.storage.DefaultTopologyMapper for getting topology information"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-088.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO BlockManagerMasterEndpoint: BlockManagerMasterEndpoint up"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-089.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO SparkEnv: Registering BlockManagerMasterHeartbeat"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-092.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO DiskBlockManager: Created local directory at C:\\Users\\jalva\\AppData\\Local\\Temp\\blockmgr-6b7989a9-0783-4d5e-afef-348700eeb44c"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-112.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO MemoryStore: MemoryStore started with capacity 2.2 GiB"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-139.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO SparkEnv: Registering OutputCommitCoordinator"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-152.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO JettyUtils: Start Jetty 0.0.0.0:4040 for SparkUI"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-263.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 WARN Utils: Service \u0027SparkUI\u0027 could not bind on port 4040. Attempting port 4041."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 WA..._15-13-35-304.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO Utils: Successfully started service \u0027SparkUI\u0027 on port 4041."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-316.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO Executor: Starting executor ID driver on host host.docker.internal"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-398.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO Executor: OS info Windows 11, 10.0, amd64"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-399.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO Executor: Java version 11.0.24"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-399.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO Executor: Starting executor with user classpath (userClassPathFirst \u003d false): \u0027\u0027"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-405.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO Executor: Created or updated repl class loader org.apache.spark.util.MutableURLClassLoader@7e9f2c32 for default."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-406.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO Utils: Successfully started service \u0027org.apache.spark.network.netty.NettyBlockTransferService\u0027 on port 55298."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-431.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO NettyBlockTransferService: Server created on host.docker.internal:55298"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-432.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO BlockManager: Using org.apache.spark.storage.RandomBlockReplicationPolicy for block replication policy"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-433.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO BlockManagerMaster: Registering BlockManager BlockManagerId(driver, host.docker.internal, 55298, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-439.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO BlockManagerMasterEndpoint: Registering block manager host.docker.internal:55298 with 2.2 GiB RAM, BlockManagerId(driver, host.docker.internal, 55298, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-442.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO BlockManagerMaster: Registered BlockManager BlockManagerId(driver, host.docker.internal, 55298, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-444.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO BlockManager: Initialized BlockManager: BlockManagerId(driver, host.docker.internal, 55298, None)"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-445.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO SparkContext: Invoking stop() from shutdown hook"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-777.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO SparkContext: SparkContext is stopping with exitCode 0."
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-778.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO SparkUI: Stopped Spark web UI at http://host.docker.internal:4041"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-778.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO MapOutputTrackerMasterEndpoint: MapOutputTrackerMasterEndpoint stopped!"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-792.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO MemoryStore: MemoryStore cleared"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-805.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO BlockManager: BlockManager stopped"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-805.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO BlockManagerMaster: BlockManagerMaster stopped"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-811.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO OutputCommitCoordinator$OutputCommitCoordinatorEndpoint: OutputCommitCoordinator stopped!"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-815.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO SparkContext: Successfully stopped SparkContext"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-821.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO ShutdownHookManager: Shutdown hook called"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-822.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

oct 18, 2024 3:13:35 P. M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTENCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "build/logMessage",
  "params": {
    "type": 1,
    "message": "24/10/18 15:13:35 INFO ShutdownHookManager: Deleting directory C:\\Users\\jalva\\AppData\\Local\\Temp\\spark-79cff079-c582-436f-9d16-6707703c5145"
  }
}
java.nio.file.InvalidPathException: Illegal char <:> at index 13: r_24/10/18 15:13:35 IN..._15-13-35-823.md
	at java.base/sun.nio.fs.WindowsPathParser.normalize(WindowsPathParser.java:182)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:153)
	at java.base/sun.nio.fs.WindowsPathParser.parse(WindowsPathParser.java:77)
	at java.base/sun.nio.fs.WindowsPath.parse(WindowsPath.java:92)
	at java.base/sun.nio.fs.WindowsFileSystem.getPath(WindowsFileSystem.java:232)
	at java.base/java.nio.file.Path.resolve(Path.java:515)
	at scala.meta.internal.metals.StdReporter.reportPath(ReportContext.scala:165)
	at scala.meta.internal.metals.StdReporter.create(ReportContext.scala:131)
	at scala.meta.internal.builds.BspErrorHandler.createReport(BSPErrorHandler.scala:38)
	at scala.meta.internal.builds.BspErrorHandler.onError(BSPErrorHandler.scala:22)
	at scala.meta.internal.metals.clients.language.ForwardingMetalsBuildClient.onBuildLogMessage(ForwardingMetalsBuildClient.scala:136)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

2024.10.18 15:13:36 INFO  Canceling debug proxy for [example.Main]
2024.10.18 15:13:36 INFO  Closing debug server tcp://0.0.0.0:55208
oct 18, 2024 3:16:04 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
oct 18, 2024 3:16:05 P. M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMACIÓN: Unsupported notification method: $/setTrace
2024.10.21 14:38:04 INFO  Shutting down server
2024.10.21 14:38:04 INFO  shutting down Metals
2024.10.21 14:38:04 INFO  Shut down connection with build server.
2024.10.21 14:38:04 INFO  Shut down connection with build server.
2024.10.21 14:38:04 INFO  Exiting server
